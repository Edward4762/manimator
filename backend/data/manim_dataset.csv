Code,prompt
"from manim import *

class ManimCELogo(Scene):
    def construct(self):
        self.camera.background_color = ""#ece6e2""
        logo_green = ""#87c2a5""
        logo_blue = ""#525893""
        logo_red = ""#e07a5f""
        logo_black = ""#343434""
        ds_m = MathTex(r""\mathbb{M}"", fill_color=logo_black).scale(7)
        ds_m.shift(2.25 * LEFT + 1.5 * UP)
        circle = Circle(color=logo_green, fill_opacity=1).shift(LEFT)
        square = Square(color=logo_blue, fill_opacity=1).shift(UP)
        triangle = Triangle(color=logo_red, fill_opacity=1).shift(RIGHT)
        logo = VGroup(triangle, square, circle, ds_m)  # order matters
        logo.move_to(ORIGIN)
        self.add(logo)","""Create a Manim animation scene called 'ManimCELogo' with a background color of #ece6e2. The scene must include the following elements: 1. A green filled circle (color #87c2a5) shifted 1 unit to the left. 2. A blue filled square (color #525893) shifted 1 unit upward. 3. A red filled right-pointing triangle (color #e07a5f) shifted 1 unit to the right. 4. A black double-struck 'M' symbol (MathTex of ""\mathbb{M}"" in color #343434), scaled by 7x, then shifted 2.25 units left and 1.5 units up. Stack these elements into a VGroup in the order: triangle first, square next, circle third, and the M last. Finally, move the entire group to the exact center of the screen (ORIGIN) and display them as a unified logo. Use the latest Manim syntax (from manim import *, classes like Scene, VGroup, etc.), and ensure all transformations (shifts, scaling) are applied in the sequence described before grouping and centering the composition."""
"from manim import *

class BraceAnnotation(Scene):
    def construct(self):
        dot = Dot([-2, -1, 0])
        dot2 = Dot([2, 1, 0])
        line = Line(dot.get_center(), dot2.get_center()).set_color(ORANGE)
        b1 = Brace(line)
        b1text = b1.get_text(""Horizontal distance"")
        b2 = Brace(line, direction=line.copy().rotate(PI / 2).get_unit_vector())
        b2text = b2.get_tex(""x-x_1"")
        self.add(line, dot, dot2, b1, b2, b1text, b2text)","Create a Manim code for an animation scene showing two dots at (-2, -1, 0) and (2, 1, 0) connected by an orange line. Include two braces: the first shows ""Horizontal distance"" below the line. The second brace uses a direction vector derived by rotating the line's original direction vector by 90 degrees (π/2 radians) and is labeled with the LaTeX expression ""x−x₁"". All elements must be shown from the start without any animations."
"from manim import *

class VectorArrow(Scene):
    def construct(self):
        dot = Dot(ORIGIN)
        arrow = Arrow(ORIGIN, [2, 2, 0], buff=0)
        numberplane = NumberPlane()
        origin_text = Text('(0, 0)').next_to(dot, DOWN)
        tip_text = Text('(2, 2)').next_to(arrow.get_end(), RIGHT)
        self.add(numberplane, dot, arrow, origin_text, tip_text)","Create a Manim scene showing a 2D coordinate system with a number plane. Include a small dot at the origin (0,0) with its label ""(0, 0)"" displayed below it. Draw a vector arrow from the origin to the point (2, 2) without any buffer overlap. Add the label ""(2, 2)"" positioned to the right of the arrow's tip. All elements should appear simultaneously in the initial frame without any animations or transformations."
"from manim import *

class GradientImageFromArray(Scene):
    def construct(self):
        n = 256
        imageArray = np.uint8(
            [[i * 256 / n for i in range(0, n)] for _ in range(0, n)]
        )
        image = ImageMobject(imageArray).scale(2)
        image.background_rectangle = SurroundingRectangle(image, color=GREEN)
        self.add(image, image.background_rectangle)","""Create a Manim scene that displays a horizontal gradient image. The gradient should be generated from a 256x256 numerical array where each row contains values increasing from 0 to 255 from left to right. Convert this array to an 8-bit image using ImageMobject, scale it by 2x, and surround it with a green rectangular frame. The final scene should show the gradient image enclosed in its green border without any animations, just stationary display."""
"from manim import *

class BooleanOperations(Scene):
    def construct(self):
        ellipse1 = Ellipse(
            width=4.0, height=5.0, fill_opacity=0.5, color=BLUE, stroke_width=10
        ).move_to(LEFT)
        ellipse2 = ellipse1.copy().set_color(color=RED).move_to(RIGHT)
        bool_ops_text = MarkupText(""<u>Boolean Operation</u>"").next_to(ellipse1, UP * 3)
        ellipse_group = Group(bool_ops_text, ellipse1, ellipse2).move_to(LEFT * 3)
        self.play(FadeIn(ellipse_group))

        i = Intersection(ellipse1, ellipse2, color=GREEN, fill_opacity=0.5)
        self.play(i.animate.scale(0.25).move_to(RIGHT * 5 + UP * 2.5))
        intersection_text = Text(""Intersection"", font_size=23).next_to(i, UP)
        self.play(FadeIn(intersection_text))

        u = Union(ellipse1, ellipse2, color=ORANGE, fill_opacity=0.5)
        union_text = Text(""Union"", font_size=23)
        self.play(u.animate.scale(0.3).next_to(i, DOWN, buff=union_text.height * 3))
        union_text.next_to(u, UP)
        self.play(FadeIn(union_text))

        e = Exclusion(ellipse1, ellipse2, color=YELLOW, fill_opacity=0.5)
        exclusion_text = Text(""Exclusion"", font_size=23)
        self.play(e.animate.scale(0.3).next_to(u, DOWN, buff=exclusion_text.height * 3.5))
        exclusion_text.next_to(e, UP)
        self.play(FadeIn(exclusion_text))

        d = Difference(ellipse1, ellipse2, color=PINK, fill_opacity=0.5)
        difference_text = Text(""Difference"", font_size=23)
        self.play(d.animate.scale(0.3).next_to(u, LEFT, buff=difference_text.height * 3.5))
        difference_text.next_to(d, UP)
        self.play(FadeIn(difference_text))","""Create an animation explaining Boolean operations on two ellipses using a graphics library. Start by displaying two overlapping ellipses: the first (blue) on the left, the second (red) on the right. Add an underlined title 'Boolean Operation' above them. Group and center-left align these elements, then fade them in. Next, animate four operations:1) **Intersection**: Show a green shape of their overlapping area scaled-down at top-right. Add 'Intersection' text above it.2) **Union**: Show an orange combined shape scaled-down below the intersection. Add 'Union' text above.3) **Exclusion**: Show a yellow non-overlapping parts shape scaled-down further below. Add 'Exclusion' text above.4) **Difference**: Show a pink shape of ellipse1 minus ellipse2 scaled-down left of union. Add 'Difference' text above. Position all operation shapes and labels without overlapping, using consistent spacing and font sizes. Use smooth transitions for object scaling/moving and text fades."""
"from manim import *

class PointMovingOnShapes(Scene):
    def construct(self):
        circle = Circle(radius=1, color=BLUE)
        dot = Dot()
        dot2 = dot.copy().shift(RIGHT)
        self.add(dot)

        line = Line([3, 0, 0], [5, 0, 0])
        self.add(line)

        self.play(GrowFromCenter(circle))
        self.play(Transform(dot, dot2))
        self.play(MoveAlongPath(dot, circle), run_time=2, rate_func=linear)
        self.play(Rotating(dot, about_point=[2, 0, 0]), run_time=1.5)
        self.wait()","Create a Manim animation scene that includes the following visual elements and transformations step-by-step:  
1. Start with a single Dot on the screen.  
2. Add a horizontal Line from coordinates (3, 0, 0) to (5, 0, 0).  
3. Animate a blue Circle (radius 1) to grow from its center.  
4. Transition (transform) the initial Dot to a second Dot positioned to the right of the first.  
5. Move the Dot along the circumference of the Circle for 2 seconds using linear motion.  
6. Immediately after, rotate the Dot around the point (2, 0, 0) for 1.5 seconds.  
7. End with a brief pause (self.wait()).Ensure objects and animations follow this precise sequence and timing."
"from manim import *

class MovingAround(Scene):
    def construct(self):
        square = Square(color=BLUE, fill_opacity=1)

        self.play(square.animate.shift(LEFT))
        self.play(square.animate.set_fill(ORANGE))
        self.play(square.animate.scale(0.3))
        self.play(square.animate.rotate(0.4))","""Create a Manim animation scene where a square starts as a solid blue shape. The square first moves to the left, then changes its fill color to orange, scales down to 30% of its original size, and finally rotates 0.4 radians clockwise. Ensure each transformation occurs sequentially as individual animated steps."""
"from manim import *

class MovingAngle(Scene):
    def construct(self):
        rotation_center = LEFT

        theta_tracker = ValueTracker(110)
        line1 = Line(LEFT, RIGHT)
        line_moving = Line(LEFT, RIGHT)
        line_ref = line_moving.copy()
        line_moving.rotate(
            theta_tracker.get_value() * DEGREES, about_point=rotation_center
        )
        a = Angle(line1, line_moving, radius=0.5, other_angle=False)
        tex = MathTex(r""\theta"").move_to(
            Angle(
                line1, line_moving, radius=0.5 + 3 * SMALL_BUFF, other_angle=False
            ).point_from_proportion(0.5)
        )

        self.add(line1, line_moving, a, tex)
        self.wait()

        line_moving.add_updater(
            lambda x: x.become(line_ref.copy()).rotate(
                theta_tracker.get_value() * DEGREES, about_point=rotation_center
            )
        )

        a.add_updater(
            lambda x: x.become(Angle(line1, line_moving, radius=0.5, other_angle=False))
        )
        tex.add_updater(
            lambda x: x.move_to(
                Angle(
                    line1, line_moving, radius=0.5 + 3 * SMALL_BUFF, other_angle=False
                ).point_from_proportion(0.5)
            )
        )

        self.play(theta_tracker.animate.set_value(40))
        self.play(theta_tracker.animate.increment_value(140))
        self.play(tex.animate.set_color(RED), run_time=0.5)
        self.play(theta_tracker.animate.set_value(350))","Design a Manim Python scene that visualizes the angle between two lines during a series of rotational movements. Specify the following details:
- Two lines originate from a common rotation center at the left side of the frame. The first line (line1) remains static while the second (line_moving) rotates around this point.
- An arc showing the angle between the lines is visible (radius 0.5), accompanied by a ""θ"" label positioned midway along the outer edge of the arc.
- The visualizations must update dynamically:
  1. Starting angle between the lines is set to 110°. Initially display all elements.
  2. First animation reduces this angle smoothly to 40°, then increases by another 140° (resulting in a total of 180° from the starting orientation).
  3. After the second step, briefly change the ""θ"" label’s color to red for half a second.
  4. Conclude by rotating the moving line until it forms an angle of 350° with the stationary line.
- The angle arc and label positions must continuously adjust their orientation, size, and positioning relative to the lines during every rotation phase. The rotation occurs about the shared left endpoint as the pivot point.
- Ensure smooth transitions by dynamically updating the angle visualization elements (arc and text) in real-time using tracker values."
"from manim import *

class MovingDots(Scene):
    def construct(self):
        d1,d2=Dot(color=BLUE),Dot(color=GREEN)
        dg=VGroup(d1,d2).arrange(RIGHT,buff=1)
        l1=Line(d1.get_center(),d2.get_center()).set_color(RED)
        x=ValueTracker(0)
        y=ValueTracker(0)
        d1.add_updater(lambda z: z.set_x(x.get_value()))
        d2.add_updater(lambda z: z.set_y(y.get_value()))
        l1.add_updater(lambda z: z.become(Line(d1.get_center(),d2.get_center())))
        self.add(d1,d2,l1)
        self.play(x.animate.set_value(5))
        self.play(y.animate.set_value(4))
        self.wait()","Create a Manim animation scene that starts with two dots: a blue dot and a green dot initially positioned horizontally apart (aligned to the left). A red line connects the centers of the two dots. First, animate the blue dot moving smoothly to the right (along the x-axis) to a position 5 units right of its original x-coordinate. While the blue dot moves, the red line must dynamically adjust its endpoints in real-time to stay connected between the two dots. After the blue dot stops, animate the green dot moving upward (along the y-axis) to a position 4 units above its original y-coordinate, while the red line continues to update its orientation and length throughout both movements. Ensure smooth transitions and continuous line adjustments using Manim's updater functions."
"from manim import *

class MovingGroupToDestination(Scene):
    def construct(self):
        group = VGroup(Dot(LEFT), Dot(ORIGIN), Dot(RIGHT, color=RED), Dot(2 * RIGHT)).scale(1.4)
        dest = Dot([4, 3, 0], color=YELLOW)
        self.add(group, dest)
        self.play(group.animate.shift(dest.get_center() - group[2].get_center()))
        self.wait(0.5)","Create a Manim animation scene with the following elements and movements:

1. **Visual Setup:**
   - Four dots arranged horizontally from left to right:
     - First dot at the far left edge (LEFT constant).
     - Second dot at the center (ORIGIN).
     - Third dot (red color) at the right edge (RIGHT constant).
     - Fourth dot at twice the right edge position (2*RIGHT).
     - All dots are scaled by 1.4x in size.
   - A yellow dot remains stationary at position (4, 3, 0).

2. **Animation Steps:**
   - Begin by showing the initial positions of the four-dot group and the yellow destination dot.
   - The group shifts as a whole, moving so the red third dot lands exactly on the yellow target’s location. The shift is calculated so that the red dot moves directly to (4,3), while keeping the other dots’ relative spacing unchanged.
   - After the shift, freeze the screen for 0.5 seconds.

3. **Technical Details:**
   - Use standard Manim classes like VGroup and Dot.
   - The group’s movement must use vector math to calculate the translation required to place the red dot at the destination point.
   - The yellow dot must remain visible and stationary throughout the scene."
"from manim import *

class MovingFrameBox(Scene):
    def construct(self):
        text=MathTex(
            ""\\frac{d}{dx}f(x)g(x)="",""f(x)\\frac{d}{dx}g(x)"",""+"",
            ""g(x)\\frac{d}{dx}f(x)""
        )
        self.play(Write(text))
        framebox1 = SurroundingRectangle(text[1], buff = .1)
        framebox2 = SurroundingRectangle(text[3], buff = .1)
        self.play(
            Create(framebox1),
        )
        self.wait()
        self.play(
            ReplacementTransform(framebox1,framebox2),
        )
        self.wait()","Create a Manim animation scene that displays the product rule formula for derivatives. The equation should be written as: d/dx[f(x)g(x)] = f(x) d/dx g(x) + g(x) d/dx f(x). The equation elements should be split into four separate parts: the left side (d/dx[f(x)g(x)]), the equal sign and first term (f(x)d/dx g(x)), the plus sign, and the second term (g(x)d/dx f(x)). Animate these parts being written onto the screen. Then, create a moving frame box that first highlights the first term (f(x)d/dx g(x)) using a SurroundingRectangle with 0.1 unit buffer. After a 1-second pause, transform the frame box to highlight the second term (g(x)d/dx f(x)). Include 1-second pauses after each major animation step."
"from manim import *

class RotationUpdater(Scene):
    def construct(self):
        def updater_forth(mobj, dt):
            mobj.rotate_about_origin(dt)
        def updater_back(mobj, dt):
            mobj.rotate_about_origin(-dt)
        line_reference = Line(ORIGIN, LEFT).set_color(WHITE)
        line_moving = Line(ORIGIN, LEFT).set_color(YELLOW)
        line_moving.add_updater(updater_forth)
        self.add(line_reference, line_moving)
        self.wait(2)
        line_moving.remove_updater(updater_forth)
        line_moving.add_updater(updater_back)
        self.wait(2)
        line_moving.remove_updater(updater_back)
        self.wait(0.5)","Create a Manim animation scene showing two lines arranged vertically from the origin: a white reference line (stationary) pointing to the left, and a yellow moving line (initially overlapping the reference line). The yellow line should first rotate clockwise around the origin continuously for 2 seconds, then reverse direction to rotate counter-clockwise for another 2 seconds, and finally stop moving while remaining on screen for an additional 0.5 seconds. The rotation must occur in real-time with smooth speed, and the reference line must stay fixed throughout the entire animation."
"from manim import *

class PointWithTrace(Scene):
    def construct(self):
        path = VMobject()
        dot = Dot()
        path.set_points_as_corners([dot.get_center(), dot.get_center()])
        def update_path(path):
            previous_path = path.copy()
            previous_path.add_points_as_corners([dot.get_center()])
            path.become(previous_path)
        path.add_updater(update_path)
        self.add(path, dot)
        self.play(Rotating(dot, radians=PI, about_point=RIGHT, run_time=2))
        self.wait()
        self.play(dot.animate.shift(UP))
        self.play(dot.animate.shift(LEFT))
        self.wait()","Create an animation using Manim where a dot leaves a visible trail (path) as it moves. The animation should start with the dot stationary, then perform a 180-degree rotation around a point located to the right of the screen, taking 2 seconds. After pausing briefly, the dot moves upward, then shifts toward the left, with each movement as separate animated steps. The path line should continuously update to follow the dot’s real-time position during all movements. Specify the use of an updater function for the path and mention the exact rotation angle, direction shifts (UP, LEFT), and durations for rotational motion."
"from manim import *

class SinAndCosFunctionPlot(Scene):
    def construct(self):
        axes = Axes(
            x_range=[-10, 10.3, 1],
            y_range=[-1.5, 1.5, 1],
            x_length=10,
            axis_config={""color"": GREEN},
            x_axis_config={
                ""numbers_to_include"": np.arange(-10, 10.01, 2),
                ""numbers_with_elongated_ticks"": np.arange(-10, 10.01, 2),
            },
            tips=False,
        )
        axes_labels = axes.get_axis_labels()
        sin_graph = axes.plot(lambda x: np.sin(x), color=BLUE)
        cos_graph = axes.plot(lambda x: np.cos(x), color=RED)

        sin_label = axes.get_graph_label(
            sin_graph, ""\\sin(x)"", x_val=-10, direction=UP / 2
        )
        cos_label = axes.get_graph_label(cos_graph, label=""\\cos(x)"")

        vert_line = axes.get_vertical_line(
            axes.i2gp(TAU, cos_graph), color=YELLOW, line_func=Line
        )
        line_label = axes.get_graph_label(
            cos_graph, r""x=2\pi"", x_val=TAU, direction=UR, color=WHITE
        )

        plot = VGroup(axes, sin_graph, cos_graph, vert_line)
        labels = VGroup(axes_labels, sin_label, cos_label, line_label)
        self.add(plot, labels)","Create a Manim animation scene that simultaneously displays the graphs of sin(x) and cos(x) on the same coordinate plane. The sine curve should be blue, the cosine curve red, and both should have their respective function labels attached near the graphs. Include a set of axes with x ranging from -10 to 10 and y from -1.5 to 1.5. The axes must have green coloration, numerical markings every 2 units along the x-axis, and extended ticks at those intervals. Add a vertical yellow line intersecting the cosine graph at x=2π (TAU), with a label ""x=2π"" positioned to the upper right of this line. All graphical elements (axes, curves, labels, and the vertical line) should be properly positioned and grouped in the scene."
"from manim import *

class ArgMinExample(Scene):
    def construct(self):
        ax = Axes(
            x_range=[0, 10], y_range=[0, 100, 10], axis_config={""include_tip"": False}
        )
        labels = ax.get_axis_labels(x_label=""x"", y_label=""f(x)"")

        t = ValueTracker(0)

        def func(x):
            return 2 * (x - 5) ** 2
        graph = ax.plot(func, color=MAROON)

        initial_point = [ax.coords_to_point(t.get_value(), func(t.get_value()))]
        dot = Dot(point=initial_point)

        dot.add_updater(lambda x: x.move_to(ax.c2p(t.get_value(), func(t.get_value()))))
        x_space = np.linspace(*ax.x_range[:2],200)
        minimum_index = func(x_space).argmin()

        self.add(ax, labels, graph, dot)
        self.play(t.animate.set_value(x_space[minimum_index]))
        self.wait()","Design a Manim animation scene that visualizes the process of locating the minimum value of a quadratic function. Include the following elements and movements:  
1. **Coordinate System**: Start with a 2D axis system labeled with ""x"" on the horizontal axis and ""f(x)"" on the vertical axis. The x-axis should range from 0 to 10, and the y-axis from 0 to 100 in increments of 10.  
2. **Function Graph**: Plot a downward-opening parabola (f(x) = 2*(x−5)²) in maroon color. The vertex of this parabola should be at (5, 0).  
3. **Dot Animation**: Show a dot starting at the leftmost point of the graph (at x=0, y=50) and smoothly moving along the curve toward the vertex (minimum point at (5,0)). The path should reveal the dot tracing the curve toward the lowest value.  
4. **Movement Details**: The animation must begin with all elements (axes, labels, graph) already visible. Then, the dot should animate moving from its starting position to the vertex, with its position updated continuously until it reaches the minimum point. Ensure the final frame holds on the dot at the vertex after the animation.  

(Include all transitions, including the transition of the dot's position over time, using the parabola’s equation to define its path.)"
"from manim import *

class GraphAreaPlot(Scene):
    def construct(self):
        ax = Axes(
            x_range=[0, 5],
            y_range=[0, 6],
            x_axis_config={""numbers_to_include"": [2, 3]},
            tips=False,
        )

        labels = ax.get_axis_labels()

        curve_1 = ax.plot(lambda x: 4 * x - x ** 2, x_range=[0, 4], color=BLUE_C)
        curve_2 = ax.plot(
            lambda x: 0.8 * x ** 2 - 3 * x + 4,
            x_range=[0, 4],
            color=GREEN_B,
        )

        line_1 = ax.get_vertical_line(ax.input_to_graph_point(2, curve_1), color=YELLOW)
        line_2 = ax.get_vertical_line(ax.i2gp(3, curve_1), color=YELLOW)

        riemann_area = ax.get_riemann_rectangles(curve_1, x_range=[0.3, 0.6], dx=0.03, color=BLUE, fill_opacity=0.5)
        area = ax.get_area(curve_2, [2, 3], bounded_graph=curve_1, color=GREY, opacity=0.5)

        self.add(ax, labels, curve_1, curve_2, line_1, line_2, riemann_area, area)","Please generate Manim Python code to create an animation scene showing the following elements: 

1. **Coordinate System**: 
   - A 2D axes with x-range [0,5] and y-range [0,6]. 
   - Numbers are displayed only at x=2 and x=3 on the x-axis. 
   - Tips (arrow heads) on axes are hidden.

2. **Curves**:
   - **Blue Curve (function 1)**: Plot the function f(x) = 4x - x² from x=0 to 4 using medium blue (BLUE_C). 
   - **Green Curve (function 2)**: Plot the function g(x) = 0.8x² - 3x + 4 from x=0 to 4 using bright green (GREEN_B).

3. **Vertical Lines**:
   - **First Vertical Line**: Draw a yellow vertical line at x=2 intersecting the blue curve.
   - **Second Vertical Line**: Draw a yellow vertical line at x=3 intersecting the blue curve.

4. **Riemann Rectangles**:
   - Add blue Riemann rectangles (semi-transparent fill_opacity=0.5) under the blue curve between x=0.3 and x=0.6 with very narrow width (dx=0.03).

5. **Shaded Area**:
   - Create a shaded region (gray color, 50% opacity) between the two curves between x=2 and x=3, bounded by the blue curve above and green curve below (or vice versa as per function values).

6. **Display Order**:
   - The axes, labels, curves, vertical lines, Riemann rectangles, and shaded area should all be present in the final frame. They should be added without animations (static drawing at initialization).

Specify all parameters such as colors, ranges, graph positions, and layer ordering in the code. Ensure axes configuration includes ""numbers_to_include"" for x-axis at 2 and 3. Bounded area must use the curve_1 (blue) as the upper boundary when calculating the region."
"from manim import *

class PolygonOnAxes(Scene):
    def get_rectangle_corners(self, bottom_left, top_right):
        return [
            (top_right[0], top_right[1]),
            (bottom_left[0], top_right[1]),
            (bottom_left[0], bottom_left[1]),
            (top_right[0], bottom_left[1]),
        ]

    def construct(self):
        ax = Axes(
            x_range=[0, 10],
            y_range=[0, 10],
            x_length=6,
            y_length=6,
            axis_config={""include_tip"": False},
        )

        t = ValueTracker(5)
        k = 25

        graph = ax.plot(
            lambda x: k / x,
            color=YELLOW_D,
            x_range=[k / 10, 10.0, 0.01],
            use_smoothing=False,
        )

        def get_rectangle():
            polygon = Polygon(
                *[
                    ax.c2p(*i)
                    for i in self.get_rectangle_corners(
                        (0, 0), (t.get_value(), k / t.get_value())
                    )
                ]
            )
            polygon.stroke_width = 1
            polygon.set_fill(BLUE, opacity=0.5)
            polygon.set_stroke(YELLOW_B)
            return polygon

        polygon = always_redraw(get_rectangle)

        dot = Dot()
        dot.add_updater(lambda x: x.move_to(ax.c2p(t.get_value(), k / t.get_value())))
        dot.set_z_index(10)

        self.add(ax, graph, dot)
        self.play(Create(polygon))
        self.play(t.animate.set_value(10))
        self.play(t.animate.set_value(k / 10))
        self.play(t.animate.set_value(5))","Please design a Manim animation scene that visualizes a dynamic rectangle under the curve of the hyperbola y = 25/x on a coordinate system. The scene should include:  
- A 6x6 unit grid with x-axis and y-axis both ranging from 0 to 10.  
- The hyperbola plotted in yellow, appearing as a continuous curve.  
- A blue semi-transparent (50% opacity) rectangle that grows/shrinks such that its top-right corner always follows a moving yellow dot along the hyperbola. The rectangle’s bottom-left corner remains fixed at the origin (0,0).  
- The animation should have three phases:  
  1. Start with the rectangle at the midpoint (t=5, forming a square-like shape).  
  2. Expand the rectangle until its corner reaches x=10 (y=2.5).  
  3. Contract the rectangle so its corner moves to x=2.5 (y=10.  
  4. Return the rectangle to its original midpoint position.  
Each transition between phases must be smooth and animated continuously. The yellow dot must move precisely along the hyperbola, and the rectangle must update in real-time as the dot moves. Include the axes without arrowheads and ensure the hyperbola uses a solid yellow line."
"from manim import *

class HeatDiagramPlot(Scene):
    def construct(self):
        ax = Axes(
            x_range=[0, 40, 5],
            y_range=[-8, 32, 5],
            x_length=9,
            y_length=6,
            x_axis_config={""numbers_to_include"": np.arange(0, 40, 5)},
            y_axis_config={""numbers_to_include"": np.arange(-5, 34, 5)},
            tips=False,
        )
        labels = ax.get_axis_labels(
            x_label=Tex(r""$\Delta Q$""), y_label=Tex(r""T[$^\circ C$]"")
        )

        x_vals = [0, 8, 38, 39]
        y_vals = [20, 0, 0, -5]
        graph = ax.plot_line_graph(x_values=x_vals, y_values=y_vals)

        self.add(ax, labels, graph)","Write Manim code to create a scene that displays a coordinate system with the following specifications:
- X-axis range: 0 to 40, Y-axis range: -8 to 32 
- X-axis labeled with ΔQ and includes numerical ticks every 5 units
- Y-axis labeled with T[°C] and includes numerical ticks every 5 units starting from -5
- Axes have x_length=9 and y_length=6, with no arrow tips at ends
- The scene includes a line graph connecting four data points: (0,20), (8,0), (38,0), (39,-5)
- All elements (axes, labels, graph) should be rendered as static objects without any animations or transformations."
"from manim import *

class FollowingGraphCamera(MovingCameraScene):
    def construct(self):
        self.camera.frame.save_state()

        # create the axes and the curve
        ax = Axes(x_range=[-1, 10], y_range=[-1, 10])
        graph = ax.plot(lambda x: np.sin(x), color=BLUE, x_range=[0, 3 * PI])

        # create dots based on the graph
        moving_dot = Dot(ax.i2gp(graph.t_min, graph), color=ORANGE)
        dot_1 = Dot(ax.i2gp(graph.t_min, graph))
        dot_2 = Dot(ax.i2gp(graph.t_max, graph))

        self.add(ax, graph, dot_1, dot_2, moving_dot)
        self.play(self.camera.frame.animate.scale(0.5).move_to(moving_dot))

        def update_curve(mob):
            mob.move_to(moving_dot.get_center())

        self.camera.frame.add_updater(update_curve)
        self.play(MoveAlongPath(moving_dot, graph, rate_func=linear))
        self.camera.frame.remove_updater(update_curve)

        self.play(Restore(self.camera.frame))","Create a Manim animation scene where a camera follows a moving dot tracing a sine curve on an axes graph. Visual elements should include:  
1. A coordinate system (Axes) with x-range [-1, 10] and y-range [-1, 10].  
2. A blue sine curve (sin(x)) plotted from x=0 to 3π.  
3. Two stationary dots: one at the starting point (x=0) and one at the ending point (x=3π) of the sine curve.  
4. A moving orange dot that starts at the beginning of the sine curve.  

Animation steps:  
- Start with the full view of the axes and graph.  
- Zoom the camera frame to 50% scale and center it on the moving orange dot’s starting position.  
- Animate the moving dot tracing the sine curve from start to end *while the camera continuously follows its motion in real-time*.  
- After reaching the end, return the camera frame to the initial full view.  

Ensure smooth transitions and real-time camera tracking during the movement."
"from manim import *

class MovingZoomedSceneAround(ZoomedScene):
# contributed by TheoremofBeethoven, www.youtube.com/c/TheoremofBeethoven
    def __init__(self, **kwargs):
        ZoomedScene.__init__(
            self,
            zoom_factor=0.3,
            zoomed_display_height=1,
            zoomed_display_width=6,
            image_frame_stroke_width=20,
            zoomed_camera_config={
                ""default_frame_stroke_width"": 3,
                },
            **kwargs
        )

    def construct(self):
        dot = Dot().shift(UL * 2)
        image = ImageMobject(np.uint8([[0, 100, 30, 200],
                                       [255, 0, 5, 33]]))
        image.height = 7
        frame_text = Text(""Frame"", color=PURPLE, font_size=67)
        zoomed_camera_text = Text(""Zoomed camera"", color=RED, font_size=67)

        self.add(image, dot)
        zoomed_camera = self.zoomed_camera
        zoomed_display = self.zoomed_display
        frame = zoomed_camera.frame
        zoomed_display_frame = zoomed_display.display_frame

        frame.move_to(dot)
        frame.set_color(PURPLE)
        zoomed_display_frame.set_color(RED)
        zoomed_display.shift(DOWN)

        zd_rect = BackgroundRectangle(zoomed_display, fill_opacity=0, buff=MED_SMALL_BUFF)
        self.add_foreground_mobject(zd_rect)

        unfold_camera = UpdateFromFunc(zd_rect, lambda rect: rect.replace(zoomed_display))

        frame_text.next_to(frame, DOWN)

        self.play(Create(frame), FadeIn(frame_text, shift=UP))
        self.activate_zooming()

        self.play(self.get_zoomed_display_pop_out_animation(), unfold_camera)
        zoomed_camera_text.next_to(zoomed_display_frame, DOWN)
        self.play(FadeIn(zoomed_camera_text, shift=UP))
        # Scale in        x   y  z
        scale_factor = [0.5, 1.5, 0]
        self.play(
            frame.animate.scale(scale_factor),
            zoomed_display.animate.scale(scale_factor),
            FadeOut(zoomed_camera_text),
            FadeOut(frame_text)
        )
        self.wait()
        self.play(ScaleInPlace(zoomed_display, 2))
        self.wait()
        self.play(frame.animate.shift(2.5 * DOWN))
        self.wait()
        self.play(self.get_zoomed_display_pop_out_animation(), unfold_camera, rate_func=lambda t: smooth(1 - t))
        self.play(Uncreate(zoomed_display_frame), FadeOut(frame))
        self.wait()","Create an animation using Manim where an image created from a NumPy array (with pixel values [[0,100,30,200],[255,0,5,33]]) of height 7 is displayed with a moving dot positioned in the upper left quadrant. The scene includes a main frame (purple, with a stroke width of 20) and a zoomed camera display (red, positioned down with stroke width 3). The zoomed display should have a background rectangle (semi-transparent) around it. 

Animate the following sequence:
1. Create the main frame (purple) around the dot and transition into zoomed view with a pop-out effect. Add text labels ""Frame"" (purple) near the main frame and ""Zoomed camera"" (red) near the zoomed display.
2. Scale the main frame by 0.5x horizontally and 1.5x vertically while shrinking/fading the text labels.
3. Perform a gradual 2x scale-in-place on the zoomed display, then shift the main frame 2.5 units downward.
4. Reverse the ""pop-out"" animation to retract the zoomed display, then remove both frames entirely to finalize.

Include all movements and transformations between frames, ensuring that the zoomed view transitions smoothly and labels fade appropriately with upward shifts. Use a smooth animation rate function for the final zoomed display removal."
"from manim import *

class FixedInFrameMObjectTest(ThreeDScene):
    def construct(self):
        axes = ThreeDAxes()
        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES)
        text3d = Text(""This is a 3D text"")
        self.add_fixed_in_frame_mobjects(text3d)
        text3d.to_corner(UL)
        self.add(axes)
        self.wait()","Create an animation using Manim where a 3D coordinate system is displayed. The camera is positioned at a 75-degree angle above the horizontal plane and rotated -45 degrees from the default front view to show the 3D axes in perspective. A static text label “This is a 3D text” must remain fixed in the upper-left corner of the screen, unaffected by the 3D camera movements. The scene should start by arranging these elements and then briefly pause to allow observation."
"from manim import *

class ThreeDLightSourcePosition(ThreeDScene):
    def construct(self):
        axes = ThreeDAxes()
        sphere = Surface(
            lambda u, v: np.array([
                1.5 * np.cos(u) * np.cos(v),
                1.5 * np.cos(u) * np.sin(v),
                1.5 * np.sin(u)
            ]), v_range=[0, TAU], u_range=[-PI / 2, PI / 2],
            checkerboard_colors=[RED_D, RED_E], resolution=(15, 32)
        )
        self.renderer.camera.light_source.move_to(3*IN) # changes the source of the light
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        self.add(axes, sphere)","Create a 3D animation scene using Manim that includes the following elements and transformations:  
1. A 3D coordinate axes (ThreeDAxes).  
2. A sphere with radius 1.5, parameterized using spherical coordinates (u and v ranges covering full sphere), rendered with a red checkerboard pattern (colors RED_D and RED_E) and resolution (15, 32).  
3. The light source is positioned at 3 units in the direction of the camera (3*IN).  
4. The 3D camera is oriented with a phi angle of 75 degrees (elevation) and a theta angle of 30 degrees (azimuth).  
5. Both the axes and the sphere must be added to the scene.  

Describe the code required to achieve these visual elements and their setup in a Manim scene class."
"from manim import *

class ThreeDCameraRotation(ThreeDScene):
    def construct(self):
        axes = ThreeDAxes()
        circle=Circle()
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        self.add(circle,axes)
        self.begin_ambient_camera_rotation(rate=0.1)
        self.wait()
        self.stop_ambient_camera_rotation()
        self.move_camera(phi=75 * DEGREES, theta=30 * DEGREES)
        self.wait()","Create a Manim animation scene where a 3D coordinate system (axes) and a circle are displayed. Initially, the camera is positioned at a 75-degree angle (phi) and 30-degree azimuth (theta). The camera should smoothly rotate around the scene ( ambient rotation with a rate of 0.1) for several seconds, then abruptly stop. After stopping, reset the camera back to its original orientation (75° phi, 30° theta) and hold the view for a few seconds. Use Manim's ThreeDScene and appropriate methods to implement the camera movements and object placement."
"from manim import *

class ThreeDCameraIllusionRotation(ThreeDScene):
    def construct(self):
        axes = ThreeDAxes()
        circle=Circle()
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        self.add(circle,axes)
        self.begin_3dillusion_camera_rotation(rate=2)
        self.wait(PI/2)
        self.stop_3dillusion_camera_rotation()","Create a Manim animation showing a 3D scene with a circle and 3D coordinate axes. The camera starts at a 75-degree elevation angle (phi) and 30-degree azimuthal angle (theta). The camera then smoothly rotates around the central axis, creating an illusion that the circle and axes are spinning. The rotation should have a rate of 2, continue for π/2 seconds, then suddenly stop. Include camera orientation setup and use 3D scene methods for rotation control."
"from manim import *

class ThreeDSurfacePlot(ThreeDScene):
    def construct(self):
        resolution_fa = 24
        self.set_camera_orientation(phi=75 * DEGREES, theta=-30 * DEGREES)

        def param_gauss(u, v):
            x = u
            y = v
            sigma, mu = 0.4, [0.0, 0.0]
            d = np.linalg.norm(np.array([x - mu[0], y - mu[1]]))
            z = np.exp(-(d ** 2 / (2.0 * sigma ** 2)))
            return np.array([x, y, z])

        gauss_plane = Surface(
            param_gauss,
            resolution=(resolution_fa, resolution_fa),
            v_range=[-2, +2],
            u_range=[-2, +2]
        )

        gauss_plane.scale(2, about_point=ORIGIN)
        gauss_plane.set_style(fill_opacity=1,stroke_color=GREEN)
        gauss_plane.set_fill_by_checkerboard(ORANGE, BLUE, opacity=0.5)
        axes = ThreeDAxes()
        self.add(axes,gauss_plane)","Create a 3D animation scene showing a Gaussian surface plotted over a coordinate system. The scene should include: 

1. A 3D rendered Gaussian surface centered at the origin, with a bell-shaped curvature decreasing radially from the center. The surface must have a translucent appearance with a checkerboard pattern alternating between orange and light blue colors, with 50% opacity. 

2. The surface must be scaled uniformly to double its original size while maintaining the center point at the origin. 

3. The scene requires a 3D coordinate axis system (x,y,z axes) visible in the background. 

4. The camera perspective should be set to: 
   - 75 degrees elevation angle (phi) from the horizontal plane 
   - -30 degrees azimuth angle (theta) around the vertical axis 

Ensure smooth 3D rendering with high surface resolution (around 24 samples per axis). The surface edges should have green outline strokes. The animation should begin and end with the static scene showing the described elements."
"from manim import *

class OpeningManim(Scene):
    def construct(self):
        title = Tex(r""This is some \LaTeX"")
        basel = MathTex(r""\sum_{n=1}^\infty \frac{1}{n^2} = \frac{\pi^2}{6}"")
        VGroup(title, basel).arrange(DOWN)
        self.play(
            Write(title),
            FadeIn(basel, shift=DOWN),
        )
        self.wait()

        transform_title = Tex(""That was a transform"")
        transform_title.to_corner(UP + LEFT)
        self.play(
            Transform(title, transform_title),
            LaggedStart(*[FadeOut(obj, shift=DOWN) for obj in basel]),
        )
        self.wait()

        grid = NumberPlane()
        grid_title = Tex(""This is a grid"", font_size=72)
        grid_title.move_to(transform_title)

        self.add(grid, grid_title)  # Make sure title is on top of grid
        self.play(
            FadeOut(title),
            FadeIn(grid_title, shift=UP),
            Create(grid, run_time=3, lag_ratio=0.1),
        )
        self.wait()

        grid_transform_title = Tex(
            r""That was a non-linear function \\ applied to the grid""
        )
        grid_transform_title.move_to(grid_title, UL)
        grid.prepare_for_nonlinear_transform()
        self.play(
            grid.animate.apply_function(
                lambda p: p
                          + np.array(
                    [
                        np.sin(p[1]),
                        np.sin(p[0]),
                        0,
                    ]
                )
            ),
            run_time=3,
        )
        self.wait()
        self.play(Transform(grid_title, grid_transform_title))
        self.wait()","""A Manim animation scene that starts with a LaTeX-rendered text saying 'This is some \LaTeX' and a displayed equation of the Basel problem: \sum_{n=1}^\infty 1/n² = π²/6. The text and equation are arranged vertically. The title is written on-screen while the equation fades in from above. After a pause, the title morphs into 'That was a transform' moving to the top-left corner, while the equation components fade out downward. Next, a grid (number plane) appears with a new title 'This is a grid' replacing the previous title. The grid is drawn gradually with a lagged animation. The grid then undergoes a nonlinear transformation where each point p in the grid is shifted by [sin(p_y), sin(p_x), 0], creating a wavy distortion. Finally, the title updates to 'That was a non-linear function applied to the grid'. Include all transitions, object positions, and parameter details like shift directions, alignment, and animation types (Write, FadeIn, Transform, LaggedStart, Create). Specify equations in LaTeX syntax and grid preparation steps (e.g., prepare_for_nonlinear_transform)."""
"from manim import *

class SineCurveUnitCircle(Scene):
    # contributed by heejin_park, https://infograph.tistory.com/230
    def construct(self):
        self.show_axis()
        self.show_circle()
        self.move_dot_and_draw_curve()
        self.wait()

    def show_axis(self):
        x_start = np.array([-6,0,0])
        x_end = np.array([6,0,0])

        y_start = np.array([-4,-2,0])
        y_end = np.array([-4,2,0])

        x_axis = Line(x_start, x_end)
        y_axis = Line(y_start, y_end)

        self.add(x_axis, y_axis)
        self.add_x_labels()

        self.origin_point = np.array([-4,0,0])
        self.curve_start = np.array([-3,0,0])

    def add_x_labels(self):
        x_labels = [
            MathTex(r""\pi""), MathTex(r""2 \pi""),
            MathTex(r""3 \pi""), MathTex(r""4 \pi""),
        ]

        for i in range(len(x_labels)):
            x_labels[i].next_to(np.array([-1 + 2*i, 0, 0]), DOWN)
            self.add(x_labels[i])

    def show_circle(self):
        circle = Circle(radius=1)
        circle.move_to(self.origin_point)
        self.add(circle)
        self.circle = circle

    def move_dot_and_draw_curve(self):
        orbit = self.circle
        origin_point = self.origin_point

        dot = Dot(radius=0.08, color=YELLOW)
        dot.move_to(orbit.point_from_proportion(0))
        self.t_offset = 0
        rate = 0.25

        def go_around_circle(mob, dt):
            self.t_offset += (dt * rate)
            # print(self.t_offset)
            mob.move_to(orbit.point_from_proportion(self.t_offset % 1))

        def get_line_to_circle():
            return Line(origin_point, dot.get_center(), color=BLUE)

        def get_line_to_curve():
            x = self.curve_start[0] + self.t_offset * 4
            y = dot.get_center()[1]
            return Line(dot.get_center(), np.array([x,y,0]), color=YELLOW_A, stroke_width=2 )


        self.curve = VGroup()
        self.curve.add(Line(self.curve_start,self.curve_start))
        def get_curve():
            last_line = self.curve[-1]
            x = self.curve_start[0] + self.t_offset * 4
            y = dot.get_center()[1]
            new_line = Line(last_line.get_end(),np.array([x,y,0]), color=YELLOW_D)
            self.curve.add(new_line)

            return self.curve

        dot.add_updater(go_around_circle)

        origin_to_circle_line = always_redraw(get_line_to_circle)
        dot_to_curve_line = always_redraw(get_line_to_curve)
        sine_curve_line = always_redraw(get_curve)

        self.add(dot)
        self.add(orbit, origin_to_circle_line, dot_to_curve_line, sine_curve_line)
        self.wait(8.5)

        dot.remove_updater(go_around_circle)","Create a Manim animation scene that illustrates the relationship between a rotating point on a unit circle and the corresponding sine curve. The animation should include the following visual elements and their interactions:

1. **Coordinate System:**
   - A horizontal x-axis spanning from x = -6 to x = 6 (y=0). Place four labels: π, 2π, 3π, and 4π at x = -1, 1, 3, and 5, aligned below the axis.
   - A vertical y-axis line at x = -4 spanning from y = -2 to y = 2.

2. **Unit Circle Movement:**
   - A circle with radius 1 centered at (-4,0,0). A yellow dot starts at the circle's rightmost (angle 0°) and moves clockwise at a constant rate (completes 1 revolution per 4 seconds). 

3. **Dynamic Lines and Curve:**
   - A blue line dynamically connecting the circle’s center to the moving dot.
   - A yellow line dynamically extending horizontally from the dot to the right until aligned with the sine curve's current y-position.
   - A growing yellow sine curve starting at (-3,0,0. This curve's x-coordinate increases at 4 units per full circle revolution, while its y-coordinate matches the dot’s vertical position as it rotates.

4. **Animation Sequence:**
   - The x/y axes and labels appear first.
   - The unit circle appears next.
   - The dot begins rotating continuously while the dynamic lines and sine curve are drawn in real-time. The animation continues for 8.5 seconds before pausing briefly.

Ensure the sine curve gradually extends to the right as the dot rotates with the lines updating in sync throughout the motion."
"from manim import *


class CreateCircle(Scene):
    def construct(self):
        circle = Circle()  # create a circle
        circle.set_fill(PINK, opacity=0.5)  # set the color and transparency
        self.play(Create(circle))  # show the circle on screen","Write Manim code for an animation scene where a pink circle with 50% opacity is gradually created and displayed on the screen. The animation should start with an empty scene and end with the filled circle fully visible. Include the following steps: (1) create a circle object, (2) set its fill color to pink and opacity to 0.5, (3) use the Create() animation to draw the circle from nothing over time. Use a Scene class called CreateCircle with all elements in the construct method."
"class SquareToCircle(Scene):
    def construct(self):
        circle = Circle()  # create a circle
        circle.set_fill(PINK, opacity=0.5)  # set color and transparency

        square = Square()  # create a square
        square.rotate(PI / 4)  # rotate a certain amount

        self.play(Create(square))  # animate the creation of the square
        self.play(Transform(square, circle))  # interpolate the square into the circle
        self.play(FadeOut(square))  # fade out animation","Create an animation that includes the following steps using Manim:

1. **First, a square is drawn on the screen, rotated at 45 degrees (π/4 radians), relative to its default orientation). Use an animation to create this square.**
2. **Next, transform the square into a pink circle with 50% transparency. The transformation should smoothly interpolate both the shape and visual properties (color/opacity).**
3. **Finally, fade the resulting circle out of the screen entirely.**

Specify all visual properties: the square’s rotation and the circle’s fill color/opacity. Use Create, Transform, and FadeOut animations in sequence."
"class SquareAndCircle(Scene):
    def construct(self):
        circle = Circle()  # create a circle
        circle.set_fill(PINK, opacity=0.5)  # set the color and transparency

        square = Square()  # create a square
        square.set_fill(BLUE, opacity=0.5)  # set the color and transparency

        square.next_to(circle, RIGHT, buff=0.5)  # set the position
        self.play(Create(circle), Create(square))  # show the shapes on screen","Design a Manim animation scene that shows a pink semi-transparent circle and a blue semi-transparent square. The square must appear positioned to the right of the circle with a 0.5 unit gap between their edges. Both shapes should be drawn/stroked into existence simultaneously as the opening animation. specifies their colors, transparency levels, spatial arrangement, and synchronized creation animation without any additional elements or transitions."
"class AnimatedSquareToCircle(Scene):
    def construct(self):
        circle = Circle()  # create a circle
        square = Square()  # create a square

        self.play(Create(square))  # show the square on screen
        self.play(square.animate.rotate(PI / 4))  # rotate the square
        self.play(Transform(square, circle))  # transform the square into a circle
        self.play(
            square.animate.set_fill(PINK, opacity=0.5)
        )  # color the circle on screen","""Design an animation sequence using Manim with the following steps: first, draw a square on an empty screen. The square then rotates 45 degrees (PI/4 radians), clockwise or counter-clockwise as per Manim's default). Next, smoothly transform the square into a circle. Finally, the circle changes its color to pink while increasing its transparency to 50%. Each transformation should be an individual animated step, performed consecutively without any overlaps."""
"class DifferentRotations(Scene):
    def construct(self):
        left_square = Square(color=BLUE, fill_opacity=0.7).shift(2 * LEFT)
        right_square = Square(color=GREEN, fill_opacity=0.7).shift(2 * RIGHT)
        self.play(
            left_square.animate.rotate(PI), Rotate(right_square, angle=PI), run_time=2
        )
        self.wait()","Create a Manim Python code to animate a scene where a blue square (fill opacity 0.7) is positioned 2 units to the left of the center and a green square (fill opacity 0.7) is positioned 2 units to the right. Both squares must simultaneously rotate 180 degrees around their centers over 2 seconds. After rotation, the animation must pause briefly before ending."
"from manim import *

class TransformCycle(Scene):
    def construct(self):
        a = Circle()
        t1 = Square()
        t2 = Triangle()
        self.add(a)
        self.wait()
        for t in [t1,t2]:
            self.play(Transform(a,t))","Create a Manim scene animation where a circle appears first on the screen. After a short pause, the circle smoothly transforms into a square, then transitions from the square into a triangle. Ensure the animation uses sequential transformations where each shape replaces the previous one using smooth visual transitions, starting with the circle, followed by the square, and ending with the triangle."
"from manim import *

class CreatingMobjects(Scene):
    def construct(self):
        circle = Circle()
        self.add(circle)
        self.wait(1)
        self.remove(circle)
        self.wait(1)","Create a Manim animation scene where a circle appears on the screen and remains visible for 1 second. The circle then instantly disappears, and the scene pauses for an additional 1 second with no objects present. Describe the sequence of visual elements (appearance, removal), their timing, and transitions in detail."
"from manim import *

class Shapes(Scene):
    def construct(self):
        circle = Circle()
        square = Square()
        triangle = Triangle()

        circle.shift(LEFT)
        square.shift(UP)
        triangle.shift(RIGHT)

        self.add(circle, square, triangle)
        self.wait(1)","Create a Manim animation scene showing three shapes: a circle, a square, and a triangle. Position the circle on the left side of the screen, the square at the top, and the triangle on the right side. Add all three shapes to the scene and display them static (without movement) for 1 second."
"from manim import *

class MobjectPlacement(Scene):
    def construct(self):
        circle = Circle()
        square = Square()
        triangle = Triangle()

        # place the circle two units left from the origin
        circle.move_to(LEFT * 2)
        # place the square to the left of the circle
        square.next_to(circle, LEFT)
        # align the left border of the triangle to the left border of the circle
        triangle.align_to(circle, LEFT)

        self.add(circle, square, triangle)
        self.wait(1)","Create a Manim animation scene that positions three shapes as follows:  
1. A circle is placed two units to the left of the origin.  
2. A square is positioned directly to the left of the circle.  
3. A triangle is placed such that its left edge aligns with the left edge of the circle.  

Add all three shapes to the scene and pause the animation for one second. Write the Python code using the Manim library to implement this scene."
"from manim import *

class MobjectStyling(Scene):
    def construct(self):
        circle = Circle().shift(LEFT)
        square = Square().shift(UP)
        triangle = Triangle().shift(RIGHT)

        circle.set_stroke(color=GREEN, width=20)
        square.set_fill(YELLOW, opacity=1.0)
        triangle.set_fill(PINK, opacity=0.5)

        self.add(circle, square, triangle)
        self.wait(1)","Create an animation scene in Manim with three shapes: a circle, square, and triangle. Position the circle to the left of the center, the square above the center, and the triangle to the right of the center. Style the circle with a thick green outline (stroke width 20, no fill). Fill the square completely with solid yellow. Fill the triangle with semi-transparent pink (50% opacity). All three shapes should appear on the screen simultaneously and remain stationary for 1 second. No animations or movements except their initial appearance."
"from manim import *

class MobjectZOrder(Scene):
    def construct(self):
        circle = Circle().shift(LEFT)
        square = Square().shift(UP)
        triangle = Triangle().shift(RIGHT)

        circle.set_stroke(color=GREEN, width=20)
        square.set_fill(YELLOW, opacity=1.0)
        triangle.set_fill(PINK, opacity=0.5)

        self.add(triangle, square, circle)
        self.wait(1)","Create a Manim animation scene where three shapes are displayed with specific visual properties and initial positions, ordered by their z-index layer. The scene should include:  
1. A **green-stroked circle** (stroke width 20) shifted to the LEFT.  
2. A **solid yellow filled square** (opacity 1.0) shifted to the UP.  
3. A **partially transparent pink triangle** (opacity 0.5) shifted to the RIGHT.  
The shapes must be added to the scene in the order: **triangle first**, then **square**, then **circle**, to establish their z-order (circle appears above square, square above triangle). The animation should start with all three shapes stationary on the screen and include a 1-second wait.  

Specify the code to achieve this using Manim's `Mobject` manipulation, positioning, styling, and z-order control."
"from manim import *

class SomeAnimations(Scene):
    def construct(self):
        square = Square()

        # some animations display mobjects, ...
        self.play(FadeIn(square))

        # ... some move or rotate mobjects around...
        self.play(Rotate(square, PI/4))

        # some animations remove mobjects from the screen
        self.play(FadeOut(square))

        self.wait(1)","Create a Manim animation scene that includes the following sequence of visual elements and transformations:  
1. A square fades in gradually onto the screen.  
2. The square then rotates 45 degrees (PI/4 radians) clockwise.  
3. The square fades out completely from the screen.  
4. After the fade-out, there is a 1-second pause (black screen).  
Specify the code using Manim's Scene class and appropriate animation methods (FadeIn, Rotate, FadeOut, self.wait). Use Python syntax with Manim v2.x framework."
"from manim import *

class AnimateExample(Scene):
    def construct(self):
        square = Square().set_fill(RED, opacity=1.0)
        self.add(square)

        # animate the change of color
        self.play(square.animate.set_fill(WHITE))
        self.wait(1)

        # animate the change of position and the rotation at the same time
        self.play(square.animate.shift(UP).rotate(PI / 3))
        self.wait(1)","Create a Manim animation scene where a red square first changes its fill color to white over a duration, pauses for 1 second, then simultaneously moves upward and rotates 60 degrees (π/3 radians) while maintaining its movement, followed by a 1-second pause at the end. Use Manim's Scene class and include all necessary methods and parameters to achieve these visual transformations and timing."
"from manim import *

class RunTime(Scene):
    def construct(self):
        square = Square()
        self.add(square)
        self.play(square.animate.shift(UP), run_time=3)
        self.wait(1)","Create a Manim animation scene that starts with displaying a square. The square should then move smoothly upwards over a duration of 3 seconds. After the movement, the scene should pause for an additional 1 second before ending. Include all necessary code elements to define the scene, animate the square's upward shift with precise timing, and implement the post-animation pause. Use Manim's Scene class, Square object, animate.shift() method, and appropriate run_time/wait parameters."
"from manim import *

class Count(Animation):
    def __init__(self, number: DecimalNumber, start: float, end: float, **kwargs) -> None:
        # Pass number as the mobject of the animation
        super().__init__(number,  **kwargs)
        # Set start and end
        self.start = start
        self.end = end

    def interpolate_mobject(self, alpha: float) -> None:
        # Set value of DecimalNumber according to alpha
        value = self.start + (alpha * (self.end - self.start))
        self.mobject.set_value(value)


class CountingScene(Scene):
    def construct(self):
        # Create Decimal Number and add it to scene
        number = DecimalNumber().set_color(WHITE).scale(5)
        # Add an updater to keep the DecimalNumber centered as its value changes
        number.add_updater(lambda number: number.move_to(ORIGIN))

        self.add(number)

        self.wait()

        # Play the Count Animation to count from 0 to 100 in 4 seconds
        self.play(Count(number, 0, 100), run_time=4, rate_func=linear)

        self.wait()","Create a Manim animation scene that starts with a large white number centered on the screen. The number should begin at 0 and smoothly transition to 100 over 4 seconds, moving continuously at a constant rate. The number must remain centered throughout the entire animation, even as its value changes. Include brief pauses before the counting begins and after the counting reaches 100."
"from manim import *

class MobjectExample(Scene):
    def construct(self):
        p1 = [-1,-1, 0]
        p2 = [ 1,-1, 0]
        p3 = [ 1, 1, 0]
        p4 = [-1, 1, 0]
        a  = Line(p1,p2).append_points(Line(p2,p3).points).append_points(Line(p3,p4).points)
        point_start  = a.get_start()
        point_end    = a.get_end()
        point_center = a.get_center()
        self.add(Text(f""a.get_start() = {np.round(point_start,2).tolist()}"", font_size=24).to_edge(UR).set_color(YELLOW))
        self.add(Text(f""a.get_end() = {np.round(point_end,2).tolist()}"", font_size=24).next_to(self.mobjects[-1],DOWN).set_color(RED))
        self.add(Text(f""a.get_center() = {np.round(point_center,2).tolist()}"", font_size=24).next_to(self.mobjects[-1],DOWN).set_color(BLUE))

        self.add(Dot(a.get_start()).set_color(YELLOW).scale(2))
        self.add(Dot(a.get_end()).set_color(RED).scale(2))
        self.add(Dot(a.get_top()).set_color(GREEN_A).scale(2))
        self.add(Dot(a.get_bottom()).set_color(GREEN_D).scale(2))
        self.add(Dot(a.get_center()).set_color(BLUE).scale(2))
        self.add(Dot(a.point_from_proportion(0.5)).set_color(ORANGE).scale(2))
        self.add(*[Dot(x) for x in a.points])
        self.add(a)","Create an animation scene showing a square-shaped path formed by connecting four corner points. Include text labels at the top right corner displaying the numerical values of the path's starting point (yellow text), ending point (red text), and center (blue text). Position colored dots: yellow at the start, red at the end, green at the top and bottom edges, blue at the center, and orange at the midpoint (50% length) of the path. Add small dots along every point along the entire path, then display the full square path outline. Arrange elements so the texts and dots are correctly positioned relative to the path."
"from manim import *

class ExampleTransform(Scene):
    def construct(self):
        self.camera.background_color = WHITE
        m1 = Square().set_color(RED)
        m2 = Rectangle().set_color(RED).rotate(0.2)
        self.play(Transform(m1,m2))",Create a Manim animation showing a red square smoothly transforming into a slightly rotated red rectangle. The transformation should include changes in both shape and rotation. The animation must occur on a white background.
"from manim import *

class ExampleRotation(Scene):
    def construct(self):
        self.camera.background_color = WHITE
        m1a = Square().set_color(RED).shift(LEFT)
        m1b = Circle().set_color(RED).shift(LEFT)
        m2a = Square().set_color(BLUE).shift(RIGHT)
        m2b = Circle().set_color(BLUE).shift(RIGHT)

        points = m2a.points
        points = np.roll(points, int(len(points)/4), axis=0)
        m2a.points = points

        self.play(Transform(m1a,m1b),Transform(m2a,m2b), run_time=1)","Animate the following scene using Manim: Start with a white background. Place a red square on the left side of the screen and a blue square on the right side. Rotate the blue square's vertices to form a diamond shape. Simultaneously transform the red square into a red circle and the diamond-shaped blue square into a blue circle, both animations completing within 1 second. Ensure the objects retain their original positions during the transformations."
"from manim import *

class HelloWorld(Scene):
    def construct(self):
        text = Text(""Hello world"", font_size=144)
        self.add(text)","Create a Manim animation scene that displays the text ""Hello world"" in a large size (font size 144). The text should appear static on the screen without any movement, transformations, or animations. The scene should simply show the text as a static element."
"from manim import *

class SingleLineColor(Scene):
    def construct(self):
        text = MarkupText(
            f'all in red <span fgcolor=""{YELLOW}"">except this</span>', color=RED
        )
        self.add(text)","Create a Manim Python code to generate an animation scene where most of the text is displayed in red, except for a specific segment shown in yellow. The text should read ""all in red except this"", with the phrase ""except this"" highlighted in yellow, while the rest remains red. The scene should be static, displaying the text without any movement or transformations. Use Manim's MarkupText to handle inline color styling, setting the default text color to red and explicitly defining the yellow section within the text."
"from manim import *

class FontsExample(Scene):
    def construct(self):
        ft = Text(""Noto Sans"", font=""Noto Sans"")
        self.add(ft)","Create a Manim animation scene that displays a static text element. The text should show the word ""Noto Sans"" using the Noto Sans font. The scene should be defined in a class called FontsExample inheriting from Scene. The text object must be created with Manim's Text class, explicitly setting the font parameter to ""Noto Sans"". The text should remain stationary without any animations, movements, or transformations throughout the scene. Provide the complete Python code implementing this visual setup."
"from manim import *

class SlantsExample(Scene):
    def construct(self):
        a = Text(""Italic"", slant=ITALIC)
        self.add(a)","Create a Manim animation scene that displays the word ""Italic"" in italics as a static text object. The scene should be defined within a class named ""SlantsExample"" inheriting from Scene. The text must use Manim's Text class with the ""slant"" parameter explicitly set to ITALIC. No additional movements, transformations, or animations beyond the initial placement of the text are required."
"from manim import *

class DifferentWeight(Scene):
    def construct(self):
        import manimpango

        g = VGroup()
        weight_list = dict(
            sorted(
                {
                    weight: manimpango.Weight(weight).value
                    for weight in manimpango.Weight
                }.items(),
                key=lambda x: x[1],
            )
        )
        for weight in weight_list:
            g += Text(weight.name, weight=weight.name, font=""Open Sans"")
        self.add(g.arrange(DOWN).scale(0.5))","Create a Manim animation scene that displays all available text weight styles for the ""Open Sans"" font. Each text line should show its corresponding weight name (e.g., ""NORMAL"", ""BOLD"") in the style of that specific weight. Arrange the text elements vertically in order of increasing weight value, and scale the entire group down to 50% of the original size. Use the manimpango library to access weight enums, sort them numerically by their underlying values, and ensure the texts are stacked without overlapping."
"from manim import *

class SimpleColor(Scene):
    def construct(self):
        col = Text(""RED COLOR"", color=RED)
        self.add(col)","Create a Manim animation scene that displays the text ""RED COLOR"" in red color. The text should appear centered on the screen without any movement or transformation. The scene should only show the static red-colored text throughout the animation."
"from manim import *

class Textt2cExample(Scene):
    def construct(self):
        t2cindices = Text('Hello', t2c={'[1:-1]': BLUE}).move_to(LEFT)
        t2cwords = Text('World',t2c={'rl':RED}).next_to(t2cindices, RIGHT)
        self.add(t2cindices, t2cwords)","Create a Manim animation scene where:
1. The word ""Hello"" is displayed with the middle characters (ells) colored blue
2. The word ""World"" is displayed next to it where the final two letters ""rl"" are colored red
3. Both texts are placed side-by-side horizontally on the screen
4. The first text is positioned to the left while the second text aligns to its right using proper positioning logic
5. Use the t2c parameter for text color customization in the Text mobject
6. Ensure the full words remain intact while only specified character segments change color"
"from manim import *

class GradientExample(Scene):
    def construct(self):
        t = Text(""Hello"", gradient=(RED, BLUE, GREEN), font_size=96)
        self.add(t)","Create a Manim Scene where a single text object displays the word ""Hello"". The text should have a horizontal gradient transitioning through three colors: starting with red, followed by blue, and ending with green. The text should be large, with a font size of 96 points. The scene should show the text as a static element without any movement or animation."
"from manim import *

class t2gExample(Scene):
    def construct(self):
        t2gindices = Text(
            'Hello',
            t2g={
                '[1:-1]': (RED,GREEN),
            },
        ).move_to(LEFT)
        t2gwords = Text(
            'World',
            t2g={
                'World':(RED,BLUE),
            },
        ).next_to(t2gindices, RIGHT)
        self.add(t2gindices, t2gwords)","Write a Manim animation scene that displays two texts side by side. The first text says 'Hello'; its middle characters (excluding the first and last characters) should be displayed in red with green background using t2g character range indexing. The second text says 'World', with the entire text displayed in red text and blue background. Position the first text on the left and the second to the right of it, using their default text style for non-styled parts."
"from manim import *

class LineSpacing(Scene):
    def construct(self):
        a = Text(""Hello\nWorld"", line_spacing=1)
        b = Text(""Hello\nWorld"", line_spacing=4)
        self.add(Group(a,b).arrange(LEFT, buff=5))","""Create a Manim animation that displays two versions of the text 'Hello\nWorld' side by side. The first text must have minimal line spacing (using line_spacing=1), while the second text must have exaggerated line spacing (using line_spacing=4). Position both texts horizontally on the screen with a clear separation between them, maintaining a 5-unit buffer gap between their left edges. Ensure both texts remain stationary and are visible simultaneously without any movement or transformation."""
"from manim import *

class DisableLigature(Scene):
    def construct(self):
        li = Text(""fl ligature"",font_size=96)
        nli = Text(""fl ligature"", disable_ligatures=True, font_size=96)
        self.add(Group(li, nli).arrange(DOWN, buff=.8))","Create a Manim animation scene that visually demonstrates the effect of disabling ligatures in text. The scene should display two lines of text: the top line shows ""fl ligature"" with default ligatures enabled, and the bottom line shows the same text with ligatures explicitly disabled. Both texts should be sized at 96 font points. Position the two texts vertically centered on the screen with 0.8 units of vertical spacing between them. Ensure the arrangement clearly contrasts the fl ligature form versus individual ""f"" and ""l"" characters."
"from manim import *

class IterateColor(Scene):
    def construct(self):
        text = Text(""Colors"", font_size=96)
        for letter in text:
            letter.set_color(random_bright_color())
        self.add(text)","Create a Manim animation scene where the text ""Colors"" is displayed in a large font size (96). Each individual letter in the text must be colored with a different randomly chosen bright color. The colors should be applied such that each character's color is distinct and vibrant. The text should appear stationary on the screen without any movement or transformation, focusing solely on the variation of colors between each letter."
"from manim import *

class MarkupTest(Scene):
    def construct(self):
        text = MarkupText(
            f'<span underline=""double"" underline_color=""green"">double green underline</span> in red text<span fgcolor=""{YELLOW}""> except this</span>',
            color=RED,
            font_size=34
        )
        self.add(text)","Write a Manim Scene (class MarkupTest) which constructs an animation that displays the text ""double green underline in red text except this"". The first part ""double green underline"" should have a double underline colored green. The main text color should be red, except for the last part ""except this"" which should be in yellow. The font size of the text should be 34."
"from manim import *

class HelloLaTeX(Scene):
    def construct(self):
        tex = Tex(r""\LaTeX"", font_size=144)
        self.add(tex)",Create a Manim animation scene that displays the LaTeX logo (rendered using the Tex class with the code r'\LaTeX') at a font size of 144. The logo should be centered on the screen and displayed statically without any movement or transformations. Use the latest Manim library syntax and name the scene class HelloLaTeX.
"from manim import *

class MathTeXDemo(Scene):
    def construct(self):
        rtarrow0 = MathTex(r""\xrightarrow{x^6y^8}"", font_size=96)
        rtarrow1 = Tex(r""$\xrightarrow{x^6y^8}$"", font_size=96)

        self.add(VGroup(rtarrow0, rtarrow1).arrange(DOWN))","Create a Manim animation scene that displays two mathematical arrows side by side as vertical elements. The top arrow should be rendered using MathTex with the LaTeX expression ""\xrightarrow{x^6y^8}"" at 96-point font size. The bottom element should show the same LaTeX code but using the Tex class (enclosed in $ delimiters) with matching font size. The two elements must be positioned directly above and below each other on the screen. Provide the Python code implementing this scene using the Manim library."
"from manim import *

class AMSLaTeX(Scene):
    def construct(self):
        tex = Tex(r'$\mathtt{H} \looparrowright$ \LaTeX', font_size=144)
        self.add(tex)","""Create a Manim animation scene that displays the LaTeX expression '$\mathtt{H} \looparrowright \LaTeX$' in a 144-point font size. The text should appear centered on the screen without any movement, transformations, or animations. Provide the Python code using Manim's Scene class to achieve this static visualization."""
"from manim import *

class LaTeXAttributes(Scene):
    def construct(self):
        tex = Tex(r'Hello \LaTeX', color=BLUE, font_size=144)
        self.add(tex)","Create a Manim scene that displays the text ""Hello \LaTeX"" in blue color with a font size of 144. The text should be rendered using LaTeX and remain stationary without any animations, movements, or transformations. Provide only the Python code using the Manim library, including the proper class definition, Tex object initialization with specified style parameters, and the self.add() method to display the text."
"from manim import *

class AddPackageLatex(Scene):
    def construct(self):
        myTemplate = TexTemplate()
        myTemplate.add_to_preamble(r""\usepackage{mathrsfs}"")
        tex = Tex(
            r""$\mathscr{H} \rightarrow \mathbb{H}$"",
            tex_template=myTemplate,
            font_size=144,
        )
        self.add(tex)","Create a Manim animation scene that displays the LaTeX equation ""$\mathscr{H} \rightarrow \mathbb{H}$"" with the scripted H (using the mathrsfs LaTeX package) and the blackboard bold H (using mathbb). The equation should be rendered in a large font size of 144 points. Ensure the mathrsfs package is properly included in the LaTeX template so that the scripted H is displayed correctly. The equation should appear statically on the screen without any movement or transformation."
"from manim import *

class LaTeXSubstrings(Scene):
    def construct(self):
        tex = Tex('Hello', r'$\bigstar$', r'\LaTeX', font_size=144)
        tex.set_color_by_tex('igsta', RED)
        self.add(tex)","Create a Manim animation scene where three visual elements appear on the screen in sequence:  
1. The text ""Hello""  
2. A large LaTeX star symbol ($\bigstar$),  
3. The LaTeX logo (rendered via \LaTeX),  

All text should be displayed in a single horizontal line with a font size of 144. Ensure the substring ""igsta"" within the star symbol is highlighted in red color. The elements should remain stationary after appearing."
"from manim import *

class IncorrectLaTeXSubstringColoring(Scene):
    def construct(self):
        equation = MathTex(
            r""e^x = x^0 + x^1 + \frac{1}{2} x^2 + \frac{1}{6} x^3 + \cdots + \frac{1}{n!} x^n + \cdots""
        )
        equation.set_color_by_tex(""x"", YELLOW)
        self.add(equation)","Create a Manim animation scene that starts with a static display of the Taylor series expansion of e^x written in LaTeX:  
""e^x = x^0 + x^1 + (1/2)x^2 + (1/6)x^3 + \cdots + (1/n!)x^n + \cdots"". All instances of the variable ""x"" within the equation must be highlighted in yellow. The scene requires no movement, transformations, or animations—only the immediate rendering of the fully colored equation on a blank background."
"from manim import *

class CorrectLaTeXSubstringColoring(Scene):
    def construct(self):
        equation = MathTex(
            r""e^x = x^0 + x^1 + \frac{1}{2} x^2 + \frac{1}{6} x^3 + \cdots + \frac{1}{n!} x^n + \cdots"",
            substrings_to_isolate=""x""
        )
        equation.set_color_by_tex(""x"", YELLOW)
        self.add(equation)","Create a Manim animation where the mathematical equation representing the Taylor series expansion of e^x is displayed. All instances of the variable ""x"" within the equation must be highlighted in yellow. The equation should appear static on the screen without any movement, scaling, fading, or transformations. The series includes terms like x^0, x^1, (1/2)x^2, (1/6)x^3, up to (1/n!)x^n and beyond."
"from manim import *

class LaTeXMathFonts(Scene):
    def construct(self):
        tex = Tex(
            r""$x^2 + y^2 = z^2$"",
            tex_template=TexFontTemplates.french_cursive,
            font_size=144,
        )
        self.add(tex)","Create Manim code for an animation scene that displays the LaTeX equation ""x^2 + y^2 = z^2"" using the French cursive font template. The equation should be rendered at a font size of 144 and centered on the screen. No movement or transformation should occur; the equation must remain static throughout the scene."
"from manim import *

class LaTeXTemplateLibrary(Scene):
    def construct(self):
        tex = Tex('Hello 你好 \\LaTeX', tex_template=TexTemplateLibrary.ctex, font_size=144)
        self.add(tex)","Create a Manim Python code for an animation scene where the text ""Hello 你好 \LaTeX"" is displayed on the screen. Use the ctex template from TexTemplateLibrary to render the text, set the font size to 144, and ensure the text is static without any movement or transformation."
"from manim import *

class LaTeXAlignEnvironment(Scene):
    def construct(self):
        tex = MathTex(r'f(x) &= 3 + 2 + 1\\ &= 5 + 1 \\ &= 6', font_size=96)
        self.add(tex)","Create a Manim animation scene that displays three math equations aligned at the equals sign, showing step-by-step simplification of f(x). The equations should be presented as:
1. f(x) = 3 + 2 + 1
2. f(x) = 5 + 1
3. f(x) = 6

Ensure the equations use LaTeX align-environment style alignment (equals signs lined up), are rendered in large font size (about 96pt), and are stacked vertically without overlapping. The equations should remain static (no animation transitions) once displayed on the scene."
"from manim import *
from manim_voiceover import VoiceoverScene
from manim_voiceover.services.recorder import RecorderService


# Simply inherit from VoiceoverScene instead of Scene to get all the
# voiceover functionality.
class RecorderExample(VoiceoverScene):
    def construct(self):
        # You can choose from a multitude of TTS services,
        # or in this example, record your own voice:
        self.set_speech_service(RecorderService())

        circle = Circle()

        # Surround animation sections with with-statements:
        with self.voiceover(text=""This circle is drawn as I speak."") as tracker:
            self.play(Create(circle), run_time=tracker.duration)
            # The duration of the animation is received from the audio file
            # and passed to the tracker automatically.

        # This part will not start playing until the previous voiceover is finished.
        with self.voiceover(text=""Let's shift it to the left 2 units."") as tracker:
            self.play(circle.animate.shift(2 * LEFT), run_time=tracker.duration)","Prompt:  
""Create a Manim animation scene that starts with a circle being drawn on the screen while a voiceover says 'This circle is drawn as I speak.' After the first voiceover finishes, the circle should smoothly shift 2 units to the left while a second voiceover states 'Let's shift it to the left 2 units.' Use the Manim VoiceoverScene class with the RecorderService for capturing the voiceover. Ensure the animation timings of each section precisely match the duration of their corresponding recorded audio clips."""
"from manim import *

class MySquare(Square):
    @override_animation(FadeIn)
    def _fade_in_override(self, **kwargs):
        return Create(self, **kwargs)

class OverrideAnimationExample(Scene):
    def construct(self):
        self.play(FadeIn(MySquare()))","Create a Manim animation scene where a square uses the Create animation instead of the default FadeIn. Design a custom Square subclass (MySquare) that overrides FadeIn to return Create(self). Implement a scene (OverrideAnimationExample) where calling FadeIn on a MySquare instance triggers the overridden Create animation. Specify the class structure, decorator usage (@override_animation), and the scene's construct method demonstrating this override."
"from manim import *

class DefaultAddScene(Scene):
    def construct(self):
        text_1 = Text(""I was added with Add!"")
        text_2 = Text(""Me too!"")
        text_3 = Text(""And me!"")
        texts = VGroup(text_1, text_2, text_3).arrange(DOWN)
        rect = SurroundingRectangle(texts, buff=0.5)

        self.play(
            Create(rect, run_time=3.0),
            Succession(
                Wait(1.0),
                # You can Add a Mobject in the middle of an animation...
                Add(text_1),
                Wait(1.0),
                # ...or multiple Mobjects at once!
                Add(text_2, text_3),
            ),
        )
        self.wait()","Create a Manim animation scene where three text elements labeled ""I was added with Add!"", ""Me too!"", and ""And me!"" are arranged vertically. The texts should be grouped and enclosed in a rectangle with a 0.5 spacing buffer around them. The rectangle must be animated to form around the texts over 3 seconds. The first text appears 1 second after the animation begins. The second and third texts appear simultaneously exactly 1 second after the first text's appearance. All text additions must be timed precisely using sequential animation commands that run concurrently with the rectangle's creation. Include delays and synchronized timing between the rectangle drawing and the text additions."
"from manim import *

class AddWithRunTimeScene(Scene):
    def construct(self):
        # A 5x5 grid of circles
        circles = VGroup(
            *[Circle(radius=0.5) for _ in range(25)]
        ).arrange_in_grid(5, 5)

        self.play(
            Succession(
                # Add a run_time of 0.2 to wait for 0.2 seconds after
                # adding the circle, instead of using Wait(0.2) after Add!
                *[Add(circle, run_time=0.2) for circle in circles],
                rate_func=smooth,
            )
        )
        self.wait()","Create a Manim animation scene where 25 circles (radius 0.5) form a 5x5 grid. Each circle appears sequentially with a smooth animation, taking 0.2 seconds per circle. The animations must play consecutively: the next circle begins its animation immediately after the prior one finishes. All circles must be arranged in a fixed 5x5 grid layout before their animations begin. After all circles have appeared, the final frame pauses briefly."
"from manim import *

class LagRatios(Scene):
    def construct(self):
        ratios = [0, 0.1, 0.5, 1, 2]  # demonstrated lag_ratios

        # Create dot groups
        group = VGroup(*[Dot() for _ in range(4)]).arrange_submobjects()
        groups = VGroup(*[group.copy() for _ in ratios]).arrange_submobjects(buff=1)
        self.add(groups)

        # Label groups
        self.add(Text(""lag_ratio = "", font_size=36).next_to(groups, UP, buff=1.5))
        for group, ratio in zip(groups, ratios):
            self.add(Text(str(ratio), font_size=36).next_to(group, UP))

        #Animate groups with different lag_ratios
        self.play(AnimationGroup(*[
            group.animate(lag_ratio=ratio, run_time=1.5).shift(DOWN * 2)
            for group, ratio in zip(groups, ratios)
        ]))

        # lag_ratio also works recursively on nested submobjects:
        self.play(groups.animate(run_time=1, lag_ratio=0.1).shift(UP * 2))","Design a Manim animation to demonstrate the effect of different lag_ratio values on moving objects. The animation should include the following elements and steps:

1. Display 5 horizontal groups of 4 dots each, arranged side-by-side with spacing between groups. Each group corresponds to a specific lag_ratio value from the list [0, 0.1, 0.5, 1, 2]
 
2. Above all groups, show the text ""lag_ratio = "" positioned at the top-center. Each individual group must have its specific ratio number displayed directly above it.

3. First animation sequence: 
   - Animate all groups moving downward by 2 units simultaneously
   - For each group, apply its assigned lag_ratio during the 1.5-second animation duration
   - Show how varying lag_ratio values control the staggered motion between dots (0: all move together; higher values cause progressive dot movement)

4. Second animation sequence:
   - Move all groups back upward by 2 units in 1 second
   - Apply a lag_ratio of 0.1 recursively across all submobjects in the group collection to demonstrate hierarchical timing effects

Ensure dots are created with Dot(), groups use VGroup.arrange_submobjects(), and text uses 36 font size with appropriate positioning. Use AnimationGroup for parallel animations and show parameter handling for both group and individual element timing behaviors."
"from manim import *

class ChangeDefaultAnimation(Scene):
    def construct(self):
        Rotate.set_default(run_time=2, rate_func=rate_functions.linear)
        Indicate.set_default(color=None)

        S = Square(color=BLUE, fill_color=BLUE, fill_opacity=0.25)
        self.add(S)
        self.play(Rotate(S, PI))
        self.play(Indicate(S))

        Rotate.set_default()
        Indicate.set_default()","Create a Manim animation showing a blue square with 25% fill opacity. First, rotate it 180 degrees (π radians) linearly over 2 seconds. Then apply an Indicate animation that pulses the square without altering its color. Before the rotations/Indicate, temporarily adjust Rotate's default run_time to 2 seconds and rate_func to linear, and set Indicate's default color parameter to None. After the animations, restore both classes' defaults to their original settings."
"from manim import *

class AnimatedBoundaryExample(Scene):
    def construct(self):
        text = Text(""So shiny!"")
        boundary = AnimatedBoundary(text, colors=[RED, GREEN, BLUE],
                                    cycle_rate=3)
        self.add(text, boundary)
        self.wait(2)","Create an animation scene showcasing the text ""So shiny!"" with a dynamic boundary effect. The boundary should continuously transition between the colors red, green, and blue in a smooth cycle, with a cycle rate of 3. The text and its animated boundary must remain visible for exactly 2 seconds."
"from manim import *

class TracedPathExample(Scene):
    def construct(self):
        circ = Circle(color=RED).shift(4*LEFT)
        dot = Dot(color=RED).move_to(circ.get_start())
        rolling_circle = VGroup(circ, dot)
        trace = TracedPath(circ.get_start)
        rolling_circle.add_updater(lambda m: m.rotate(-0.3))
        self.add(trace, rolling_circle)
        self.play(rolling_circle.animate.shift(8*RIGHT), run_time=4, rate_func=linear)","Create an animation showing a red circle starting on the left side of the screen with a red dot at its initial position. The circle and dot move together to the right, shifting 8 units over 4 seconds with constant linear speed. As they move, they continuously rotate clockwise at a fixed angular rate to produce a rolling motion. The path traced by the dot's movement must be dynamically drawn in real-time as a cycloid curve during the translation."
"from manim import *

class DissipatingPathExample(Scene):
    def construct(self):
        a = Dot(RIGHT * 2)
        b = TracedPath(a.get_center, dissipating_time=0.5, stroke_opacity=[0, 1])
        self.add(a, b)
        self.play(a.animate(path_arc=PI / 4).shift(LEFT * 2))
        self.play(a.animate(path_arc=-PI / 4).shift(LEFT * 2))
        self.wait()","Create a Manim animation showing a dot starting at the right side (2 units along the x-axis). The dot moves in two stages: first, it shifts 2 units to the left along a curved path with a PI/4 arc angle, then another 2 units left with a -PI/4 arc angle. The movement leaves a dissolving trail that gradually disappears over a 0.5-second duration. The trail begins invisibly and becomes fully opaque as it progresses, updating continuously as the dot moves. After the movements, briefly pause to display the final trail."
"from manim import *

class LaggedStartExample(Scene):
    def construct(self):
        title = Text(""lag_ratio = 0.25"").to_edge(UP)

        dot1 = Dot(point=LEFT * 2 + UP, radius=0.16)
        dot2 = Dot(point=LEFT * 2, radius=0.16)
        dot3 = Dot(point=LEFT * 2 + DOWN, radius=0.16)
        line_25 = DashedLine(
            start=LEFT + UP * 2,
            end=LEFT + DOWN * 2,
            color=RED
        )
        label = Text(""25%"", font_size=24).next_to(line_25, UP)
        self.add(title, dot1, dot2, dot3, line_25, label)

        self.play(LaggedStart(
            dot1.animate.shift(RIGHT * 4),
            dot2.animate.shift(RIGHT * 4),
            dot3.animate.shift(RIGHT * 4),
            lag_ratio=0.25,
            run_time=4
        ))","Create an animation scene using Manim that demonstrates the effect of `lag_ratio` on object movements. The scene should include:  
1. A title text ""lag_ratio = 0.25"" positioned at the top edge of the screen.  
2. Three dots (radius=0.16) arranged vertically on the left side: the top dot at `LEFT*2 + UP`, middle dot at `LEFT*2`, and bottom dot at `LEFT*2 + DOWN`.  
3. A vertical dashed red line (thickness adjusted) centered at the middle dot's position, spanning from `LEFT + UP*2` to `LEFT + DOWN*2`, with a small text label ""25%"" above the line.  
4. An animation where all three dots move smoothly to the right by 4 units, but delayed in sequence. The movement should start with the top dot, followed by the middle dot after a 0.25 lag ratio delay, then the bottom dot after another 0.25 delay. The total animation duration should be 4 seconds. Use `LaggedStart` to coordinate the staggered motion between the dots. Ensure all elements are properly added to the scene before the animation begins."
"from manim import *

class LaggedStartMapExample(Scene):
    def construct(self):
        title = Tex(""LaggedStartMap"").to_edge(UP, buff=LARGE_BUFF)
        dots = VGroup(
            *[Dot(radius=0.16) for _ in range(35)]
            ).arrange_in_grid(rows=5, cols=7, buff=MED_LARGE_BUFF)
        self.add(dots, title)

        # Animate yellow ripple effect
        for mob in dots, title:
            self.play(LaggedStartMap(
                ApplyMethod, mob,
                lambda m : (m.set_color, YELLOW),
                lag_ratio = 0.1,
                rate_func = there_and_back,
                run_time = 2
            ))","Design a Manim animation scene with the following elements and sequence:  
1. A title labeled ""LaggedStartMap"" positioned at the top edge of the screen.  
2. Below the title, a uniformly spaced 5-row by 7-column grid of small dots.  
3. First, the grid of dots undergoes a **yellow ripple animation**: Each dot gradually turns fully yellow, one after another in a staggered sequential wave. The color transition for each dot reverses back to its original color after reaching full yellow, creating a pulse effect. The ripple effect between adjacent dots has a subtle delay (0.1 lag ratio).  
4. Immediately after the dot animation concludes, the title text exhibits the same ripple effect: its characters change to yellow sequentially from left to right (or in a logical order), then reverse back to their original color. The delay between character transitions matches the dots' lag ratio.  
5. Each full animation cycle (color change + reversal) for both elements takes approximately 2 seconds.  
6. The animations for the dots and title must occur in sequence, not simultaneously.  

Focus on achieving smooth staggered transitions, clear visual separation between the grid, title, and their respective animations, and use a pulsating ""there-and-back"" dynamic for the color changes."
"from manim import *

class SuccessionExample(Scene):
    def construct(self):
        dot1 = Dot(point=LEFT * 2 + UP * 2, radius=0.16, color=BLUE)
        dot2 = Dot(point=LEFT * 2 + DOWN * 2, radius=0.16, color=MAROON)
        dot3 = Dot(point=RIGHT * 2 + DOWN * 2, radius=0.16, color=GREEN)
        dot4 = Dot(point=RIGHT * 2 + UP * 2, radius=0.16, color=YELLOW)
        self.add(dot1, dot2, dot3, dot4)

        self.play(Succession(
            dot1.animate.move_to(dot2),
            dot2.animate.move_to(dot3),
            dot3.animate.move_to(dot4),
            dot4.animate.move_to(dot1)
        ))","Create a Manim animation where four colored dots appear at square corners: blue at top-left (-2,2), maroon at bottom-left (-2,-2, green at bottom-right (2,-2, and yellow at top-right (2,2. The animation should sequentially animate each dot moving to the next's original position in order: first the blue moves to the maroon's start position, then maroon moves to the green's, green moves to yellow's, and finally yellow returns to blue's starting spot. The moves occur in succession, so one finishes before the next begins, creating a cycle passing positions clockwise around the square."
"from manim import *

class CreateScene(Scene):
    def construct(self):
        self.play(Create(Square()))","Create a Manim animation scene where a square is drawn on the screen using a stroke-building animation. The animation should start with an empty scene and gradually construct the square's outline frame by frame. Specify the Python code using the Manim library, including necessary imports, a Scene subclass, and the construct method containing the animation call to achieve this visual effect."
"from manim import *

class ShowDrawBorderThenFill(Scene):
    def construct(self):
        self.play(DrawBorderThenFill(Square(fill_opacity=1, fill_color=ORANGE)))","Create a Manim animation scene that displays an orange square. The square must start as an unfilled border, then transition into being fully filled with the same orange color in a single fluid animation. The animation should clearly show the outline being drawn first, followed by the interior filling in after the border is complete."
"from manim import *

class ShowIncreasingSubsetsScene(Scene):
    def construct(self):
        p = VGroup(Dot(), Square(), Triangle())
        self.add(p)
        self.play(ShowIncreasingSubsets(p))
        self.wait()","""Create a Manim animation scene that sequentially displays a Dot, Square, and Triangle as part of a single group. The animation should start with none of the shapes visible, then gradually add each shape one by one until all three are fully visible on the screen. The three shapes should be part of the same visual group, and the animation effect must use an incremental subset reveal animation. Include a brief pause at the end to show all elements fully displayed."""
"from manim import *

class SpiralInExample(Scene):
    def construct(self):
        pi = MathTex(r""\pi"").scale(7)
        pi.shift(2.25 * LEFT + 1.5 * UP)
        circle = Circle(color=GREEN_C, fill_opacity=1).shift(LEFT)
        square = Square(color=BLUE_D, fill_opacity=1).shift(UP)
        shapes = VGroup(pi, circle, square)
        self.play(SpiralIn(shapes))","Create a Manim animation showing three shapes spiraling in from different positions. The animation should start with a large π symbol (scaled to 7x its original size) positioned 2.25 units to the left and 1.5 units upward on the screen. Alongside it, include a solid green circle (filled, color GREEN_C) shifted 1 unit to the left and a solid blue square (filled, color BLUE_D) shifted 1 unit upward. Group these three elements together and apply a SpiralIn animation so they spiral into their final positions simultaneously. Specify exact positioning, colors, scaling, and animation type."
"from manim import *

class InsertingTextExample(Scene):
    def construct(self):
        text = Text(""Inserting"", color=PURPLE).scale(1.5).to_edge(LEFT)
        cursor = Rectangle(
            color = GREY_A,
            fill_color = GREY_A,
            fill_opacity = 1.0,
            height = 1.1,
            width = 0.5,
        ).move_to(text[0]) # Position the cursor

        self.play(TypeWithCursor(text, cursor))
        self.play(Blink(cursor, blinks=2))","Create a Manim animation scene that starts with the text ""Inserting"" displayed in purple color, scaled to 1.5x, and positioned at the left edge of the screen. Add a grey cursor (rectangle with fill) of height 1.1 and width 0.5 initially placed at the starting position of the first character of the text. First, animate the text to appear letter by letter while the cursor blinks in sync with the typing. After the text is fully displayed, make the cursor blink twice in place. Use appropriate Manim classes and functions to implement the visual elements and their animations."
"from manim import *

class ShowUncreate(Scene):
    def construct(self):
        self.play(Uncreate(Square()))","""Write a Manim Python code to create an animation scene where a square first appears, and then undergoes an uncreation effect, showing its gradual disappearance. The animation should start with the square visible on the screen and transition seamlessly to its uncreation without any lingering remnants."""
"from manim import *

class DeletingTextExample(Scene):
    def construct(self):
        text = Text(""Deleting"", color=PURPLE).scale(1.5).to_edge(LEFT)
        cursor = Rectangle(
            color = GREY_A,
            fill_color = GREY_A,
            fill_opacity = 1.0,
            height = 1.1,
            width = 0.5,
        ).move_to(text[0]) # Position the cursor

        self.play(UntypeWithCursor(text, cursor))
        self.play(Blink(cursor, blinks=2))","Create a Manim animation scene that starts with the text ""Deleting"" displayed in purple, scaled to 1.5x, positioned on the left side of the screen. A thin grey rectangle (0.5 width, 1.1 height) acts as a cursor, initially placed next to the first character of the text. Animate the text being gradually erased character by character while the cursor moves along with the deletion. After the text is gone, have the cursor blink twice in place."
"from manim import *

class UnwriteReverseTrue(Scene):
    def construct(self):
        text = Tex(""Alice and Bob"").scale(3)
        self.add(text)
        self.play(Unwrite(text))","Design a Manim scene animation that starts by displaying the large text ""Alice and Bob"" scaled 3x its original size. The text should then be gradually erased using the Unwrite animation effect, which removes the text stroke from left to right (or as per default Unwrite direction) while remaining on screen until fully erased."
"from manim import *

class UnwriteReverseFalse(Scene):
    def construct(self):
        text = Tex(""Alice and Bob"").scale(3)
        self.add(text)
        self.play(Unwrite(text, reverse=False))","Create a Manim animation scene where the text ""Alice and Bob"" is first displayed in full on the screen, scaled up to three times its original size. The text must then undergo an animation where it erases stroke-by-stroke from the first character (leftmost) to the last character (rightmost) in a continuous motion. Use the Unwrite animation class with reverse=False parameter to achieve this left-to-right erasure effect. Provide the complete Python code implementing this animation sequence using Manim's Scene framework."
"from manim import *

class ShowWrite(Scene):
    def construct(self):
        self.play(Write(Text(""Hello"", font_size=144)))","Create a Manim Python code to animate the text ""Hello"" with a font size of 144, displayed on the screen using the Write animation. The scene should be structured in a class called ShowWrite, inheriting from Scene, with the animation executed in the construct method to show the text being written stroke by stroke."
"from manim import *

class ShowWriteReversed(Scene):
    def construct(self):
        self.play(Write(Text(""Hello"", font_size=144), reverse=True, remover=False))","""Create a Manim animation scene that displays the text 'Hello' with a font size of 144. The text should be written in reverse order, starting from the last character and moving backwards. Ensure that the text remains on the screen after the animation completes."""
"from manim import *

class Fading(Scene):
    def construct(self):
        tex_in = Tex(""Fade"", ""In"").scale(3)
        tex_out = Tex(""Fade"", ""Out"").scale(3)
        self.play(FadeIn(tex_in, shift=DOWN, scale=0.66))
        self.play(ReplacementTransform(tex_in, tex_out))
        self.play(FadeOut(tex_out, shift=DOWN * 2, scale=1.5))","Design a Manim animation scene named 'Fading' that sequences three main visuals:  
1. Start with the text ""Fade"" and ""In"" displayed as a single scaled (3x) Tex object. Fade this text in from a position shifted 1 unit downward and scaled down to 0.66× its size, moving upward to center while increasing to full size.  

2. Transition the original text ""Fade In"" into ""Fade Out"" by smoothly transforming every letter, keeping the word ""Fade"" fixed while ""In"" morphs into ""Out"". Maintain the text's 3x scaling during this transformation.  

3. Fade out the resulting ""Fade Out"" text, moving it twice the original down-shift distance (DOWN*2) while scaling it 1.5× its original scaled size (3x * 1.5 = 4.5x during fade-out). The text should enlarge and descend further down as it disappears completely.  

Ensure animations occur in order: first FadeIn (with shift=DOWN and scale=0.66), then transformation, then FadeOut with shift=DOWN * 2 and scale=1.5.  

The first Tex object must be initialized with .scale(3), the second Tex ""Fade Out"" must also be 3× scaled to match."
"from manim import *

class FadeInExample(Scene):
    def construct(self):
        dot = Dot(UP * 2 + LEFT)
        self.add(dot)
        tex = Tex(
            ""FadeIn with "", ""shift "", r"" or target\_position"", "" and scale""
        ).scale(1)
        animations = [
            FadeIn(tex[0]),
            FadeIn(tex[1], shift=DOWN),
            FadeIn(tex[2], target_position=dot),
            FadeIn(tex[3], scale=1.5),
        ]
        self.play(AnimationGroup(*animations, lag_ratio=0.5))","Create a Manim animation scene where a text is split into four parts and animated using different FadeIn parameters. A small dot must first appear at the top-left of the screen (position UP*2 + LEFT). The text ""FadeIn with shift or target_position and scale"" is divided into four segments: ""FadeIn with "", ""shift "", "" or target_position"", and "" and scale"". Each segment must animate as follows:  
- The first segment fades in normally.  
- The second fades in while shifting downward.  
- The third fades in moving directly toward the pre-placed dot.  
- The fourth fades in while scaling to 1.5x its original size.  
All parts should appear sequentially with a visible delay between each animation. Include the necessary code to set up the scene, define the text segments, and group all FadeIn animations into an AnimationGroup with a lag_ratio of 0.5."
"from manim import *

class FadeInExample(Scene):
    def construct(self):
        dot = Dot(UP * 2 + LEFT)
        self.add(dot)
        tex = Tex(
            ""FadeOut with "", ""shift "", r"" or target\_position"", "" and scale""
        ).scale(1)
        animations = [
            FadeOut(tex[0]),
            FadeOut(tex[1], shift=DOWN),
            FadeOut(tex[2], target_position=dot),
            FadeOut(tex[3], scale=0.5),
        ]
        self.play(AnimationGroup(*animations, lag_ratio=0.5))","**Prompt:**  
""Create a Manim animation scene that demonstrates different FadeOut effects. Start with a small dot placed in the upper left quadrant of the screen. Display a LaTeX text divided into four parts: 'FadeOut with ', 'shift ', 'or target_position', 'and scale'. The first text segment ('FadeOut with ') should fade out normally. The second part ('shift ') should fade while moving downward. The third part ('target_position ') must animate towards the position of the pre-placed dot. The fourth segment ('scale ') should shrink to half its size as it fades. Play all four animations together with a 0.5 lag ratio between each part's start time."""
"from manim import *

class Growing(Scene):
    def construct(self):
        square = Square()
        circle = Circle()
        triangle = Triangle()
        arrow = Arrow(LEFT, RIGHT)
        star = Star()

        VGroup(square, circle, triangle).set_x(0).arrange(buff=1.5).set_y(2)
        VGroup(arrow, star).move_to(DOWN).set_x(0).arrange(buff=1.5).set_y(-2)

        self.play(GrowFromPoint(square, ORIGIN))
        self.play(GrowFromCenter(circle))
        self.play(GrowFromEdge(triangle, DOWN))
        self.play(GrowArrow(arrow))
        self.play(SpinInFromNothing(star))","Create a Manim animation scene where the following occurs:  

1. **Visual Layout**:  
   - A square, circle, and triangle are arranged horizontally at the top of the screen (aligned at y = 2), spaced 1.5 units apart and centered horizontally.  
   - An arrow and a star are placed at the bottom of the screen (aligned at y = -2), also spaced 1.5 units apart and centered.  

2. **Animations**:  
   - The square should **grow from a point at the center (ORIGIN)** using `GrowFromPoint`.  
   - The circle should **expand outward from its own center** using `GrowFromCenter`.  
   - The triangle should **grow upward from its bottom edge** using `GrowFromEdge`.  
   - The arrow should **stretch outward from its tip to its head** using `GrowArrow`.  
   - The star should **spin into view from nothing** using `SpinInFromNothing`.  

3. **Order and Timing**:  
   - Each shape animates sequentially (one after another), starting with the square, followed by the circle, triangle, arrow, and finally the star.  
   - All elements remain visible after their animations are complete.  

Describe this animation in enough detail for the LLM to generate the code."
"from manim import *

class GrowArrowExample(Scene):
    def construct(self):
        arrows = [Arrow(2 * LEFT, 2 * RIGHT), Arrow(2 * DR, 2 * UL)]
        VGroup(*arrows).set_x(0).arrange(buff=2)
        self.play(GrowArrow(arrows[0]))
        self.play(GrowArrow(arrows[1], point_color=RED))","Create a Manim animation scene that includes the following elements and actions:  
1. Two arrows:  
   - First arrow starts at position 2 units left and points 2 units to the right.  
   - Second arrow starts at position 2 units down-right (DR) and points 2 units toward up-left (UL).  
2. Both arrows are centered on the screen and arranged horizontally with 2 units of spacing between them.  
3. First arrow grows on-screen starting from its base (tip-first animation).  
4. Second arrow also grows from its base, but during the animation, its tip changes color to red while expanding.  

Specify the direction, positioning, and color change details for the animations in the code."
"from manim import *

class GrowFromCenterExample(Scene):
    def construct(self):
        squares = [Square() for _ in range(2)]
        VGroup(*squares).set_x(0).arrange(buff=2)
        self.play(GrowFromCenter(squares[0]))
        self.play(GrowFromCenter(squares[1], point_color=RED))","Design an animation using Manim where two squares are arranged horizontally and centered on the screen with space between them. The first square should grow outward from its center point, followed by the second square growing similarly but with its growth origin point displayed in red. The squares should maintain their positions while the animation occurs sequentially."
"from manim import *

class GrowFromEdgeExample(Scene):
    def construct(self):
        squares = [Square() for _ in range(4)]
        VGroup(*squares).set_x(0).arrange(buff=1)
        self.play(GrowFromEdge(squares[0], DOWN))
        self.play(GrowFromEdge(squares[1], RIGHT))
        self.play(GrowFromEdge(squares[2], UR))
        self.play(GrowFromEdge(squares[3], UP, point_color=RED))","Create an animation where four squares are arranged horizontally with spacing between them. The first square should grow from the bottom edge, the second from the right edge, the third from the top-right corner, and the fourth from the top edge with its growing point highlighted in red. Each square's animation should play sequentially."
"from manim import *

class GrowFromPointExample(Scene):
    def construct(self):
        dot = Dot(3 * UR, color=GREEN)
        squares = [Square() for _ in range(4)]
        VGroup(*squares).set_x(0).arrange(buff=1)
        self.add(dot)
        self.play(GrowFromPoint(squares[0], ORIGIN))
        self.play(GrowFromPoint(squares[1], [-2, 2, 0]))
        self.play(GrowFromPoint(squares[2], [3, -2, 0], RED))
        self.play(GrowFromPoint(squares[3], dot, dot.get_color()))","Create a Manim animation scene where four squares are arranged in a horizontal row spaced 1 unit apart. The animation starts with a green dot positioned at the upper right corner. The first square grows from the center of the screen, the second grows from the point (-2, 2), the third grows from (3, -2) and is red in color, and the fourth square grows from the position and color of the green dot. Each square's appearance should be shown in sequence using the GrowFromPoint animation."
"from manim import *

class SpinInFromNothingExample(Scene):
    def construct(self):
        squares = [Square() for _ in range(3)]
        VGroup(*squares).set_x(0).arrange(buff=2)
        self.play(SpinInFromNothing(squares[0]))
        self.play(SpinInFromNothing(squares[1], angle=2 * PI))
        self.play(SpinInFromNothing(squares[2], point_color=RED))","""Design a Manim animation scene where three squares are arranged horizontally with space between them. The first square spins in using the default SpinInFromNothing animation. The second square must display a full 360° spin during its SpinInFromNothing animation. The third square's SpinInFromNothing animation should change its spinning path color to red. Arrange the squares in a row, spaced apart, and ensure each square uses the specified parameters for their animations."""
"from manim import *

class Indications(Scene):
    def construct(self):
        indications = [ApplyWave,Circumscribe,Flash,FocusOn,Indicate,ShowPassingFlash,Wiggle]
        names = [Tex(i.__name__).scale(3) for i in indications]

        self.add(names[0])
        for i in range(len(names)):
            if indications[i] is Flash:
                self.play(Flash(UP))
            elif indications[i] is ShowPassingFlash:
                self.play(ShowPassingFlash(Underline(names[i])))
            else:
                self.play(indications[i](names[i]))
            self.play(AnimationGroup(
                FadeOut(names[i], shift=UP*1.5),
                FadeIn(names[(i+1)%len(names)], shift=UP*1.5),
            ))","Create an animation scene in Manim that demonstrates a series of indicating animations on text labels. The scene should transition through each animation, with each step showing a text label (e.g., ""ApplyWave"", ""Flash"", etc.) displayed large on screen. For each step:  
1. Apply the corresponding indicating animation specific to the text’s name (e.g., Flash for the ""Flash"" text). If the animation is Flash, show the flash effect pointing upward instead of the text. For ShowPassingFlash, animate an underline passing over the text.  
2. After the animation, fade out the current text upward while simultaneously sliding in the next text from above. Repeat this until all animations are shown in a loop.  

Ensure smooth transitions between each text label and their respective indicating animations, cycling through all listed effects: ApplyWave, Circumscribe, Flash, FocusOn, Indicate, ShowPassingFlash, and Wiggle."
"from manim import *

class ApplyingWaves(Scene):
    def construct(self):
        tex = Tex(""WaveWaveWaveWaveWave"").scale(2)
        self.play(ApplyWave(tex))
        self.play(ApplyWave(
            tex,
            direction=RIGHT,
            time_width=0.5,
            amplitude=0.3
        ))
        self.play(ApplyWave(
            tex,
            rate_func=linear,
            ripples=4
        ))","Create a Manim animation scene where a large text displaying the phrase ""WaveWaveWaveWaveWave"" (scaled to twice its original size) undergoes three successive wave animations: 

1. First, apply a standard upward wave effect.  
2. Next, animate a wave moving from left to right with a smaller vertical displacement (less pronounced upwards/downwards movement), tightly spaced ripples (closer together horizontally), and a rightward direction.  
3. Finally, execute a wave with exactly four distinct peaks/troughs (ripples), spreading across the text at a constant speed without acceleration or deceleration.  

Ensure the transformations occur sequentially, with each wave animation occurring after the previous one completes."
"from manim import *

class BlinkingExample(Scene):
    def construct(self):
        text = Text(""Blinking"").scale(1.5)
        self.add(text)
        self.play(Blink(text, blinks=3))","Design a Manim animation scene where the text ""Blinking"" appears scaled to 1.5 times its original size. The text should then perform a blinking animation consisting of three blinks. Each blink should involve the text dimming briefly and then brightening again. Use Manim's built-in Blink animation class with blinks=3, ensuring the text is added to the scene first (via self.add), followed by the blinking animation (via self.play in the scene's construct method)."
"from manim import *

class UsingCircumscribe(Scene):
    def construct(self):
        lbl = Tex(r""Circum-\\scribe"").scale(2)
        self.add(lbl)
        self.play(Circumscribe(lbl))
        self.play(Circumscribe(lbl, Circle))
        self.play(Circumscribe(lbl, fade_out=True))
        self.play(Circumscribe(lbl, time_width=2))
        self.play(Circumscribe(lbl, Circle, True))","Create a Manim animation scene that visualizes different variations of the Circumscribe animation on a scaled text label. The scene should start with a Tex label ""Circum-\\scribe"" scaled to twice its original size. The animations must sequentially show: 1. A default Circumscribe animation outlining the label with a moving pen stroke, 2. A Circumscribe animation using a circular shape around the label, 3. A Circumscribe animation that fades away the enclosing shape after drawing, 4. A Circumscribe animation with a thicker, slower-moving enclosure (time_width=2), 5. A combined circular Circumscribe that both fades out and encloses the label. Each animation should transition smoothly with proper timing between stages."
"from manim import *

class UsingFlash(Scene):
    def construct(self):
        dot = Dot(color=YELLOW).shift(DOWN)
        self.add(Tex(""Flash the dot below:""), dot)
        self.play(Flash(dot))
        self.wait()","Create a Manim animation scene where the text ""Flash the dot below:"" is displayed followed by a yellow dot positioned directly beneath it. The dot should then animate with a spark-like Flash effect, and the scene should hold the final frame briefly afterward."
"from manim import *

class FlashOnCircle(Scene):
    def construct(self):
        radius = 2
        circle = Circle(radius)
        self.add(circle)
        self.play(Flash(
            circle, line_length=1,
            num_lines=30, color=RED,
            flash_radius=radius+SMALL_BUFF,
            time_width=0.3, run_time=2,
            rate_func = rush_from
        ))","Create a Manim animation scene named FlashOnCircle. The scene should display a circle with a radius of 2 units. Animate a flash effect around the circle using 30 red radial lines, each line 1 unit in length. The flash's radius must be slightly larger than the circle. The animation should last 2 seconds, initiating abruptly and use the rush_from rate function for its timing."
"from manim import *

class UsingFocusOn(Scene):
    def construct(self):
        dot = Dot(color=YELLOW).shift(DOWN)
        self.add(Tex(""Focusing on the dot below:""), dot)
        self.play(FocusOn(dot))
        self.wait()","Create an animation that starts by displaying the text ""Focusing on the dot below"" centered on the screen, followed by a yellow dot positioned below the text. Next, animate a focus effect (e.g., expanding concentric circles) that converges on the dot, then briefly pause the final frame."
"from manim import *

class UsingIndicate(Scene):
    def construct(self):
        tex = Tex(""Indicate"").scale(3)
        self.play(Indicate(tex))
        self.wait()","Write a Manim animation showing a text ""Indicate"" displayed at 3x original size. The text should perform a pulsating highlight animation that includes slight scaling and color changes to emphasizes it, followed by a brief pause at the end."
"from manim import *

class TimeWidthValues(Scene):
    def construct(self):
        p = RegularPolygon(5, color=DARK_GRAY, stroke_width=6).scale(3)
        lbl = VMobject()
        self.add(p, lbl)
        p = p.copy().set_color(BLUE)
        for time_width in [0.2, 0.5, 1, 2]:
            lbl.become(Tex(r""\texttt{time\_width={{%.1f}}}""%time_width))
            self.play(ShowPassingFlash(
                p.copy().set_color(BLUE),
                run_time=2,
                time_width=time_width
            ))","Create a Manim animation scene that demonstrates the effect of different 'time_width' values on the ShowPassingFlash animation. Start by displaying a dark gray regular pentagon (stroke width 6, scaled to 3x size) and a label below it. Then, for each time_width value in [0.2, 0.5, 1, 2]: 
- Create a blue copy of the pentagon
- Update the label to display the current time_width value in monospace font
- Animate the blue pentagon with ShowPassingFlash using the current time_width parameter (run_time=2 seconds per frame)
Ensure the original pentagon remains visible while the animated copies with varying flash widths appear sequentially."
"from manim import *

class ApplyingWaves(Scene):
    def construct(self):
        tex = Tex(""Wiggle"").scale(3)
        self.play(Wiggle(tex))
        self.wait()","Write a Manim Python code to create an animation scene called ApplyingWaves. The scene should display the LaTeX text ""Wiggle"", scaled to 3 times its original size. The text must then perform a wiggling motion animation. After completing the animation, the scene should pause briefly to allow observation of the final state."
"from manim import *

class HomotopyExample(Scene):
    def construct(self):
        square = Square()

        def homotopy(x, y, z, t):
            if t <= 0.25:
                progress = t / 0.25
                return (x, y + progress * 0.2 * np.sin(x), z)
            else:
                wave_progress = (t - 0.25) / 0.75
                return (x, y + 0.2 * np.sin(x + 10 * wave_progress), z)

        self.play(Homotopy(homotopy, square, rate_func= linear, run_time=2))","""Create a Manim animation demonstrating a homotopy transformation on a square. The square should first undergo a vertical displacement where its y-coordinate shifts upward based on a sine wave of its x-coordinate over the first quarter of the animation duration. For the remaining time, the square should undulate with a moving wave along its surface, where the wave's phase increases over time, creating a flowing motion. The transition between these two phases must be continuous. Use a linear rate function and a total animation runtime of 2 seconds. Specify the homotopy function's time-based conditions and mathematical transformations for coordinate changes in the code.""

This prompt captures:
- The two-phase transformation timing (first 25% vs remaining 75%)
- Vertical displacement using sine of x in the initial phase
- Progressive wave motion using increasing phase in the second phase
- Linear timing and 2-second runtime constraint
- The need for a conditional homotopy function implementation
- The use of a Square as the animated object

It avoids mentioning code syntax, classes, or specific programming constructs while precisely describing the visual transformation sequence and mathematical behavior."
"from manim import *

class MoveAlongPathExample(Scene):
    def construct(self):
        d1 = Dot().set_color(ORANGE)
        l1 = Line(LEFT, RIGHT)
        l2 = VMobject()
        self.add(d1, l1, l2)
        l2.add_updater(lambda x: x.become(Line(LEFT, d1.get_center()).set_color(ORANGE)))
        self.play(MoveAlongPath(d1, l1), rate_func=linear)","Design a Manim animation where an orange dot moves horizontally along a straight line from the left to the right edge of the screen. Simultaneously, an orange line must dynamically adjust in real-time to connect the left edge of the screen to the current position of the moving dot. Ensure the dot's motion follows a constant speed (linear rate function) using MoveAlongPath animation while maintaining the static horizontal line visible throughout the scene."
"from manim import *

class UsingRotate(Scene):
    def construct(self):
        self.play(
            Rotate(
                Square(side_length=0.5).shift(UP * 2),
                angle=2*PI,
                about_point=ORIGIN,
                rate_func=linear,
            ),
            Rotate(Square(side_length=0.5), angle=2*PI, rate_func=linear),
            )","Create a Manim animation scene where two squares, each with a side length of 0.5 units, rotate simultaneously. The first square is positioned 2 units above the origin (center of the screen) and rotates around the origin (0,0) through an angle of 2π radians, while the second square remains centered at the origin and rotates around its own center by the same angle. Both rotations should use a linear rate function and occur at the same time within a single animation play."
"from manim import *

class BroadcastExample(Scene):
    def construct(self):
        mob = Circle(radius=4, color=TEAL_A)
        self.play(Broadcast(mob))","Design a Manim animation scene named ""BroadcastExample"" where a large TEAL_A-colored circle (radius 4 units) appears on an empty screen using the ""Broadcast"" animation effect. The animation must apply the Broadcast animation to the entire circle, with its visual components synchronized during the display process."
"from manim import *

class SpeedModifierExample(Scene):
    def construct(self):
        a = Dot().shift(LEFT * 4)
        b = Dot().shift(RIGHT * 4)
        self.add(a, b)
        self.play(
            ChangeSpeed(
                AnimationGroup(
                    a.animate(run_time=1).shift(RIGHT * 8),
                    b.animate(run_time=1).shift(LEFT * 8),
                ),
                speedinfo={0.3: 1, 0.4: 0.1, 0.6: 0.1, 1: 1},
                rate_func=linear,
            )
        )","Create an animation using Manim where two dots start on opposite ends of the screen (left and right edges). The left dot moves to the right edge while the right dot moves to the left edge. Their motion should have their speed vary over time: maintaining 1x speed until 0.3 seconds, then dropping to 0.1x speed at 0.4 seconds, switching back to 0.1x at 0.6 seconds, and reverting to 1x speed until completion. The movement must be synchronized between both dots, with their positions updating together. The animation must use a linear rate function ensuring constant progression of motion while applying the specified speed modifications at the given time intervals (0.3, 0.4, 0.6, and 1.0). The total duration should remain 1 second while applying these dynamic speed adjustments to create a stuttering or uneven motion effect."
"from manim import *

class SpeedModifierUpdaterExample(Scene):
    def construct(self):
        a = Dot().shift(LEFT * 4)
        self.add(a)

        ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))
        self.play(
            ChangeSpeed(
                Wait(2),
                speedinfo={0.4: 1, 0.5: 0.2, 0.8: 0.2, 1: 1},
                affects_speed_updaters=True,
            )
        )","Write a Manim animation scene demonstrating the following:  
1. A dot starts at the far left of the screen (positioned at 4 units left of the origin).  
2. The dot continuously moves to the right at a constant speed due to a speed updater attached to it.  
3. Over a total duration of 2 seconds, the movement speed of the dot dynamically changes in four phases using a speed modifier animation:  
   - For the first 0.4 seconds, the speed remains normal (1x).  
   - From 0.4 to 0.5 seconds, the speed slows down to 0.2x.  
   - From 0.5 to 0.8 seconds, the speed increases back to 0.2x (maintained). *(Note: Ensure the speed transitions follow the given timeline precisely.)*  
   - From 0.8 to 2 seconds, the speed returns to normal (1x).  
4. The speed changes must affect the dot's updater-driven motion, altering its position accordingly during the animation.  

The scene should use `ChangeSpeed` with a `Wait(2)` to apply the speed modifications and ensure `affects_speed_updaters=True` to link the speed adjustments to the continuous updater."
"from manim import *

class SpeedModifierUpdaterExample2(Scene):
    def construct(self):
        a = Dot().shift(LEFT * 4)
        self.add(a)

        ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))
        self.wait()
        self.play(
            ChangeSpeed(
                Wait(),
                speedinfo={1: 0},
                affects_speed_updaters=True,
            )
        )","Create an animation that starts with a dot placed far to the left of the screen (4 units left of center). The dot must move to the right at a constant speed under an always-active updater that continuously shifts it by 4 units per second. After 1 second of normal playback, introduce a speed modification that affects the passage of time: use a speed-adjusted Wait() animation to create a segment where the animation time slows or halts, altering the rate of all ongoing processes including the updater-driven motion. The code must use both a continuous position updaters and a scene-wide speed modifier applied after 1 second that interacts with those updaters using Manim's speed adjustment mechanism. Include necessary imports and ensure continuous movement is altered during a specified time keyframe."
"from manim import *

class ApplyMatrixExample(Scene):
    def construct(self):
        matrix = [[1, 1], [0, 2/3]]
        self.play(ApplyMatrix(matrix, Text(""Hello World!"")), ApplyMatrix(matrix, NumberPlane()))","Create an animation scene where a ""Hello World!"" text and a number plane simultaneously undergo a linear transformation defined by the matrix [[1, 1], [0, 2/3]]. The text must transform alongside the number plane's coordinate grid, clearly showing how both objects visually deform according to the matrix's scaling and shearing effects."
"from manim import *

class WarpSquare(Scene):
    def construct(self):
        square = Square()
        self.play(
            ApplyPointwiseFunction(
                lambda point: complex_to_R3(np.exp(R3_to_complex(point))), square
            )
        )
        self.wait()","Create an animation where a square morphs into a visually transformed shape through a complex exponential function's application. The animation should start with a stationary square, then show each point of the square dynamically warping according to the function's mathematical effect—causing the square to curve, stretch, or twist into a deformed configuration. Depict the full seamless transition from the original square to the final warped shape, and end with a brief pause to show the transformed result. Use smooth and continuous motion to illustrate the transformation's geometric impact."
"from manim import *

class ClockwiseExample(Scene):
    def construct(self):
        dl, dr = Dot(), Dot()
        sl, sr = Square(), Square()

        VGroup(dl, sl).arrange(DOWN).shift(2*LEFT)
        VGroup(dr, sr).arrange(DOWN).shift(2*RIGHT)

        self.add(dl, dr)
        self.wait()
        self.play(
            ClockwiseTransform(dl, sl),
            Transform(dr, sr)
        )
        self.wait()","Create a Manim animation scene that starts with two dots (dl and dr) positioned on the left and right sides of the screen. Each dot should be vertically aligned above a square (sl and sr) of the same color, forming two separate vertical pairs. Shift the left pair 2 units to the left and the right pair 2 units to the right. Initially display only the dots, then animate the left dot (dl) rotating clockwise to transform into its lower square (sl), while the right dot (dr) simply morphs into its lower square (sr). Use a smooth transition with a brief pause before and after the transformations."
"from manim import *

class CounterclockwiseTransform_vs_Transform(Scene):
    def construct(self):
        # set up the numbers
        c_transform = VGroup(DecimalNumber(number=3.141, num_decimal_places=3), DecimalNumber(number=1.618, num_decimal_places=3))
        text_1 = Text(""CounterclockwiseTransform"", color=RED)
        c_transform.add(text_1)

        transform = VGroup(DecimalNumber(number=1.618, num_decimal_places=3), DecimalNumber(number=3.141, num_decimal_places=3))
        text_2 = Text(""Transform"", color=BLUE)
        transform.add(text_2)

        ints = VGroup(c_transform, transform)
        texts = VGroup(text_1, text_2).scale(0.75)
        c_transform.arrange(direction=UP, buff=1)
        transform.arrange(direction=UP, buff=1)

        ints.arrange(buff=2)
        self.add(ints, texts)

        # The mobs move in clockwise direction for ClockwiseTransform()
        self.play(CounterclockwiseTransform(c_transform[0], c_transform[1]))

        # The mobs move straight up for Transform()
        self.play(Transform(transform[0], transform[1]))","Create a Manim animation scene comparing two number transformations side by-side. The left side shows two vertically stacked decimal numbers (3.141 above 1.618) labeled ""CounterclockwiseTransform"" in red (text smaller than default). The right side shows the same numbers reversed (1.618 above 3.141) labeled ""Transform"" in blue. Both number pairs should be arranged horizontally with space between the two comparison groups. Animate the top number on the left rotating counterclockwise around the lower number while swapping positions, while the top number on the right moves straight up to the position of the bottom number. Use contrasting color labels to highlight the different movement paths between the two transformations."
"from manim import *

class CyclicReplaceExample(Scene):
    def construct(self):
        group = VGroup(Square(), Circle(), Triangle(), Star())
        group.arrange(RIGHT)
        self.add(group)

        for _ in range(4):
            self.play(CyclicReplace(*group))","Create a Manim animation scene where four shapes (square, circle, triangle, and star) are initially arranged in a horizontal row. The animation must show each shape cyclically moving to the position of the next shape in the sequence. The last shape in the row should move to replace the first shape's position, creating a continuous cycle. This cyclic shifting of positions must repeat exactly four full times, maintaining the same order and spacing between shapes throughout the animation."
"from manim import *

class FadeToColorExample(Scene):
    def construct(self):
        self.play(FadeToColor(Text(""Hello World!""), color=RED))","Create a Manim animation showing the text ""Hello World!"" gradually fading its color to red. Use the FadeToColor animation class to transition the text's color smoothly. Provide the complete Python code including scene structure and necessary imports to render this specific color fading effect."
"from manim import *

class DifferentFadeTransforms(Scene):
    def construct(self):
        starts = [Rectangle(width=4, height=1) for _ in range(3)]
        VGroup(*starts).arrange(DOWN, buff=1).shift(3*LEFT)
        targets = [Circle(fill_opacity=1).scale(0.25) for _ in range(3)]
        VGroup(*targets).arrange(DOWN, buff=1).shift(3*RIGHT)

        self.play(*[FadeIn(s) for s in starts])
        self.play(
            FadeTransform(starts[0], targets[0], stretch=True),
            FadeTransform(starts[1], targets[1], stretch=False, dim_to_match=0),
            FadeTransform(starts[2], targets[2], stretch=False, dim_to_match=1)
        )

        self.play(*[FadeOut(mobj) for mobj in self.mobjects])","Create an animation using Manim that demonstrates three different object transformations side-by-side. Start with three rectangles arranged vertically on the left half of the screen (spaced 1 unit apart). Animate them fading in simultaneously. Then, transform each rectangle into a small filled circle on the right half of the screen, maintaining their vertical arrangement. 

The first transformation should show the rectangle stretch morphing into the circle. The second should shrink only along the x-axis (width) while keeping its original height before fading into the circle. The third should shrink only along the y-axis (height) while keeping original width before transforming. Each transformation must keep their respective target positions on the right. Finally, all objects should fade out together at the end. Use different fade behaviors based on stretch and dimension parameters for each transform pair."
"from manim import *

class FadeTransformSubmobjects(Scene):
    def construct(self):
        src = VGroup(Square(), Circle().shift(LEFT + UP))
        src.shift(3*LEFT + 2*UP)
        src_copy = src.copy().shift(4*DOWN)

        target = VGroup(Circle(), Triangle().shift(RIGHT + DOWN))
        target.shift(3*RIGHT + 2*UP)
        target_copy = target.copy().shift(4*DOWN)

        self.play(FadeIn(src), FadeIn(src_copy))
        self.play(
            FadeTransform(src, target),
            FadeTransformPieces(src_copy, target_copy)
        )
        self.play(*[FadeOut(mobj) for mobj in self.mobjects])","""Create a Manim animation scene that performs the following sequence of transformations: 

1. Start by creating two groups of shapes:
   - First group (src) contains a square and a circle shifted to the left and up. Position the entire group 3 units to the left and 2 units up.
   - Create a copy of this group (src_copy) and position it 4 units downward.
   
2. Create a second pair of groups (target and target_copy):
   - The target group contains a circle and a triangle shifted to the right and down. Position this group 3 units to the right and 2 units up.
   - Make a copy (target_copy) shifted 4 units downward.

3. Animate the following transitions:
   - First, fade in both the src group and its copy (src_copy) simultaneously.
   - Next, transform the original src group into the target group using a fade transformation (FadeTransform).
   - Simultaneously, perform a piecewise fade transformation (FadeTransformPieces) on the copied group (src_copy to target_copy).
   
4. Finally, fade out all objects from the scene.

Ensure the animation uses explicit shifts for positioning (LEFT, RIGHT, UP, DOWN) and properly applies both types of fade transformations between grouped elements. The order of animations must follow the sequence described."""
"from manim import *

class MoveToTargetExample(Scene):
    def construct(self):
        c = Circle()

        c.generate_target()
        c.target.set_fill(color=GREEN, opacity=0.5)
        c.target.shift(2*RIGHT + UP).scale(0.5)

        self.add(c)
        self.play(MoveToTarget(c))","Create a Manim animation scene where a circle starts centered on the screen and transitions to a new position, undergoing three simultaneous transformations:  
1. Moves 2 units to the right and 1 unit upward.  
2. Shrinks to half its original size.  
3. Fills with green color at 50% opacity.  
The animation should complete these changes in a single smooth motion using Manim's `MoveToTarget` method. Start by drawing the initial circle, then apply all three transformations to its target state before playing the transition."
"from manim import *

class ReplacementTransformOrTransform(Scene):
    def construct(self):
        # set up the numbers
        r_transform = VGroup(*[Integer(i) for i in range(1,4)])
        text_1 = Text(""ReplacementTransform"", color=RED)
        r_transform.add(text_1)

        transform = VGroup(*[Integer(i) for i in range(4,7)])
        text_2 = Text(""Transform"", color=BLUE)
        transform.add(text_2)

        ints = VGroup(r_transform, transform)
        texts = VGroup(text_1, text_2).scale(0.75)
        r_transform.arrange(direction=UP, buff=1)
        transform.arrange(direction=UP, buff=1)

        ints.arrange(buff=2)
        self.add(ints, texts)

        # The mobs replace each other and none are left behind
        self.play(ReplacementTransform(r_transform[0], r_transform[1]))
        self.play(ReplacementTransform(r_transform[1], r_transform[2]))

        # The mobs linger after the Transform()
        self.play(Transform(transform[0], transform[1]))
        self.play(Transform(transform[1], transform[2]))
        self.wait()","Create a Manim animation scene showing two vertical columns of integers and text labels to demonstrate the difference between ReplacementTransform and Transform. The left column has numbers 1, 2, 3 with ""ReplacementTransform"" text in red above them (scaled down). The right column has numbers 4, 5, 6 with ""Transform"" text in blue above them (scaled down). Arrange the columns horizontally with spacing between them. Animate the left numbers replacing each previous number completely one after another using ReplacementTransform. Simultaneously, animate the right numbers transitioning into the next number but leaving remnants of previous numbers during each step using Transform. Final frame holds both columns after all transitions."
"from manim import *

class RestoreExample(Scene):
    def construct(self):
        s = Square()
        s.save_state()
        self.play(FadeIn(s))
        self.play(s.animate.set_color(PURPLE).set_opacity(0.5).shift(2*LEFT).scale(3))
        self.play(s.animate.shift(5*DOWN).rotate(PI/4))
        self.wait()
        self.play(Restore(s), run_time=2)","Create a Manim animation scene where a square undergoes the following transformations in sequence:  
1. The square fades in.  
2. It simultaneously changes to purple, becomes 50% transparent, shifts 2 units to the left, and enlarges to 3 times its original size.  
3. Then, it moves 5 units downward while rotating 45 degrees (π/4 radians).  
4. After a brief pause, it fully reverses all transformations, returning to its original size, position, color, and opacity over 2 seconds. Ensure the initial state is saved before applying changes so the final restoration works correctly."
"from manim import *

class ScaleInPlaceExample(Scene):
    def construct(self):
        self.play(ScaleInPlace(Text(""Hello World!""), 2))","Create an animation showing a Text object displaying ""Hello World!"" scaling up in place to twice its original size. The text should start at its normal size, then smoothly enlarge to 2x scale while remaining centered on the screen."
"from manim import *

class ShrinkToCenterExample(Scene):
    def construct(self):
        self.play(ShrinkToCenter(Text(""Hello World!"")))","Create a Manim animation scene where the text ""Hello World!"" is displayed and then shrinks towards its own center. The animation should use the ShrinkToCenter transformation. Include the full code structure with a Scene class, construct method, and necessary imports."
"from manim import *

class TransformPathArc(Scene):
    def construct(self):
        def make_arc_path(start, end, arc_angle):
            points = []
            p_fn = path_along_arc(arc_angle)
            # alpha animates between 0.0 and 1.0, where 0.0
            # is the beginning of the animation and 1.0 is the end.
            for alpha in range(0, 11):
                points.append(p_fn(start, end, alpha / 10.0))
            path = VMobject(stroke_color=YELLOW)
            path.set_points_smoothly(points)
            return path

        left = Circle(stroke_color=BLUE_E, fill_opacity=1.0, radius=0.5).move_to(LEFT * 2)
        colors = [TEAL_A, TEAL_B, TEAL_C, TEAL_D, TEAL_E, GREEN_A]
        # Positive angles move counter-clockwise, negative angles move clockwise.
        examples = [-90, 0, 30, 90, 180, 270]
        anims = []
        for idx, angle in enumerate(examples):
            left_c = left.copy().shift((3 - idx) * UP)
            left_c.fill_color = colors[idx]
            right_c = left_c.copy().shift(4 * RIGHT)
            path_arc = make_arc_path(left_c.get_center(), right_c.get_center(),
                                     arc_angle=angle * DEGREES)
            desc = Text('%d°' % examples[idx]).next_to(left_c, LEFT)
            # Make the circles in front of the text in front of the arcs.
            self.add(
                path_arc.set_z_index(1),
                desc.set_z_index(2),
                left_c.set_z_index(3),
            )
            anims.append(Transform(left_c, right_c, path_arc=angle * DEGREES))

        self.play(*anims, run_time=2)
        self.wait()","Create a Manim animation showing six vertical examples of circles moving between left and right positions along defined curved paths. Each example should show a transition where a left circle (initial position on the left side of the screen) moves to the right along an arc path determined by a specified angle (in degrees: -90°, 0°, 30°, 90°, 180°, 270°). Negative angles curve clockwise; positive angles curve counter-clockwise). For each example:  
- Arrange examples vertically along the left half of the screen, spaced evenly from top to bottom.  
- The left circle has a 0.5 radius, starts blue, then changes to different TEAL and GREEN colors for subsequent examples.  
- The text showing the angle (e.g., ""30°"") is displayed to the left of each left circle.  
- The path of the arc is drawn as a yellow curve behind the circles and text.  
- The target position at the end of the animation is 4 units to the right of each starting circle.  
All transitions occur simultaneously, taking 2 seconds, followed by a short pause. The arcs must visually represent their respective angles (straight line for 0°, half-circle for 90°, etc.)."
"from manim import *

class Anagram(Scene):
    def construct(self):
        src = Text(""the morse code"")
        tar = Text(""here come dots"")
        self.play(Write(src))
        self.wait(0.5)
        self.play(TransformMatchingShapes(src, tar, path_arc=PI/2))
        self.wait(0.5)","Create an animation using Manim where the text ""the morse code"" first appears by being written on the screen. After a 0.5-second pause, the text morphs dynamically into ""here come dots"" by transforming each character along a 90-degree curved path (弧形路径). The transition should match characters between the two texts based on their shapes, with movement following the specified path angle. Add a 0.5-second pause after the initial writing and again after the transformation completes, ensuring smooth character alignment during the shape transformation."
"from manim import *

class MatchingEquationParts(Scene):
    def construct(self):
        variables = VGroup(MathTex(""a""), MathTex(""b""), MathTex(""c"")).arrange_submobjects().shift(UP)

        eq1 = MathTex(""{{x}}^2"", ""+"", ""{{y}}^2"", ""="", ""{{z}}^2"")
        eq2 = MathTex(""{{a}}^2"", ""+"", ""{{b}}^2"", ""="", ""{{c}}^2"")
        eq3 = MathTex(""{{a}}^2"", ""="", ""{{c}}^2"", ""-"", ""{{b}}^2"")

        self.add(eq1)
        self.wait(0.5)
        self.play(TransformMatchingTex(Group(eq1, variables), eq2))
        self.wait(0.5)
        self.play(TransformMatchingTex(eq2, eq3))
        self.wait(0.5)","Create an animation scene that shows the following sequence of visual transformations:

1. Start with the equation: ""x² + y² = z²"" displayed on the screen.
2. Above this equation, display three labeled variables (a, b, c) arranged horizontally.
3. The variables (a, b, c) move simultaneously into the corresponding placeholder positions in the equation, replacing x → a, y → b, and z → c, resulting in the equation ""a² + b² = c²"".
4. The new equation (a² + b² = c²) then rearranges itself algebraically to form ""a² = c² - b²"" by moving the ""b²"" term to the right side of the equation while preserving the equality structure.
5. All transitions between equations must use partwise morphing animations where variable terms visibly move from their original positions to new positions in the rearranged equations.

Require smooth morph/transform animations between each step, emphasizing the substitution of variables into placeholders first, followed by term rearrangement for algebraic transformation."
"from manim import *

class TangentAnimation(Scene):
    def construct(self):
        ax = Axes()
        sine = ax.plot(np.sin, color=RED)
        alpha = ValueTracker(0)
        point = always_redraw(
            lambda: Dot(
                sine.point_from_proportion(alpha.get_value()),
                color=BLUE
            )
        )
        tangent = always_redraw(
            lambda: TangentLine(
                sine,
                alpha=alpha.get_value(),
                color=YELLOW,
                length=4
            )
        )
        self.add(ax, sine, point, tangent)
        self.play(alpha.animate.set_value(1), rate_func=linear, run_time=2)","Create a Manim animation showing a blue dot moving along a red sine curve while a yellow tangent line dynamically adjusts its position and angle to remain tangent at the current point. Include the following details:
1. Display a coordinate system (Axes).
2. The sine curve is red and stationary on the axes.
3. The blue dot starts at the leftmost point of the sine curve and moves smoothly to the rightmost point over 2 seconds at constant speed.
4. The yellow tangent line (length 4 units) adjusts in real-time to stay tangent to the curve at the moving blue dot's position throughout the animation.
5. All elements (axes, curve, dot, tangent) are present from the start, with movement and tangent adjustment occurring as a single continuous animation sequence."
"from manim import *

class SpinningTriangle(Scene):
    def construct(self):
        tri = Triangle().set_fill(opacity=1).set_z_index(2)
        sq = Square().to_edge(LEFT)

        # will keep spinning while there is an animation going on
        always_rotate(tri, rate=2*PI, about_point=ORIGIN)

        self.add(tri, sq)
        self.play(sq.animate.to_edge(RIGHT), rate_func=linear, run_time=1)","Write a Manim animation scene named ""SpinningTriangle"" that includes the following:  
A solid-colored triangle (filled with opacity 1) placed at the center of the scene, continuously spinning around the origin (screen's center) at a rotational speed of 2π radians per second. Simultaneously, a square starts positioned on the left edge of the screen and slides smoothly to the right edge in a straight line over exactly 1 second. The triangle must remain on top of the square by setting its z-index higher (e.g., 2). The square's movement should use a linear timing function. Include both animations in the same scene, ensuring the triangle keeps spinning even as the square moves. Use appropriate Manim functions like 'always_rotate' for the spinning and 'animate' for the square's transition."
"from manim import *

class ShiftingSquare(Scene):
    def construct(self):
        sq = Square().set_fill(opacity=1)
        tri = Triangle()
        VGroup(sq, tri).arrange(LEFT)

        # construct a square which is continuously
        # shifted to the right
        always_shift(sq, RIGHT, rate=5)

        self.add(sq)
        self.play(tri.animate.set_fill(opacity=1))","Design a Manim animation scene that displays a square and a triangle positioned side by side (square on the left, triangle on the right). The square must continuously move to the right at a constant rate of 5 units per second throughout the animation. Simultaneously, gradually animate the triangle’s fill opacity from 0 to 1 to make it fully visible. The square should remain visible and filled at all times, while the triangle transitions from transparent to solid. Ensure the two shapes maintain their initial side-by-side arrangement while these transformations occur."
"from manim import *

class WelcomeToManim(Scene):
    def construct(self):
        words = Text(""Welcome to"")
        banner = ManimBanner().scale(0.5)
        VGroup(words, banner).arrange(DOWN)

        turn_animation_into_updater(Write(words, run_time=0.9))
        self.add(words)
        self.wait(0.5)
        self.play(banner.expand(), run_time=0.5)","Create a Manim animation scene where:  
1. Start by displaying the text ""Welcome to"" using a smooth writing animation that completes in 0.9 seconds. This animation should continuously render the text stroke-by-stroke while remaining visible once finished.  
2. The text ""Welcome to"" should stay centered on the screen and remain visible throughout the scene.  
3. Below the text, initially show a Manim logo banner scaled down to 50% of its original size. Position the banner directly below the text, creating a grouped vertical alignment.  
4. After the writing animation completes, wait for 0.5 seconds.  
5. Finally, animate the banner expanding from its small size to its full original size over 0.5 seconds while maintaining its vertical position below the text.  

The animation should combine:  
- Continuous text writing (not paused until completion).  
- A delayed banner expansion after a brief pause.  
- Proper vertical positioning between the text and banner."
"from manim import *

class UsefulAnnotations(Scene):
    def construct(self):
        m0 = Dot()
        m1 = AnnotationDot()
        m2 = LabeledDot(""ii"")
        m3 = LabeledDot(MathTex(r""\alpha"").set_color(ORANGE))
        m4 = CurvedArrow(2*LEFT, 2*RIGHT, radius= -5)
        m5 = CurvedArrow(2*LEFT, 2*RIGHT, radius= 8)
        m6 = CurvedDoubleArrow(ORIGIN, 2*RIGHT)

        self.add(m0, m1, m2, m3, m4, m5, m6)
        for i, mobj in enumerate(self.mobjects):
            mobj.shift(DOWN * (i-3))","""Create a Manim animation scene displaying a vertical column of different visual elements. The left-to-right arrangement in each row should include: (1) a simple dot, (2) a crosshair-style annotation dot, (3) a dot labeled with the text 'ii', (4) a dot labeled with an orange α symbol (using MathTex), (5) a curved arrow that bends downward from left to right, (6) a wide upward-bending curved arrow covering more space, and (7) a double-headed curved arrow pointing to the right. Each element must be spaced vertically so that they form a clear vertical sequence across the scene, centered horizontally. No movement or transitions should occur—they should all appear statically arranged from the start."""
"from manim import *

class AnnularSectorExample(Scene):
    def construct(self):
        # Changes background color to clearly visualize changes in fill_opacity.
        self.camera.background_color = WHITE

        # The default parameter start_angle is 0, so the AnnularSector starts from the +x-axis.
        s1 = AnnularSector(color=YELLOW).move_to(2 * UL)

        # Different inner_radius and outer_radius than the default.
        s2 = AnnularSector(inner_radius=1.5, outer_radius=2, angle=45 * DEGREES, color=RED).move_to(2 * UR)

        # fill_opacity is typically a number > 0 and <= 1. If fill_opacity=0, the AnnularSector is transparent.
        s3 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=PI, fill_opacity=0.25, color=BLUE).move_to(2 * DL)

        # With a negative value for the angle, the AnnularSector is drawn clockwise from the start value.
        s4 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=-3 * PI / 2, color=GREEN).move_to(2 * DR)

        self.add(s1, s2, s3, s4)","Create a Manim animation scene showing four AnnularSector shapes arranged at each corner of the screen. The scene's background should be white. The first AnnularSector (top-left) is yellow with default parameter settings except its position. The second (top-right) has an inner radius of 1.5, outer radius 2, a 45-degree angle, color red. The third (bottom-left) uses inner radius 1, outer 1.5, 180-degree angle, 25% fill opacity, blue color. The fourth (bottom-right) has inner radius 1, outer 1.5, angle -270 degrees (to sweep clockwise), green color. Position each sector 2 units away from the center in their respective directions (up-left, up-right, down-left, down-right). Use move_to with those coordinates. Do not animate their movement; simply display them on the screen."
"from manim import *

class AnnulusExample(Scene):
    def construct(self):
        annulus_1 = Annulus(inner_radius=0.5, outer_radius=1).shift(UP)
        annulus_2 = Annulus(inner_radius=0.3, outer_radius=0.6, color=RED).next_to(annulus_1, DOWN)
        self.add(annulus_1, annulus_2)","Generate a Manim animation scene featuring two annuli. The first annulus must have inner radius 0.5 and outer radius 1, positioned higher on the screen. The second annulus should have inner radius 0.3, outer radius 0.6, appear in red color, and be placed immediately below the first annulus without any overlap. Both shapes should remain stationary in their respective positions throughout the scene."
"from manim import *

class ArcExample(Scene):
    def construct(self):
        self.add(Arc(angle=PI))","Create a Manim animation scene where a single arc spanning an angle of π radians (180 degrees) is displayed on an empty screen. The arc should start from the positive x-axis and remain stationary without any movement, rotation, or transformation throughout the animation. Use default parameters for color, radius, and position unless specified otherwise."
"from manim import *

class ArcBetweenPointsExample(Scene):
    def construct(self):
        circle = Circle(radius=2, stroke_color=GREY)
        dot_1 = Dot(color=GREEN).move_to([2, 0, 0]).scale(0.5)
        dot_1_text = Tex(""(2,0)"").scale(0.5).next_to(dot_1, RIGHT).set_color(BLUE)
        dot_2 = Dot(color=GREEN).move_to([0, 2, 0]).scale(0.5)
        dot_2_text = Tex(""(0,2)"").scale(0.5).next_to(dot_2, UP).set_color(BLUE)
        arc= ArcBetweenPoints(start=2 * RIGHT, end=2 * UP, stroke_color=YELLOW)
        self.add(circle, dot_1, dot_2, dot_1_text, dot_2_text)
        self.play(Create(arc))","""Create a Manim animation scene that displays a grey circle with radius 2. Place two small green dots at coordinates (2,0) and (0,2). Add blue text labels showing each dot's coordinates positioned next to their respective dots: the (2,0) label to the right of the first dot, and the (0,2) label above the second dot. Animate the creation of a yellow arc connecting the two dots directly (using ArcBetweenPoints), starting the animation after all other elements are displayed. Ensure the arc starts at (2,0) and ends at (0,2), forming a circular path on the screen."""
"from manim import *

class SeveralArcPolygons(Scene):
    def construct(self):
        a = [0, 0, 0]
        b = [2, 0, 0]
        c = [0, 2, 0]
        ap1 = ArcPolygon(a, b, c, radius=2)
        ap2 = ArcPolygon(a, b, c, angle=45*DEGREES)
        ap3 = ArcPolygon(a, b, c, arc_config={'radius': 1.7, 'color': RED})
        ap4 = ArcPolygon(a, b, c, color=RED, fill_opacity=1,
                                    arc_config=[{'radius': 1.7, 'color': RED},
                                    {'angle': 20*DEGREES, 'color': BLUE},
                                    {'radius': 1}])
        ap_group = VGroup(ap1, ap2, ap3, ap4).arrange()
        self.play(*[Create(ap) for ap in [ap1, ap2, ap3, ap4]])
        self.wait()","Create a Manim animation scene where four different ArcPolygon shapes are displayed side by side. The first shape connects points (0,0), (2,0), and (0,2) with arcs of radius 2. The second uses the same points but with each arc bent at 45-degree angles. The third is a red-colored shape with 1.7 radius arcs and red fill. The fourth shape has a solid red fill, with each arc individually customized: the first arc uses radius 1.7 and red, the second has a 20-degree blue arc, and the third has a radius of 1. All four shapes should appear on screen simultaneously with smooth creation animations, then pause briefly."
"from manim import *

class ArcPolygonExample(Scene):
    def construct(self):
        arc_conf = {""stroke_width"": 0}
        poly_conf = {""stroke_width"": 10, ""stroke_color"": BLUE,
              ""fill_opacity"": 1, ""color"": PURPLE}
        a = [-1, 0, 0]
        b = [1, 0, 0]
        c = [0, np.sqrt(3), 0]
        arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)
        arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)
        arc2 = ArcBetweenPoints(c, a, radius=2, **arc_conf)
        reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)
        self.play(FadeIn(reuleaux_tri))
        self.wait(2)","Create a Manim animation scene that shows a Reuleaux triangle. The scene should start with three circular arcs forming the shape. Each arc connects vertices of an equilateral triangle with coordinates (-1,0), (1,0), and (0, np.sqrt(3)). The arcs must have a radius of 2 units. The Reuleaux triangle must be displayed with a blue border (stroke_width: 10) and purple fill (fill_opacity: 1). Animate the shape fading in, then pause for 2 seconds. Use ArcBetweenPoints for the arcs, combine them with ArcPolygonFromArcs, and apply the specified styling."
"from manim import *

class ArcPolygonExample2(Scene):
    def construct(self):
        arc_conf = {""stroke_width"": 3, ""stroke_color"": BLUE,
            ""fill_opacity"": 0.5, ""color"": GREEN}
        poly_conf = {""color"": None}
        a = [-1, 0, 0]
        b = [1, 0, 0]
        c = [0, np.sqrt(3), 0]
        arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)
        arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)
        arc2 = ArcBetweenPoints(c, a, radius=2, stroke_color=RED)
        reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)
        self.play(FadeIn(reuleaux_tri))
        self.wait(2)","Design a Manim animation scene for a Reuleaux triangle with the following elements:  
1. **Visual Components**:  
   - Three circular arcs of radius 2, forming a symmetrical shape.  
   - Arcs connect points **A (-1, 0, 0)**, **B (1, 0, 0)**, and **C (0, √3, 0)**.  
   - First two arcs (A-B and B-C) have **blue strokes** (**stroke_width=3**), while the third arc (C-A) has a **red stroke**.  
   - The enclosed area is filled with **green (#GREEN)** and has **50% opacity**.  

2. **Animation Sequence**:  
   - The Reuleaux triangle **fades in** smoothly.  
   - The animation pauses for **2 seconds** after completion.  

Focus on accurate geometric construction using **ArcBetweenPoints**, **ArcPolygonFromArcs**, and appropriate styling parameters."
"from manim import *

class CircleExample(Scene):
    def construct(self):
        circle_1 = Circle(radius=1.0)
        circle_2 = Circle(radius=1.5, color=GREEN)
        circle_3 = Circle(radius=1.0, color=BLUE_B, fill_opacity=1)

        circle_group = Group(circle_1, circle_2, circle_3).arrange(buff=1)
        self.add(circle_group)","Create a Manim animation scene displaying three circles arranged in a row with spacing between them. The first circle should have a radius of 1.0 and default color. The second circle must be green with a radius of 1.5. The third circle must be fully filled (fill_opacity=1) with radius 1.0 and color BLUE_B. Arrange all three circles horizontally, maintaining a gap of 1 unit between each."
"from manim import *

class CircleFromPointsExample(Scene):
    def construct(self):
        circle = Circle.from_three_points(LEFT, LEFT + UP, UP * 2, color=RED)
        dots = VGroup(
            Dot(LEFT),
            Dot(LEFT + UP),
            Dot(UP * 2),
        )
        self.add(NumberPlane(), circle, dots)","""Write the Manim code to create an animation scene (called CircleFromPointsExample) that displays the following elements: 1) Three points/coordinates visually marked with dots (Dot objects) at positions LEFT, LEFT + UP, and UP*2. 2) A circle drawn through these three points using the Circle.from_three_points() method, colored red (RED). 3) A number plane (NumberPlane) as the background grid. The dots should be grouped into a VGroup. Ensure the scene adds the number plane first, then the circle, then the dots."""
"from manim import *

class PointAtAngleExample(Scene):
    def construct(self):
        circle = Circle(radius=2.0)
        p1 = circle.point_at_angle(PI/2)
        p2 = circle.point_at_angle(270*DEGREES)

        s1 = Square(side_length=0.25).move_to(p1)
        s2 = Square(side_length=0.25).move_to(p2)
        self.add(circle, s1, s2)",Create a Manim animation scene where a circle of radius 2.0 is displayed. Place two small squares (side length 0.25) at the top and bottom points of the circle. The first square should be positioned at 90 degrees (PI/2 radians) and the second at 270 degrees (270*DEGREES) on the circle's circumference. Show both squares stationary at their respective positions on the circle.
"from manim import *

class CircleSurround(Scene):
    def construct(self):
        triangle1 = Triangle()
        circle1 = Circle().surround(triangle1)
        group1 = Group(triangle1,circle1) # treat the two mobjects as one

        line2 = Line()
        circle2 = Circle().surround(line2, buffer_factor=2.0)
        group2 = Group(line2,circle2)

        # buffer_factor < 1, so the circle is smaller than the square
        square3 = Square()
        circle3 = Circle().surround(square3, buffer_factor=0.5)
        group3 = Group(square3, circle3)

        group = Group(group1, group2, group3).arrange(buff=1)
        self.add(group)","Design an animation scene using Manim where three groups of shapes are displayed side by side. Each group consists of a central shape (triangle, straight line, square) surrounded by a circle. The first group shows a triangle perfectly enclosed by a circle. The second group shows a line with a significantly larger surrounding circle (buffer factor 2.0), while the third group shows a square with a much tighter-fit circle (buffer factor 0.5). Arrange all three groups horizontally with spacing between them. Ensure the circle's size relationship to the enclosed shape varies明显ly in each group to show buffer_factor's effect."
"from manim import *

class BezierSplineExample(Scene):
    def construct(self):
        p1 = np.array([-3, 1, 0])
        p1b = p1 + [1, 0, 0]
        d1 = Dot(point=p1).set_color(BLUE)
        l1 = Line(p1, p1b)
        p2 = np.array([3, -1, 0])
        p2b = p2 - [1, 0, 0]
        d2 = Dot(point=p2).set_color(RED)
        l2 = Line(p2, p2b)
        bezier = CubicBezier(p1b, p1b + 3 * RIGHT, p2b - 3 * RIGHT, p2b)
        self.add(l1, d1, l2, d2, bezier)","Create a Manim Scene that shows the following elements without any animations or transitions:
1. A blue dot at (-3, 1).0) and a line extending 1 unit to the right from this dot
2. A red dot at (3, -1.0) and a line extending 1 unit to the left from this dot
3. A cubic Bézier curve connecting the line endpoints (right end of blue line at (-2,1.0) and left end of red line at (2,-1.0). The Bézier curve must have its first control point 3 units to the right of the blue line's endpoint and its second control point 3 units to the left of the red line's endpoint. The curve should pass through these guide points. All elements should be displayed statically when rendered."
"from manim import *

class DotExample(Scene):
    def construct(self):
        dot1 = Dot(point=LEFT, radius=0.08)
        dot2 = Dot(point=ORIGIN)
        dot3 = Dot(point=RIGHT)
        self.add(dot1,dot2,dot3)","Create a Manim Python code to animate a scene where three dots are positioned horizontally at the left, center, and right of the screen. The left dot has a radius of 0.08, while the others are the default size. The dots should appear all at once without any movement or transformations."
"from manim import *

class EllipseExample(Scene):
    def construct(self):
        ellipse_1 = Ellipse(width=2.0, height=4.0, color=BLUE_B)
        ellipse_2 = Ellipse(width=4.0, height=1.0, color=BLUE_D)
        ellipse_group = Group(ellipse_1,ellipse_2).arrange(buff=1)
        self.add(ellipse_group)",Write a Manim Scene code to animate and display two ellipses side by side. The first ellipse should have a width of 2.0 and height of 4.0 in color BLUE_B. The second ellipse must have a width of 4.0 and a height of 1.0 using color BLUE_D. Arrange the two ellipses horizontally with a buffer space of 1 unit between them. The entire group should be displayed static on the screen without any movements or transformations.
"from manim import *

class SeveralLabeledDots(Scene):
    def construct(self):
        sq = Square(fill_color=RED, fill_opacity=1)
        self.add(sq)
        dot1 = LabeledDot(Tex(""42"", color=RED))
        dot2 = LabeledDot(MathTex(""a"", color=GREEN))
        dot3 = LabeledDot(Text(""ii"", color=BLUE))
        dot4 = LabeledDot(""3"")
        dot1.next_to(sq, UL)
        dot2.next_to(sq, UR)
        dot3.next_to(sq, DL)
        dot4.next_to(sq, DR)
        self.add(dot1, dot2, dot3, dot4)","""Design a Manim animation that shows a red filled square centered on the screen, with four labeled dots positioned at each of its four corners. The upper-left corner should have a red-numbered label (label text: '42' using TeX), the upper-right corner should have a green variable label (label text: 'a' in MathTeX), the lower-left corner should have a blue textual label (label text: 'ii' using plain text), and the lower-right corner should have a neutral numeric label (label text: '3'). Each label should stay attached to its respective corner of the square without any movement or transformation once placed."""
"from manim import *

class ExampleSector(Scene):
    def construct(self):
        sector = Sector(radius=2)
        sector2 = Sector(radius=2.5, angle=60*DEGREES).move_to([-3, 0, 0])
        sector.set_color(RED)
        sector2.set_color(PINK)
        self.add(sector, sector2)","""Create a Manim animation scene with two stationary sectors. The first sector must have a radius of 2 units, be colored red, and remain centered at the origin. The second sector should have a radius of 2.5 units, an angle of 60 degrees, positioned 3 units to the left of the center at coordinates (-3, 0, 0), and colored pink. Ensure neither sector moves or transforms during the animation."""
"from manim import *

class DifferenceExample(Scene):
    def construct(self):
        sq = Square(color=RED, fill_opacity=1)
        sq.move_to([-2, 0, 0])
        cr = Circle(color=BLUE, fill_opacity=1)
        cr.move_to([-1.3, 0.7, 0])
        un = Difference(sq, cr, color=GREEN, fill_opacity=1)
        un.move_to([1.5, 0, 0])
        self.add(sq, cr, un)","Create a Manim animation scene showing three shapes: a solid red square on the left, a solid blue circle overlapping it positioned slightly to the right and above, and a third solid green shape representing the set difference (the area of the square not covered by the circle) placed on the far right. The square should be centered at coordinates (-2, 0), the circle at (-1.3, 0.7), and the difference shape at (1.5, 0). All shapes must be fully filled (opacity 1) with their respective colors. The scene should display all three static elements arranged side by side to visually demonstrate the set difference operation."
"from manim import *

class IntersectionExample(Scene):
    def construct(self):
        sq = Square(color=RED, fill_opacity=1)
        sq.move_to([-2, 0, 0])
        cr = Circle(color=BLUE, fill_opacity=1)
        cr.move_to([-1.3, 0.7, 0])
        un = Exclusion(sq, cr, color=GREEN, fill_opacity=1)
        un.move_to([1.5, 0.4, 0])
        self.add(sq, cr, un)","Create a Manim animation scene where three colored shapes are displayed side by side. The first shape is a solid red square positioned on the left side of the screen. The second is a solid blue circle placed slightly to the right and upward from the square. The third shape is a solid green exclusion (representing the non-overlapping regions between the square and circle) positioned on the right side of the screen. All three shapes should be static and visible simultaneously from the start of the scene. Use exact coordinates for positioning: square at (-2, 0, 0), circle at (-1.3, 0.7, 0), and exclusion shape at (1.5, 0.4, 0)."
"from manim import *

class IntersectionExample(Scene):
    def construct(self):
        sq = Square(color=RED, fill_opacity=1)
        sq.move_to([-2, 0, 0])
        cr = Circle(color=BLUE, fill_opacity=1)
        cr.move_to([-1.3, 0.7, 0])
        un = Intersection(sq, cr, color=GREEN, fill_opacity=1)
        un.move_to([1.5, 0, 0])
        self.add(sq, cr, un)","Create a Manim animation scene that shows three static elements arranged side-by-side: a red filled square and a blue filled circle overlapping partially in the left portion of the screen, with their overlapping intersection area displayed as a separate green filled shape positioned on the right side of the screen. The square should be positioned on the far left, the circle slightly overlapping it on the left side, while the green intersection shape is placed to the right, clearly showing their positions and relationship. All three shapes must remain static and visible simultaneously throughout the scene."
"from manim import *

class UnionExample(Scene):
    def construct(self):
        sq = Square(color=RED, fill_opacity=1)
        sq.move_to([-2, 0, 0])
        cr = Circle(color=BLUE, fill_opacity=1)
        cr.move_to([-1.3, 0.7, 0])
        un = Union(sq, cr, color=GREEN, fill_opacity=1)
        un.move_to([1.5, 0.3, 0])
        self.add(sq, cr, un)","Create a Manim animation scene showing three static elements. One is a solid red square positioned at (-2, 0), another is a solid blue circle at (-1.3, 0.7), and the third is their solid green union shape placed at (1.5, 0.3. The union must be formed by merging the square and circle using the Union class, with all three shapes displaying full fill opacity and no motion."
"from manim import *

class LabelExample(Scene):
    def construct(self):
        label = Label(
            label=Text('Label Text', font='sans-serif'),
            box_config = {
                ""color"" : BLUE,
                ""fill_opacity"" : 0.75
            }
        )
        label.scale(3)
        self.add(label)","""Write a Manim Python code to create an animation scene named LabelExample. The scene should display a blue rectangular box filled at 75% opacity containing the centered text 'Label Text' in sans-serif font. The entire label must be scaled to three times its original size and displayed stationary on the screen. Include all necessary imports and ensure the label’s text and box configuration are properly defined."""
"from manim import *

class LabeledArrowExample(Scene):
    def construct(self):
        l_arrow = LabeledArrow(""0.5"", start=LEFT*3, end=RIGHT*3 + UP*2, label_position=0.5)

        self.add(l_arrow)","""Create a Manim scene named LabeledArrowExample that displays an arrow with a label. The arrow should start at a position 3 units to the left (LEFT*3), end at a position 3 units right and 2 units up (RIGHT*3 + UP*2). The label should display the text '0.5' and be placed exactly halfway along the arrow's path (label_position=0.5). Include all necessary imports and structure for a runnable code example."""
"from manim import *

class LabeledLineExample(Scene):
    def construct(self):
        line = LabeledLine(
            label          = '0.5',
            label_position = 0.8,
            label_config = {
                ""font_size"" : 20
            },
            start=LEFT+DOWN,
            end=RIGHT+UP)

        line.set_length(line.get_length() * 2)
        self.add(line)","Write a Manim scene that animates a labeled line starting at the position LEFT+DOWN and ending at RIGHT+UP. The line has a numeric label ""0.5"" placed 80% along its length with a font size of 20. After initialization, the line's total length is doubled while maintaining its orientation. The final scene should display this scaled line with the label positioned proportionally along the extended length. Use the LabeledLine class from Manim's library to implement this visualization with precise parameter configurations."
"from manim import *

class LabeledPolygramExample(Scene):
    def construct(self):
        # Define Rings
        ring1 = [
            [-3.8, -2.4, 0], [-2.4, -2.5, 0], [-1.3, -1.6, 0], [-0.2, -1.7, 0],
            [1.7, -2.5, 0], [2.9, -2.6, 0], [3.5, -1.5, 0], [4.9, -1.4, 0],
            [4.5, 0.2, 0], [4.7, 1.6, 0], [3.5, 2.4, 0], [1.1, 2.5, 0],
            [-0.1, 0.9, 0], [-1.2, 0.5, 0], [-1.6, 0.7, 0], [-1.4, 1.9, 0],
            [-2.6, 2.6, 0], [-4.4, 1.2, 0], [-4.9, -0.8, 0], [-3.8, -2.4, 0]
        ]
        ring2 = [
            [0.2, -1.2, 0], [0.9, -1.2, 0], [1.4, -2.0, 0], [2.1, -1.6, 0],
            [2.2, -0.5, 0], [1.4, 0.0, 0], [0.4, -0.2, 0], [0.2, -1.2, 0]
        ]
        ring3 = [[-2.7, 1.4, 0], [-2.3, 1.7, 0], [-2.8, 1.9, 0], [-2.7, 1.4, 0]]

        # Create Polygons (for reference)
        p1 = Polygon(*ring1, fill_opacity=0.75)
        p2 = Polygon(*ring2, fill_color=BLACK, fill_opacity=1)
        p3 = Polygon(*ring3, fill_color=BLACK, fill_opacity=1)

        # Create Labeled Polygram
        polygram = LabeledPolygram(
            *[ring1, ring2, ring3],
            label=Text('Pole', font='sans-serif'),
            precision=0.01,
        )

        # Display Circle (for reference)
        circle = Circle(radius=polygram.radius, color=WHITE).move_to(polygram.pole)

        self.add(p1, p2, p3)
        self.add(polygram)
        self.add(circle)","<think>
Okay, I need to figure out what the user is asking here. They provided a Manim code example and want me to come up with a prompt that someone would use to ask an LLM to generate that exact code. The key is that the prompt should include all necessary details about the animation's visual elements, their movements, transformations, etc., and nothing else.

First, I should analyze the code to understand what's happening. The code defines a Scene class called LabeledPolygramExample. There are three rings (lists of coordinates) forming a polygram. The polygram is created with those rings, along with a label 'Pole', and added to the scene. There's also a circle displayed at the pole's position with the same radius as the polygram.

Looking at the elements:
- ring1 has many points, forming the outer polygon.
- ring2 and ring3 are inner polygons filled in black, possibly creating holes.
- The LabeledPolygram combines these rings, places the label 'Pole', and maybe has a radius based on those rings.
- The circle is added to show the pole's position and radius, which might be centered at some point derived from the polygram.

Now, the prompt needs to describe each visual component and their arrangement without referencing code specifics. Since LLMs need clear instructions, the prompt must detail the shapes, colors, label placement, etc., and any animations (though in this code, there's no animation methods like .animate used, it's just constructing objects and self.add() which is static display).

Wait, in the construct, they are using self.add, so the desired animation is a static scene with the objects displayed together. The prompt must ask for that setup. Also, note that 'p1', 'p2', 'p3' are separate polygons displayed, but the LabeledPolygram is also added on top. The circle shows the pole's radius and location.

Wait the LabeledPolygram might already include those rings, but they also individually added p1, p2, p3 along with polygram, which could imply redundant shapes. So perhaps the prompt requires explicitly adding reference polygons and the labeled polygram along with the circle.

Thus, the prompt should ask for creating a scene with three polygon rings forming a labeled polygram, each with specific colors and opacities. The label should be 'Pole', and there should be a white circle indicating the center and radius, at the polygram's pole position.

I should make sure to mention each polygon's fill color: p1 has 0.75 opacity (so maybe a solid color, perhaps default, like blue), p2 and p3 are filled with black, fully opaque. The labeled polygram is also added, suggesting it might have its own styling, but the main point is that all elements are included as per the code.

Also, the coordinates are given as lists in ring1 to ring3, which form the shapes. The user is likely expecting an animation where these shapes are drawn, but in the current code, it's just static. Wait the code doesn't have any animations beyond creation and display. The construct function adds them to the scene, so maybe it's a still image? Hmm, maybe the original code is just displaying the static shapes. So the prompt should ask for a still scene showing the structures.

Putting this together, the prompt would need to specify each component's role: the polygons representing the rings, the labeled polygram combining them, the black inner shapes, the circle reference.

Wait, the code also has self.add(p1, p2, p3), then adds the LabeledPolygram. That might mean the polygons are drawn as separate layers. But since the LabeledPolygram itself is built from the rings, maybe that's just for debugging or visual clarity. The exact prompt would need to mention these elements.

I think the prompt should say something like:

""Create a Manim animation that displays a labeled polygram composed of three polygon rings. The first outer ring has points at coordinates [and lists all coordinates for ring1], filled with some color. The second inner ring uses ring2's coordinates, filled black. The third small ring is ring3, also black. A text label 'Pole' should be placed at the center, and a white circle matching the polygram's radius and center should be present to indicate the center position.""

Wait, but the code has the polygram created with the rings, and also the separate p1,p2,p3 are displayed. Since they are all added via self.add, they must all be visible in the final scene. The prompt needs to mention that all three polygons (the outer, two inner) are drawn, along with the LabeledPolygram and the circle. Maybe the user wants the LabeledPolygram to be an overlay or combined shape?

Alternatively, perhaps the LabeledPolygram is just a different way to create the same as the polygons, but the code includes both. Since the user wants a prompt that results in the provided code, the prompt must include all those elements explicitly. So, the question needs to ask for:

- A scene with three groups of coordinates forming polygons (defining each ring's points), with the first filled with 75% opacity, others black and fully opaque.
- The labeled polygram object that uses these rings as input, with the label 'Pole', positioned at their center.
- A white circle that matches the polygram's radius and center point.

The prompt must be precise about each of those elements. The user also wants the code to use LabeledPolygram, but if someone doesn't know Manim well, the prompt must describe visually what to do so that the code correctly uses these classes. Alternatively, since the prompt is to generate that exact code, maybe it's better to describe the animation precisely without knowing the code structure. They just need to explain the desired final image, which should lead to writing that code.

Also, the Polygons are created from the ring lists, and the LabeledPolygram is initialized with those three rings and the text. The circle is placed at polygram.pole with its radius.

The prompt should mention the specific coordinates for each ring (maybe?), but wait, the user's code uses arrays like ring1, ring2, etc. But since the user is asking for the prompt that would generate the code, perhaps the prompt need not list coordinates but just say ""three predefined polygon rings with specific coordinates"", but the code needs those coordinates. Hmm, this is tricky because the LLM might not get all the coordinates. Alternatively, maybe the problem assumes the LLM can determine coordinates (unlikely), so perhaps the coordinates are important here.

Wait the user's code uses specific coordinates. To get that exact code, the prompt must specify where each ring's coordinates are, otherwise the generated code could use different rings.

Wait, but the user might only want a general description of the scene, and not the exact coordinates. Since the user wants the prompt that would allow an LLM to produce this code, the prompt needs to be precise enough so that the coordinates are part of the rings. Since the code includes the coordinate lists, the prompt must describe those polygons.

Wait, maybe the actual coordinates' specific positions aren't as important unless the prompt asks for it. But the code uses specific coordinates to form the rings. However, the user might not want to mention coordinates in the prompt, instead describing the visual arrangement. Let me think.

Alternatively, perhaps the points in ring1 form an irregular polygon, and ring2 forms a smaller inner one, then the third is another inner small triangle. But the coordinate arrays are explicit, so the prompt should specify that the first ring has 20 points arranged in a certain way? But that's too specific. Maybe the user wants the prompt to describe the structure without listing points. Wait the user says ""keep details such as visual elements..."" So maybe the prompt should mention the shapes (number of vertices, relative positions?), but without coordinates?

Alternatively, maybe the rings form specific shapes, like a star or complex polygon. But since the rings have specific coordinates, it's too detailed for a prompt. The user probably wants the prompt to describe the animation components as generally as possible but with all visual elements mentioned.

Hmm, since the LLM won't know the coordinates, but the user's provided code does, so the prompt must at least mention that the polygons are defined by coordinate lists, but the specific points are defined by the user's structure (the three rings as given). But maybe the prompt would need to just say ""create a labeled polygram with three rings, with the first having several vertices forming an outer shape..."" and so on, but perhaps that’s too vague?

The user wants the code generated exactly. Therefore, the prompt has to include all the details present in the code. However, if they list the coordinates in the prompt, that would make the code generate those points. But the user's question is to create a prompt that would make the LLM generate exactly the given code, so the prompt must include all these elements. Since the code constructs each polygon, the prompt must ask for each of the components:

""Create a Manim Scene called LabeledPolygramExample where the following are displayed:

1. Three polygon rings drawn with specific coordinates:
   - The first ring has vertices at the points: (-3.8,-2.4), (-2.4,-2.5), etc. (list ring1's coordinates in the prompt?)
   - The second ring uses ring2's coordinates.
   - The third ring uses ring3's coordinates.

2. Fill the first polygon with some color (maybe default) with 75% opacity, and the second and third fully filled in black.

3. Add a LabeledPolygram object using the three rings, including a white text label 'Pole' at the center.

4. Alongside, add a white circle that has the same radius and center as the polygram's pole.""

But the problem is that if coordinates are part of the prompt, they need to be listed. But the user's code has the coordinate lists explicitly written in their code, so the prompt must mention all the coordinates, which is too long.

Wait, perhaps the user's example can have a prompt that refers to creating rings around the pole, but with certain numbers of vertices. Alternatively, the prompt doesn't need the exact coordinates but just the structure, trusting the LLM to set up the data points correctly. But in the code, each ring is a list of points forming a closed shape.

Alternatively, the prompt is about creating layered polygons with the black inner rings and a label, so the key elements are:

- Three layers: an outer polygon, an inner polygon, and another small one.

But since the code uses specific coordinates, the prompt would have to include those coordinates. However, writing all those coordinates in a natural language might be tedious but necessary.

Wait the problem says ""create the prompt that would generate the code"". The key points are:

- The scene has three polygons (p1, p2, p3 as defined by ring1, ring2, ring3)
- The LabeledPolygram uses these three rings with the label 'Pole'
- A circle around the pole's position with the same radius as the polygram's.

The coordinates are stored in ring1, ring2, ring3 variables, so the prompt would need to include all these coordinates in their structure. That's part of the code, so the prompt would need to state to ""create a LabeledPolygram with three rings specified by these coordinates..."".

Alternatively, perhaps the user wants a more general description, trusting the LLM to structure the coordinates, but that would vary. But the exact Manim code is given, so the prompt must detail each element precisely.

Hmm. The user wants the prompt such that when given to an LLM, the LLM would code it exactly as provided. So the prompt must include all the necessary elements to derive the code.

The code snippet has three polygons created from the rings; each coordinate list is for each ring. So the prompt must specify the exact coordinate points? That's too specific. Since coordinates are precise, they must be part of the prompt. But perhaps in the problem's context, the coordinates are just example points, and the main part is the relationships.

Alternatively, the prompt mentions three rings forming a complex shape with holes, and that the rings are represented as polygons with specific points, but perhaps the user just wants the code structure. Alternatively, maybe the problem is more about the structure and not exact coordinates, so the prompt can abstract the coordinates as defined lists without listing them, but the LLM is supposed to set up the variables.

Given the code, the precise prompt would have to describe that the scene should display an outer polygon (ring1), two filled-black polygons inside (ring2 and ring3), a LabeledPolygram combining these, with the label 'Pole', and a circle whose center is the pole's position and radius equal to the polygram.

Maybe the prompt says:

""Write a Manim scene that creates an animation (or static scene) displaying the following:

- An outer polygon (ring1) with vertices at specific coordinates forming a complex shape, filled with 75% opacity.
- Two smaller polygons inside (ring2 and ring3) filled completely black.
- A LabeledPolygram object using all three rings, labeled 'Pole' at the figure's center.
- A white circle centered on the pole's location with the same radius as the polygram's outer edge.

Provide the complete Python code using Manim imports, defining a Scene class with the necessary Polygon and LabeledPolygram elements.""

Wait but maybe more precise. The actual prompt needs to capture:

- the three rings, defined as polygon coordinates, added to the scene (construct contains self.add(p1, p2, p3, polygram, circle).

Wait the construct method adds them all, so the prompt must include all those elements. The LabeledPolygram is another object added on top.

Alternatively, the prompt would be:

""Create a Manim animation scene named LabeledPolygramExample where:

1. Three polygrams are defined: ring1 has vertices at the points [list all ring1 points], ring2 uses the points [ring2 points], and ring3 the [ring3 points].
2. Each polygon is rendered with the first with 75% opacity fill (default color), the second and third with black fill and 100% opacity.
3. A LabeledPolygram is created using the three rings, including a label 'Pole' centered at the figure's pole location.
4. Add a white circle whose radius matches the polygram's calculated radius and centered at the pole.
5. All elements are displayed simultaneously in the scene.""

Make sure to use the Polygon class for each ring, apply proper fill properties, add the LabeledPolygram with provided label and precision 0.01, and include the circle based on the polygram's properties.""

Wait but the code's rings are defined as lists, so the prompt should ask for the creation of polygons using the coordinates of ring1, 2,3, but the coordinates are part of the code. Since the user is asking for the prompt, the question must be stated as a task that would make the LLM write exactly this code, which requires the precise instruction on how each polygon is set up.

Alternatively, perhaps the exact prompt would be to generate code showing a labeled polygram with three specific polygon rings and the other elements. Since the coordinates are part of the structure, the prompt must specify that.

Alternatively, maybe the prompt focuses on elements rather than their coordinates:

""Design a Manim animation scene that displays the following elements:

- An outer polygon with 20 vertices, forming an irregular shape (like a star or complex figure), with coordinates specified as [each coordinate in ring1 array].
- An inner smaller polygon with 8 vertices (ring2 coordinates) filled black, creating a hole in the center
- Another tiny polygon (ring3) forming a small triangle (its coordinates given)
- The LabeledPolygram element built from all three rings, which adds a white label 'Pole' at the center of these shapes.
- A white circle that centers at the same point as the label and has a radius matching the largest circle encompassing the outer polygon.

Make sure the scene uses Polygon and LabeledPolygram properly.""

Wait but that still won't generate the exact coordinate lists. So perhaps the prompt must include the coordinates. But perhaps the user expects that the prompt would specify the coordinates as provided.

The problem states that the LLM is to generate the code, so prompt must give all the parameters. Therefore, the prompt must include every detail in the code except possibly variable names.

Hmm, but in the prompt, variables like ring1, ring2 aren't there. Alternatively, it would be natural to say ""three polygons using the coordinates [lists]..."", but that's a lot of numbers, but as the user's code requires that, the prompt must include the coordinate points. Since the code includes them, the prompt should say ""the outer ring has vertices at the points: (-3.8, -2.4..., [-2.4, -2.5...), etc.) for all points in each ring's lists. But writing all the coordinates in the prompt might be necessary.

But since the user is asking to write the prompt for someone to describe the scene so the code is generated. The user wants the exact code, so the prompt must specify:

The scene must:

- Show three polygon rings defined by these three point lists ([provide coordinates?]).
- The first ring is filled with 75% transparency, the second and third fully filled with black.
- Overlay a labeled polygram using those rings with 'Pole' label.
- Add a white circle at the same center as the label with the same radius as the outer ring.

Therefore, the coordinates have to be part of the prompt's description. But since those coordinates are specific coordinates, the prompt must list them. However, maybe the assistant is supposed to realize that, for example, ring1 has a long list of vertices forming an intricate closed path, and the inner rings as smaller closed polygons.

Alternatively, perhaps the coordinates can be described as example points, but the user wants the exact code. Therefore, the prompt should contain everything but code.

Alternatively, focusing on the visual aspects:

""I want to create an animation scene in Manim that visually represents a labeled polygon with three rings. The first ring is an outer polygon defined by the following set of coordinates: a list of 20 points forming an irregular shape (give ring1's points), then an inner polygon (ring2's 8 points), and another tiny polygon. All three are to be displayed as filled polygons. The second and third polygons are filled with black, hiding parts of the first. Additionally, create a LabeledPolygram with the three rings, include a label ""Pole"" at the center, and a concentric circle of the same center. The circle's radius equals that of the LabeledPolygram.""

Wait, but if coordinates are important, they are essential. The code can't be generated without them unless the user assumes the LLM creates the data, but in this case the desired code includes those coordinates, so the prompt must instruct to include the coordinates as lists.

Alternatively, the prompt may describe the final image's description without coordinates, so LLM comes up with coordinates based on that. But the code has coordinates, so the prompt must give coordinates. But that's a lot. Alternatively, maybe the coordinates aren't crucial as part of the prompt; perhaps the user expects the general description.

Hmm, the user wants the prompt that would allow generating the code provided. Since the code includes the coordinates, perhaps the prompt must include verbiage such as the following:

""Write the code for a manim scene called LabeledPolygramExample that draws three polygonal rings. The first ring has vertices at the points of ring1 (list them), which are -3.8, -2.4 etc. list all ring1 coordinates), then next rings. Then, etc.""

But the problem might prefer not to list coordinates, but I'm confused.

Alternatively, since the final code has all those coordinates, the prompt must list them in a detailed way. Let me look at the rings again.

Ring1 has 20 points, ring2 has 8, ring3 has 4. The prompt must specify that:

First ring has coordinates as (x, y, 0) points listed in ring1...

The prompt has to be precise enough that the LLM would use Polygon constructors for each, with those coordinates, then combine them into the LabeledPolygram and add the circle.

Thus, the prompt must include the coordinates in the description. The user wants the code to be generated, so the prompt has to precisely describe each element's properties. Otherwise, if coordinates are left out, the LLM might generate different coordinates.

Wait but perhaps the coordinates are part of the 'specific visual elements' mentioned in the user's problem statement. The problem says ""details such as visual elements"", so the coordinates are part of those visual elements.

The user specified that the prompt must include details like visual elements, their movements and transformations. Since all elements are static here, it's just the structure. Since the code uses those coordinates as fixed, the prompt must include them as lists.

So the final prompt should probably look like this:

""Create a Manim animation scene showing a labeled polygram constructed from three polygon rings. The first ring is formed from the following coordinates: ([give the exact coordinates for each ring's points in a list format]). The first polygon has a fill with 75% opacity, while the second and third are solid black. The LabeledPolygram element combines these rings, with the label 'Pole' positioned at the center. Add a white circle at the center with radius same as the polygram's outer edge.""

Additionally, all polygons and the label should be displayed on the screen in the scene.""

Wait, but perhaps the exact phrasing would be needed to generate that code, so the prompt could be phrased as follows, trying to translate each line into the prompt:

I think the accurate prompt would need to mention each element exactly as in the code, so that the code's coordinates and parameters are included. So the prompt would read something like:

I need a Manim animation that shows three polygon rings (outer, middle, inner), each specified by their vertices coordinates), filled appropriately, plus a labeled pole at center and a circle around it.""

Therefore, the complete prompt, in order:

""Design a Manim animation scene where:

- The first polygon has these coordinates: [list ring1]. It should be filled semi-transparently (75% opaque).

- The second polygon is made of [ring2's coordinates], filled completely black.

- The third polygon uses [ring3's coordinates] with full black fill.

- A LabeledPolygram is created using all three rings, including the text label 'Pole' placed at the polygram's center point.

- Add a white circle centered at the polygram's pole with radius equal to the polygram's calculated radius.

Include the necessary classes (Polygon, LabeledPolygram, ...) and ensure the circle follows the polygram's properties.""

Wait but in the code, the Polygons are created with *ring1 for each, but written as lists. The 'LabeledPolygram is instantiated with *[ring1, ring2, ring3], label and precision. The circle is positioned at the polygram's .pole attribute's position. The code uses those variables.

To get the LLM to code exactly as in the example, the prompt must specify everything precisely, so the LLM codes them step by step. So the prompt must specify that there are three rings with their exact coordinates. Since the user provided coordinates in the code, the prompt must include each ring's coordinates as lists. Otherwise, the LLM will choose other coordinates.

But maybe the coordinates can be omitted, and the LLM can assume some example coordinates, but to get the exact code, the coordinates must be included in the prompt. But the user's example has those numbers, so the prompt must list each ring's points.

Wait the user might consider the actual coordinate lists as part of visual details. The problem says ""details such as visual elements... do not output anything else"", so the prompt should include those coordinate points.

Therefore, the needed prompt must exactly describe each step of the code: the variables defined as the coordinate lists for each ring, creating Polygons for each with the given coordinates, their colors, creating the labeled Polygram, etc.

So, rephrasing the entire code into natural language instructions:

""Create a Manim Python class named LabeledPolygramExample inheriting from Scene. In the construct function:

- Define three lists of 2D coordinates for three polygon rings. The first ring has vertices at:

   ring1 = [ [-3.8, -2.4], [-2.4, -2.5], ... ( list all ring1 points)

   Similarly for ring2 and ring3. The code's ring1 has 20 points, so the prompt would list each of three ring's coordinates precisely as they're in the code.

Wait but maybe the specific coordinates aren't the key part of the prompt. Alternatively, perhaps they're just variables and the LLM will name them as such. The problem might prioritize the structural elements and the elements' characteristics.

Alternatively, maybe the prompt is about creating a scene with three layered polygons, first semi-transparent, then two blacked filled, with the labeled polygram and circle. So perhaps the user expects the prompt like:

""Write a Manim scene that constructs a labeled polygram composed of three concentric polygonal rings. The outer ring has vertices forming an irregular shape with a certain number of points, the inner rings having progressively smaller ones. The outer polygon is light-colored with 75% opacity, the inner two are opaque black. Place these polygons on the screen, add a labeled pole at their center point with the text 'Pole', and overlay a white circle that uses the polygram's radius and center. The code should define the vertex coordinates for each polygon as given, form them into Polygons with their fill properties, make a LabeledPolygram with the rings and label, and position the circle precisely via the polygram’s properties.""

But the exact code's coordinates are crucial for the Polygons' shapes, so the prompt must list all the coordinate lists for rings. Without that, the LLM can't generate the exact code. The user might expect the assistant to phrase the prompt instruction precisely enough.

Alternatively, perhaps the code is correct but the problem requires a succinct prompt without all the coordinates. But the manim code requires the coordinates as provided, so the prompt must instruct to use those. Since it's impossible to avoid coordinates, but in an actual scenario, the user might describe the scene by saying there are an outer ring of x vertices, middle ring z, and inner, etc. But given the code uses coordinates, the prompt must include them to ensure they’re used. Without that, the LLM won't know.

Alternatively, the user might accept the prompt as just describing the structure and visual aspects. So the final prompt might say:

""Design a static Manim animation scene that draws three polygon rings forming a labeled figure. An outer ring with multiple vertices (around 20 points arranged in an irregular polygon), and two smaller inner filled-black polygons (with 8 and 4 points respectively), forming a central triangle). The LabeledPolygram combines these rings with a 'Pole' label at the center. Add a white circle centered at the label's position with the same radius as the outermost ring.

Provide the code including the coordinate lists for each ring, the Polygon fill settings, and the LabeledPolygram setup, and the circle at the appropriate position.""

Hmm, but without the coordinates' exact points, the code would vary.

Wait, perhaps the actual coordinate lists are just example coordinates and the key details are the structure. Maybe the user considers the coordinates as just example data. Since the problem's instruction says the prompt should describe the elements without outputting code, but including the details of the visual.

Therefore, the correct prompt might look like this:

""Create a Manim animation class called LabeledPolygramExample. The scene must display:

1. The first polygon (filled with partial transparency) shaped by a set of 20 vertices forming an elongated shape around the center.

2. Two inner polygons filled with black: one with 8 points and another smaller with 4 points, which create a central hole.

3. A LabeledPolygram object using those rings, adding a central white label 'Pole', then a white circle centered at that pole position with radius matching the LabeledPolygram's.""

But the code requires defining those coordinate arrays. Maybe the key point is stating that the outer ring has the list ring1, second ringring2, third ring3, but the user's desired prompt would need to instruct the LLM to create those coordinates. Since the user's code's construct includes each list of coordinates, the prompt must describe each list's purpose.

Alternatively, given the code's structure, the prompt could be:

""Develop a Manim code to create a Scene where a labeled polygram is displayed. The polygram consists of three polygon rings. The outer ring uses these coordinates: list of ring1's points. The inner rings use ring2 and ring3's points. The first is semi-transparent, the inner two are black. The LabeledPolygram is to use these lists, and a circle centered at pole with the radius.""

But writing this prompt would require specifying all coordinates, which seems tedious but necessary for the code.

Given the problem states ""keep details such as visual elements, their movements and transformation..."", and the movements/trans are N/A here, movement is none, so it's a stationary scene. The elements are all the polygons and the circle.

Putting this all together into a clear, concise prompt:

""Write Python code using Manim library to create a static scene (no animations) showing a labeled polygram as follows:

- The first polygon has vertices at [(each ring1's list coordinates), omit Z? since the code uses 0,Z-coordinate].

Wait perhaps it's better to write the prompt step-by-step:

The prompt would ask something like:

""Create a Manim Scene to display a complex polygon figure. The figure consists of three polygon layers. The first layer is an outer ring defined by twenty vertices arranged in a specific pattern, creating a 3D polygon (maybe the z=0).0). The second is an inner ring with eight vertices, and a third with four vertices, all these coordinates given. The outer is partially filled, the inner two are black filled. A white label 'Pole' is placed at the central point of these shapes, and the circle around it.""

Wait, perhaps the best approach is to describe the entire setup in natural language, listing all coordinates where needed, but without code syntax.

Wait the coordinates are for ring1 are:

The first list starts at (-3.8, -2.4), 0), etc. But in the prompt, I have to describe them as vertices lists for each polygon.

The prompt can be structured as:

""Design a Manim animation scene (without any movement) where three polygon rings are drawn. The first outer ring has coordinates: list each of the points of ring1 (exactly as in the code's lists). For example, start by listing the ring1's coordinates, then the next. Then, form polygons from these lists. The second and third as inner rings.""

Wait but writing that into a prompt? That could be very long. Alternatively, the prompt can describe each polygon as follows, but list each point precisely.

But the user's example code uses lists of coordinates, so the prompt might instruct:

""Create a Manim scene where three polygon rings are defined by the following coordinates:

- Ring1: [ [-3.8, ... (all the ring1 points) ]

- Ring2: [ ring2 coordinates ] 

- Ring3 ... 

The outer ring is drawn with fill opacity 75%, and the middle and inner ones filled black.

Also create a LabeledPolygram object using the three rings, with the text 'Pole', and add a circle whose center is polygram.pole and radius polygram.radius. 

Wait perhaps that’s the most precise way.

Alternatively, the prompt could be structured like this:

""Using Manim's Polygon objects, create a static animation scene that has three rings made of connected vertices. Specify the code to include:

- Define three groups of points (coordinates) stored as variables ring1, ring2, ring3.

Ring1 is a list of 20 vertices forming a star-like shape.

Ring2 has 8 vertices forming an inner loop.

Ring3 has 4 points.

Then, create three Polygon objects for each ring with respective fill properties: first (translucent), others solid black.

Add a LabeledPolygram using all three rings w"
"from manim import *

import requests
import json

class LabeledCountryExample(Scene):
    def construct(self):
        # Fetch JSON data and process arcs
        data = requests.get('https://cdn.jsdelivr.net/npm/us-atlas@3/nation-10m.json').json()
        arcs, transform = data['arcs'], data['transform']
        sarcs = [np.cumsum(arc, axis=0) * transform['scale'] + transform['translate'] for arc in arcs]
        ssarcs = sorted(sarcs, key=len, reverse=True)[:1]

        # Compute Bounding Box
        points = np.concatenate(ssarcs)
        mins, maxs = np.min(points, axis=0), np.max(points, axis=0)

        # Build Axes
        ax = Axes(
            x_range=[mins[0], maxs[0], maxs[0] - mins[0]], x_length=10,
            y_range=[mins[1], maxs[1], maxs[1] - mins[1]], y_length=7,
            tips=False
        )

        # Adjust Coordinates
        array = [[ax.c2p(*point) for point in sarc] for sarc in ssarcs]

        # Add Polygram
        polygram = LabeledPolygram(
            *array,
            label=Text('USA', font='sans-serif'),
            precision=0.01,
            fill_color=BLUE,
            stroke_width=0,
            fill_opacity=0.75
        )

        # Display Circle (for reference)
        circle = Circle(radius=polygram.radius, color=WHITE).move_to(polygram.pole)

        self.add(ax)
        self.add(polygram)
        self.add(circle)","Create a Manim animation scene that displays a labeled USA shape with reference components. Requirements:  
1. Fetch nation geometry data from https://cdn.jsdelivr.net/npm/us-atlas@3/nation-10m.json  
2. Process the top longest arc path using scale/translation from the JSON data's transform properties  
3. Create a custom coordinate system (Axes) matching the shape's bounding box dimensions  
4. Display the processed path as a filled polygon with:  
   - Blue color and 75% opacity  
   - Centered ""USA"" text label (sans-serif font)  
   - Use LabeledPolygram mobject for shape and label integration  
5. Add a white reference circle showing the polygon's circumradius and center point  
6. Ensure the axes automatically adjust to the shape's coordinate range  
7. Maintain aspect ratio with x_length=10 and y_length=7 units  
8. Animation should display all elements simultaneously (no animations, just scene composition)"
"from manim import *

class RightArcAngleExample(Scene):
    def construct(self):
        line1 = Line( LEFT, RIGHT )
        line2 = Line( DOWN, UP )
        rightarcangles = [
            Angle(line1, line2, dot=True),
            Angle(line1, line2, radius=0.4, quadrant=(1,-1), dot=True, other_angle=True),
            Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, dot=True, dot_color=YELLOW, dot_radius=0.04, other_angle=True),
            Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, dot=True, dot_color=GREEN, dot_radius=0.08),
        ]
        plots = VGroup()
        for angle in rightarcangles:
            plot=VGroup(line1.copy(),line2.copy(), angle)
            plots.add(plot)
        plots.arrange(buff=1.5)
        self.add(plots)","Create a Manim Scene that demonstrates multiple angle representations between two intersecting lines (horizontal and vertical) using different parameter configurations. The animation should show four distinct angle diagrams arranged horizontally with spacing between them. Each diagram must include: 1) A default angle with a dot, 2) an angle of radius 0.4 with quadrant (1, -1), other_angle=True, and a dot, 3) an angle with radius 0.5, quadrant (-1,1), stroke_width 8, yellow dot (radius 0.04), other_angle=True, 4) an angle with radius 0.7, quadrant (-1,-1), red color, green dot (radius 0.08), and a dot. Ensure each configuration uses copies of the lines and includes all specified styling parameters."
"from manim import *

class AngleExample(Scene):
    def construct(self):
        line1 = Line( LEFT + (1/3) * UP, RIGHT + (1/3) * DOWN )
        line2 = Line( DOWN + (1/3) * RIGHT, UP + (1/3) * LEFT )
        angles = [
            Angle(line1, line2),
            Angle(line1, line2, radius=0.4, quadrant=(1,-1), other_angle=True),
            Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, other_angle=True),
            Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED),
            Angle(line1, line2, other_angle=True),
            Angle(line1, line2, radius=0.4, quadrant=(1,-1)),
            Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8),
            Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, other_angle=True),
        ]
        plots = VGroup()
        for angle in angles:
            plot=VGroup(line1.copy(),line2.copy(), angle)
            plots.add(VGroup(plot,SurroundingRectangle(plot, buff=0.3)))
        plots.arrange_in_grid(rows=2,buff=1)
        self.add(plots)","Create an animation in Manim showing multiple angle examples between two lines, arranged in a 2-row grid. Each cell must display two intersecting lines forming an angle, with angle markers having varying styles: different radius values (0.4, 0.5, 0.7), different quadrant positions (e.g., (1, -1), (-1,1)), colors like red, stroke widths (e.g., 8), and ""other_angle"" toggled to show both the primary and secondary angles. Each example must be enclosed in a framed box to distinguish configurations, and all must be spaced evenly in a 2-row layout."
"from manim import *

class FilledAngle(Scene):
    def construct(self):
        l1 = Line(ORIGIN, 2 * UP + RIGHT).set_color(GREEN)
        l2 = (
            Line(ORIGIN, 2 * UP + RIGHT)
            .set_color(GREEN)
            .rotate(-20 * DEGREES, about_point=ORIGIN)
        )
        norm = l1.get_length()
        a1 = Angle(l1, l2, other_angle=True, radius=norm - 0.5).set_color(GREEN)
        a2 = Angle(l1, l2, other_angle=True, radius=norm).set_color(GREEN)
        q1 = a1.points #  save all coordinates of points of angle a1
        q2 = a2.reverse_direction().points  #  save all coordinates of points of angle a1 (in reversed direction)
        pnts = np.concatenate([q1, q2, q1[0].reshape(1, 3)])  # adds points and ensures that path starts and ends at same point
        mfill = VMobject().set_color(ORANGE)
        mfill.set_points_as_corners(pnts).set_fill(GREEN, opacity=1)
        self.add(l1, l2)
        self.add(mfill)",Write a Manim script that creates a scene with two green lines starting at the origin forming a 20° angle. The first line points to the coordinates (RIGHT + 2*UP. The second line is a copy rotated -20° around the start point. Display between them two angle arcs: one with a radius 0.5 units shorter than the line length and another at full length. Use the arcs' points (reverse one arc) to form a closed filled region between them. Fill this shape solid green. The scene should show the lines and filled angle-sector simultaneously.
"from manim import *

class AngleFromThreePointsExample(Scene):
    def construct(self):
        sample_angle = Angle.from_three_points(UP, ORIGIN, LEFT)
        red_angle = Angle.from_three_points(LEFT + UP, ORIGIN, RIGHT, radius=.8, quadrant=(-1,-1), color=RED, stroke_width=8, other_angle=True)
        self.add(red_angle, sample_angle)","Design a Manim scene showing two angles created with `Angle.from_three_points`. The first angle connects points A (UP), vertex at ORIGIN, and point C (LEFT) with default parameters. The second angle connects points D (LEFT + UP), vertex at ORIGIN, and point B (RIGHT), with: red color, radius 0.8, stroke width 8, quadrant set to (-1, -1), and `other_angle=True` to draw the larger arc. Both angles must be displayed simultaneously by layering them in the scene."
"from manim import *

class GetValueExample(Scene):
    def construct(self):
        line1 = Line(LEFT+(1/3)*UP, RIGHT+(1/3)*DOWN)
        line2 = Line(DOWN+(1/3)*RIGHT, UP+(1/3)*LEFT)

        angle = Angle(line1, line2, radius=0.4)

        value = DecimalNumber(angle.get_value(degrees=True), unit=r""^{\circ}"")
        value.next_to(angle, UR)

        self.add(line1, line2, angle, value)","""Create an animation using Manim that displays two lines intersecting each other. The first line should start at the left edge shifted slightly upward and end at the right edge shifted slightly downward. The second line should start at the bottom center shifted to the right and end at the top center shifted to the left. Draw an angle marker between these two lines with a small radius. Position a numerical value next to the angle marker, showing the angle's measure in degrees (e.g., ""45°""), formatted to update based on the angle between the lines. The scene should be static with all elements displayed simultaneously."""
"from manim import *

from manim.mobject.geometry.tips import ArrowSquareTip
class ArrowExample(Scene):
    def construct(self):
        arrow_1 = Arrow(start=RIGHT, end=LEFT, color=GOLD)
        arrow_2 = Arrow(start=RIGHT, end=LEFT, color=GOLD, tip_shape=ArrowSquareTip).shift(DOWN)
        g1 = Group(arrow_1, arrow_2)

        # the effect of buff
        square = Square(color=MAROON_A)
        arrow_3 = Arrow(start=LEFT, end=RIGHT)
        arrow_4 = Arrow(start=LEFT, end=RIGHT, buff=0).next_to(arrow_1, UP)
        g2 = Group(arrow_3, arrow_4, square)

        # a shorter arrow has a shorter tip and smaller stroke width
        arrow_5 = Arrow(start=ORIGIN, end=config.top).shift(LEFT * 4)
        arrow_6 = Arrow(start=config.top + DOWN, end=config.top).shift(LEFT * 3)
        g3 = Group(arrow_5, arrow_6)

        self.add(Group(g1, g2, g3).arrange(buff=2))","Create a Manim animation scene demonstrating arrow configurations and parameters. The scene should display three horizontally arranged main groups with 2 units spacing:  

**First group (left):**  
- Two gold arrows pointing left (RIGHT→LEFT direction). The second arrow uses a square tip (ArrowSquareTip) and is positioned directly below the first one.  

**Second group (middle):**  
- Two side-by-side arrows pointing right (LEFT→RIGHT direction). The first uses default parameters. The second arrow has `buff=0` and is placed above the first arrow of the first group. A maroon square is positioned adjacent to them to highlight the `buff` parameter's effect on spacing.  

**Third group (right):**  
- Two upward-pointing arrows shifted left. The first spans from the origin to the screen’s top edge (vertical) and is shifted 4 units left. The second is shorter (starting just below the top edge and ending at the top edge) and shifted 3 units left, illustrating how shorter arrows have smaller tips and thinner strokes.  

All groups should be combined into one arrangement with horizontal spacing via `arrange(buff=2)`. Use the `ArrowSquareTip` class for the second arrow in the first group. Ensure proper `buff` usage in the second group and display tip/stroke differences in the third group."
"from manim import *

class ArrowExample(Scene):
    def construct(self):
        left_group = VGroup()
        # As buff increases, the size of the arrow decreases.
        for buff in np.arange(0, 2.2, 0.45):
            left_group += Arrow(buff=buff, start=2 * LEFT, end=2 * RIGHT)
        # Required to arrange arrows.
        left_group.arrange(DOWN)
        left_group.move_to(4 * LEFT)

        middle_group = VGroup()
        # As max_stroke_width_to_length_ratio gets bigger,
        # the width of stroke increases.
        for i in np.arange(0, 5, 0.5):
            middle_group += Arrow(max_stroke_width_to_length_ratio=i)
        middle_group.arrange(DOWN)

        UR_group = VGroup()
        # As max_tip_length_to_length_ratio increases,
        # the length of the tip increases.
        for i in np.arange(0, 0.3, 0.1):
            UR_group += Arrow(max_tip_length_to_length_ratio=i)
        UR_group.arrange(DOWN)
        UR_group.move_to(4 * RIGHT + 2 * UP)

        DR_group = VGroup()
        DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareTip)
        DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareFilledTip)
        DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleTip)
        DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleFilledTip)
        DR_group.arrange(DOWN)
        DR_group.move_to(4 * RIGHT + 2 * DOWN)

        self.add(left_group, middle_group, UR_group, DR_group)","""Create a Manim animation scene demonstrating arrow customization. The scene should include four groups of arrows arranged as follows:

1. **Left Side (aligned vertically on left):**
   - Arrows with start at 2*LEFT and end at 2*RIGHT.
   - Vary `buff` values from 0 to 2.2 in increments of ~0.45, positioned vertically.
   - Show that increasing `buff` reduces arrow body size.

2. **Center (vertically arranged in middle):**
   - Arrows with varying `max_stroke_width_to_length_ratio` from 0 to 5 in 0.5 increments.
   - Illustrate that higher values increase stroke width.

3. **Upper Right:**
   - Arrows arranged downward, starting at top-right (4*RIGHT + 2*UP).
   - Adjust `max_tip_length_to_length_ratio` from 0 to 0.3 in 0.1 increments.
   - Demonstrate tip length increases with parameter.

4. **Lower Right:**
   - Four horizontally same-width arrows, arranged vertically (4*RIGHT + 2*DOWN):
      a. Blue arrow with square tip (unfilled)
      b. Blue arrow with filled square tip
      c. Yellow arrow with circle tip (unfilled)
      d. Yellow arrow with filled circle tip
   - Use tip shapes: ArrowSquareTip, ArrowSquareFilledTip, ArrowCircleTip, ArrowCircleFilledTip.

All groups must be added to the scene to display simultaneously. Ensure correct positioning and parameter behaviors are visually clear through their arrangements."""
"from manim import *

class DashedLineExample(Scene):
    def construct(self):
        # dash_length increased
        dashed_1 = DashedLine(config.left_side, config.right_side, dash_length=2.0).shift(UP*2)
        # normal
        dashed_2 = DashedLine(config.left_side, config.right_side)
        # dashed_ratio decreased
        dashed_3 = DashedLine(config.left_side, config.right_side, dashed_ratio=0.1).shift(DOWN*2)
        self.add(dashed_1, dashed_2, dashed_3)","Create a Manim animation scene that displays three horizontal dashed lines across the screen. Position each line vertically: the top line shifted 2 units up, the middle line centered, and the bottom line shifted 2 units down. Adjust the top line with increased dash length (dash_length=2.0), the bottom line with reduced dashed ratio (dashed_ratio=0.1), and leave the middle line with default parameters. Ensure all lines span from the left to right edge of the frame."
"from manim import *

from manim.mobject.geometry.tips import ArrowCircleFilledTip
class DoubleArrowExample(Scene):
    def construct(self):
        circle = Circle(radius=2.0)
        d_arrow = DoubleArrow(start=circle.get_left(), end=circle.get_right())
        d_arrow_2 = DoubleArrow(tip_shape_end=ArrowCircleFilledTip, tip_shape_start=ArrowCircleFilledTip)
        group = Group(Group(circle, d_arrow), d_arrow_2).arrange(UP, buff=1)
        self.add(group)","Create a Manim animation scene that includes the following visual elements and arrangement:  
1. A circle with a radius of 2.0 units.  
2. A double arrow (`DoubleArrow`) spanning from the left edge to the right edge of the circle.  
3. A second double arrow (`DoubleArrow`) where **both** its start and end tips are replaced with filled circle tips (`ArrowCircleFilledTip`).  
4. The circle and the first double arrow must be grouped together and positioned below the second double arrow, with a vertical spacing (`buff=1`) between them.  

The scene should arrange these elements such that the grouped circle + first arrow and the second arrow are stacked vertically. Define the scene class `DoubleArrowExample` to accomplish this setup using Manim's `Group`, `arrange`, and appropriate tip configuration."
"from manim import *

class DoubleArrowExample2(Scene):
    def construct(self):
        box = Square()
        p1 = box.get_left()
        p2 = box.get_right()
        d1 = DoubleArrow(p1, p2, buff=0)
        d2 = DoubleArrow(p1, p2, buff=0, tip_length=0.2, color=YELLOW)
        d3 = DoubleArrow(p1, p2, buff=0, tip_length=0.4, color=BLUE)
        Group(d1, d2, d3).arrange(DOWN)
        self.add(box, d1, d2, d3)","""Pretend you are a Manim developer creating an animation scene. Generate Python code for a Manim Scene class (DoubleArrowExample2) that shows a square with three vertical double arrows stacked below it. The first arrow (d1) should be in default color, the second (d2) yellow with tip_length 0.2, and the third (d3) blue with tip_length 0.4. All arrows must span between the left and right edges of the square, with no buffer (buff=0). Arrange the arrows vertically with spacing using Group.arrange(DOWN). Include all necessary imports and scene setup for immediate execution.""

This prompt explicitly requests the following visual elements and behaviors:
- Square as central reference object
- Three DoubleArrow objects with specific color and tip_length parameters
- Buff=0 parameter for arrow positioning relative to square
- Vertical arrangement using Group.arrange(DOWN)
- Complete code structure with proper inheritance and method implementation
- Clear indication of object hierarchy via self.add() statements"
"from manim import *

class ElbowExample(Scene):
    def construct(self):
        elbow_1 = Elbow()
        elbow_2 = Elbow(width=2.0)
        elbow_3 = Elbow(width=2.0, angle=5*PI/4)

        elbow_group = Group(elbow_1, elbow_2, elbow_3).arrange(buff=1)
        self.add(elbow_group)",Create a Manim Python code for an animation scene that displays three Elbow objects. The first Elbow should use default settings. The second Elbow must have a width of 2.0. The third Elbow needs to have a width of 2.0 and an angle of 5*PI/4 radians (225 degrees). Arrange these three Elbow objects in a group with each element spaced 1 unit apart from each other. The scene should simply show the three arranged Elbow shapes without any further animations or transformations.
"from manim import *

class LineExample(Scene):
    def construct(self):
        d = VGroup()
        for i in range(0,10):
            d.add(Dot())
        d.arrange_in_grid(buff=1)
        self.add(d)
        l= Line(d[0], d[1])
        self.add(l)
        self.wait()
        l.put_start_and_end_on(d[1].get_center(), d[2].get_center())
        self.wait()
        l.put_start_and_end_on(d[4].get_center(), d[7].get_center())
        self.wait()","Create an animation showing a grid of 10 dots arranged with spacing between each. First, display a line connecting the first and second dot. After a brief pause, quickly change the line to connect the second and third dot instead. After another short pause, abruptly transform the line to connect the fourth and seventh dots in the grid layout. Each line transition occurs after a visible pause, highlighting each segment."
"from manim import *

class RightAngleExample(Scene):
    def construct(self):
        line1 = Line( LEFT, RIGHT )
        line2 = Line( DOWN, UP )
        rightangles = [
            RightAngle(line1, line2),
            RightAngle(line1, line2, length=0.4, quadrant=(1,-1)),
            RightAngle(line1, line2, length=0.5, quadrant=(-1,1), stroke_width=8),
            RightAngle(line1, line2, length=0.7, quadrant=(-1,-1), color=RED),
        ]
        plots = VGroup()
        for rightangle in rightangles:
            plot=VGroup(line1.copy(),line2.copy(), rightangle)
            plots.add(plot)
        plots.arrange(buff=1.5)
        self.add(plots)","Create a Manim animation scene demonstrating different configurations of right angles formed between two perpendicular lines. The scene should: 1. Display four variations of right angle markers between a horizontal line (left to right) and vertical line (down to up), arranged side-by-side with spacing. 2. First variation shows default right angle marker. Second uses 0.4 unit length with quadrant (1,-1). Third has 0.5 unit length, quadrant (-1,1), and thicker stroke. Fourth uses 0.7 unit length, quadrant (-1,-1), and red color. 3. Each combination of lines and right angle marker should be grouped together and arranged horizontally with 1.5 units of buffer between groups."
"from manim import *

class TangentLineExample(Scene):
    def construct(self):
        circle = Circle(radius=2)
        line_1 = TangentLine(circle, alpha=0.0, length=4, color=BLUE_D) # right
        line_2 = TangentLine(circle, alpha=0.4, length=4, color=GREEN) # top left
        self.add(circle, line_1, line_2)","Write a Python class using the Manim library to create an animation scene showing a circle and two tangent lines. The scene should display:  
1. A circle with a radius of 2 units.  
2. A blue tangent line (BLUE_D color) at the rightmost point (alpha=0.0) of the circle, with length 4 units.  
3. A green tangent line (GREEN color) at an alpha value of 0.4 (positioned ~top-left) of the circle, with length 4 units.  
Include the complete code structure with proper imports and a Scene subclass to render these elements together on the screen."
"from manim import *

class VectorExample(Scene):
    def construct(self):
        plane = NumberPlane()
        vector_1 = Vector([1,2])
        vector_2 = Vector([-5,-2])
        self.add(plane, vector_1, vector_2)","Create a Manim Python code animation scene that displays a number plane (coordinate system) with two vectors. The first vector must originate from the origin (0,0) and point directly to the coordinate (1, 2). The second vector should also start at the origin and point to the coordinates (-5, -2. The scene should show both vectors and the number plane simultaneously without any movement, transformations, or animations—only their static initial positions."
"from manim import *

class VectorCoordinateLabel(Scene):
    def construct(self):
        plane = NumberPlane()

        vec_1 = Vector([1, 2])
        vec_2 = Vector([-3, -2])
        label_1 = vec_1.coordinate_label()
        label_2 = vec_2.coordinate_label(color=YELLOW)

        self.add(plane, vec_1, vec_2, label_1, label_2)","""Create a Manim animation scene showing a NumberPlane with two Vectors displayed: one starting at the origin pointing to (1, 2) with its coordinate label, and another starting at the origin pointing to (-3, -2) with its coordinate label colored yellow. All elements should appear simultaneously on the screen without any movement or animation transitions."""
"from manim import *

class ConvexHullExample(Scene):
    def construct(self):
        points = [
            [-2.35, -2.25, 0],
            [1.65, -2.25, 0],
            [2.65, -0.25, 0],
            [1.65, 1.75, 0],
            [-0.35, 2.75, 0],
            [-2.35, 0.75, 0],
            [-0.35, -1.25, 0],
            [0.65, -0.25, 0],
            [-1.35, 0.25, 0],
            [0.15, 0.75, 0]
        ]
        hull = ConvexHull(*points, color=BLUE)
        dots = VGroup(*[Dot(point) for point in points])
        self.add(hull)
        self.add(dots)","Create a Manim animation scene showing 10 dots arranged in specific positions on a 2D plane. Simultaneously display a blue convex hull polygon that fully encloses these points. The dots should remain stationary and the convex hull outline must be fixed, with all elements appearing together without any movement, fading, or transformation effects. The scene should include precise positioning of the dots with coordinates that create a clear convex hull geometry when connected."
"from manim import *

class CutoutExample(Scene):
    def construct(self):
        s1 = Square().scale(2.5)
        s2 = Triangle().shift(DOWN + RIGHT).scale(0.5)
        s3 = Square().shift(UP + RIGHT).scale(0.5)
        s4 = RegularPolygon(5).shift(DOWN + LEFT).scale(0.5)
        s5 = RegularPolygon(6).shift(UP + LEFT).scale(0.5)
        c = Cutout(s1, s2, s3, s4, s5, fill_opacity=1, color=BLUE, stroke_color=RED)
        self.play(Write(c), run_time=4)
        self.wait()","Create a Manim animation scene named `CutoutExample` with the following steps: Start with a large square (scaled to 2.5x size) at the center. Add a smaller triangle (0.5x scale) shifted to DOWN + RIGHT, a small square (0.5x) shifted to UP + RIGHT, a 5-sided polygon (0.5x) shifted to DOWN + LEFT, and a 6-sided polygon (0.5x) shifted to UP + LEFT. Combine all these shapes into a single `Cutout` object with blue fill (fill_opacity=1) and red outline. Animate the `Cutout` using `Write` animation over 4 seconds, then pause briefly. Fully define all object positions, scales, and styling parameters in the code."
"from manim import *

class PolygonExample(Scene):
    def construct(self):
        isosceles = Polygon([-5, 1.5, 0], [-2, 1.5, 0], [-3.5, -2, 0])
        position_list = [
            [4, 1, 0],  # middle right
            [4, -2.5, 0],  # bottom right
            [0, -2.5, 0],  # bottom left
            [0, 3, 0],  # top left
            [2, 1, 0],  # middle
            [4, 3, 0],  # top right
        ]
        square_and_triangles = Polygon(*position_list, color=PURPLE_B)
        self.add(isosceles, square_and_triangles)","Write a Python script using Manim library to create an animation scene that displays two geometric figures. The first figure is an isosceles triangle defined by the points (-5, 1.5), (-2, 1.5), and (-3.5, -2). The second figure is a hexagon/polygon with vertices at (4, 1), (4, -2.5), (0, -2.5), (0, 3), (2, 1), and (4, 3), colored in PURPLE_B. Both shapes should be present on the screen simultaneously without any animations or transformations."
"from manim import *

import numpy as np

class PolygramExample(Scene):
    def construct(self):
        hexagram = Polygram(
            [[0, 2, 0], [-np.sqrt(3), -1, 0], [np.sqrt(3), -1, 0]],
            [[-np.sqrt(3), 1, 0], [0, -2, 0], [np.sqrt(3), 1, 0]],
        )
        self.add(hexagram)

        dot = Dot()
        self.play(MoveAlongPath(dot, hexagram), run_time=5, rate_func=linear)
        self.remove(dot)
        self.wait()","Create a Manim animation where the scene begins by displaying a six-pointed star (hexagram) formed from two overlapping triangles. The first triangle has vertices at coordinates (0, 2, 0), (-√3, -1, 0), and (√3, -1, 0). The second triangle has vertices at (-√3, 1, 0), (0, -2, 0), and (√3, 1, 0. An orange dot then appears and moves precisely along the full perimeter of the hexagram’s outline at a constant speed, taking exactly 5 seconds to complete the loop. After finishing its path, the dot abruptly disappears from the screen, leaving only the hexagram visible. The scene pauses briefly before ending. Use coordinates defined with numpy.sqrt, and ensure the hexagram is created using the Polygram class with the provided vertex lists as separate polygons."
"from manim import *

class PolygramRoundCorners(Scene):
    def construct(self):
        star = Star(outer_radius=2)

        shapes = VGroup(star)
        shapes.add(star.copy().round_corners(radius=0.1))
        shapes.add(star.copy().round_corners(radius=0.25))

        shapes.arrange(RIGHT)
        self.add(shapes)","Create a Manim animation scene where three versions of a star are displayed horizontally side by side. The first version is a sharp-pointed regular star with an outer radius of 2. The second and third stars should be copies of the first, each modified to have their corners rounded with radii of 0.1 and 0.25 respectively. Arrange them from left to right to progressively show the increase in corner roundness."
"from manim import *

class RectangleExample(Scene):
    def construct(self):
        rect1 = Rectangle(width=4.0, height=2.0, grid_xstep=1.0, grid_ystep=0.5)
        rect2 = Rectangle(width=1.0, height=4.0)
        rect3 = Rectangle(width=2.0, height=2.0, grid_xstep=1.0, grid_ystep=1.0)
        rect3.grid_lines.set_stroke(width=1)

        rects = Group(rect1, rect2, rect3).arrange(buff=1)
        self.add(rects)","Design a Manim scene where three rectangles are arranged horizontally with spacing between them. The first rectangle has a width of 4 and height of 2 units, with vertical grid lines every 1 unit and horizontal grid lines every 0.5 units. The second rectangle has a width of 1 and height of 4 units with no grid lines. The third rectangle has a width and height of 2 units each, with grid lines every 1 unit in both directions and the grid lines have a stroke width of 1. The three rectangles should be displayed as a grouped arrangement with space between them."
"from manim import *

class RegularPolygonExample(Scene):
    def construct(self):
        poly_1 = RegularPolygon(n=6)
        poly_2 = RegularPolygon(n=6, start_angle=30*DEGREES, color=GREEN)
        poly_3 = RegularPolygon(n=10, color=RED)

        poly_group = Group(poly_1, poly_2, poly_3).scale(1.5).arrange(buff=1)
        self.add(poly_group)",Create a Manim animation scene showing three regular polygons arranged horizontally. The first polygon is a 6-sided hexagon in the default color. The second is also a 6-sided polygon but rotated 30 degrees and colored green. The third is a 10-sided polygon in red. All shapes should be scaled to 1.5x their original size and evenly spaced with gaps between them. No movement or transformations occur beyond their initial arrangement.
"from manim import *

class RegularPolygramExample(Scene):
    def construct(self):
        pentagram = RegularPolygram(5, radius=2)
        self.add(pentagram)","""Design a Manim animation scene called RegularPolygramExample that displays a static 5-pointed star (pentagram) with a radius of exactly 2 units. Ensure the star is created using Manim's RegularPolygram class with no motion, rotation, color changes, or transformations. The pentagram should simply appear centered on the screen and stay stationary. Include all necessary imports and structure the code using a self-contained Scene subclass."""
"from manim import *

class RoundedRectangleExample(Scene):
    def construct(self):
        rect_1 = RoundedRectangle(corner_radius=0.5)
        rect_2 = RoundedRectangle(corner_radius=1.5, height=4.0, width=4.0)

        rect_group = Group(rect_1, rect_2).arrange(buff=1)
        self.add(rect_group)",Create a Manim animation scene showing two rounded rectangles. The first rounded rectangle has smaller rounded corners (corner radius 0.5). The second rounded rectangle has significantly larger rounded corners (corner radius 1.5) and is much bigger in size (4 units height and width). Position both shapes side by side with a small gap between them.
"from manim import *

class SquareExample(Scene):
    def construct(self):
        square_1 = Square(side_length=2.0).shift(DOWN)
        square_2 = Square(side_length=1.0).next_to(square_1, direction=UP)
        square_3 = Square(side_length=0.5).next_to(square_2, direction=UP)
        self.add(square_1, square_2, square_3)","Create a Manim animation that displays three squares stacked vertically in decreasing size. The first square (side length 2.0) is positioned at the bottom, shifted down from the center. The second smaller square (side length 1.0) is placed directly above the first, centered with it. The third smallest square (side length 0.5) is placed directly above the second, maintaining alignment with the squares below. No motion or transformations should occur—only their initial static arrangement on the screen."
"from manim import *

class StarExample(Scene):
    def construct(self):
        pentagram = RegularPolygram(5, radius=2)
        star = Star(outer_radius=2, color=RED)

        self.add(pentagram)
        self.play(Create(star), run_time=3)
        self.play(FadeOut(star), run_time=2)","Create a Manim animation scene where a regular pentagram (5-pointed star with radius 2 units) is displayed initially. Then, a red-colored star with an outer radius of 2 units should be animated to appear using a 3-second ""Create"" animation. After that, the red star should fade out over 2 seconds while the pentagram remains visible on the screen throughout the entire duration of the scene."
"from manim import *

class DifferentDensitiesExample(Scene):
    def construct(self):
        density_2 = Star(7, outer_radius=2, density=2, color=RED)
        density_3 = Star(7, outer_radius=2, density=3, color=PURPLE)

        self.add(VGroup(density_2, density_3).arrange(RIGHT))","Create a Manim animation scene showing two 7-pointed star shapes arranged side by side. The first star should have a red color and a density value of 2, while the second star should be purple with a density value of 3. Both stars must have the same outer radius of 2 units. The stars should be displayed statically arranged from left to right with spacing between them. Highlight the differences in their star point arrangements caused by the density parameter variation."
"from manim import *

class TriangleExample(Scene):
    def construct(self):
        triangle_1 = Triangle()
        triangle_2 = Triangle().scale(2).rotate(60*DEGREES)
        tri_group = Group(triangle_1, triangle_2).arrange(buff=1)
        self.add(tri_group)","Create a Manim animation scene that starts with two triangles. The first triangle remains at its default size, while the second triangle is scaled to twice its original size and rotated 60 degrees. Both triangles should be positioned next to each other with a gap of 1 unit between them. The scene should display this arrangement of the two triangles from the beginning."
"from manim import *

class ExampleBackgroundRectangle(Scene):
    def construct(self):
        circle = Circle().shift(LEFT)
        circle.set_stroke(color=GREEN, width=20)
        triangle = Triangle().shift(2 * RIGHT)
        triangle.set_fill(PINK, opacity=0.5)
        backgroundRectangle1 = BackgroundRectangle(circle, color=WHITE, fill_opacity=0.15)
        backgroundRectangle2 = BackgroundRectangle(triangle, color=WHITE, fill_opacity=0.15)
        self.add(backgroundRectangle1)
        self.add(backgroundRectangle2)
        self.add(circle)
        self.add(triangle)
        self.play(Rotate(backgroundRectangle1, PI / 4))
        self.play(Rotate(backgroundRectangle2, PI / 2))","Create a Manim animation scene where a green-outlined circle (stroke width 20) is positioned to the left, and a pink semi-transparent triangle (50% opacity) is placed on the far right. Both shapes should have white background rectangles with 15% fill opacity. The background rectangles must be added first, followed by the shapes. Animate the left background rectangle rotating 45 degrees (π/4 radians), and the right background rectangle rotating 90 degrees (π/2 radians)."
"from manim import *

class ExampleCross(Scene):
    def construct(self):
        cross = Cross()
        self.add(cross)","Write Manim code to create an animation scene displaying a static cross on the screen. The scene must be named ""ExampleCross"", and the cross should be added to the scene without any movement, transformations, or animation effects. The cross should remain stationary throughout the entire scene duration."
"from manim import *

class SurroundingRectExample(Scene):
    def construct(self):
        title = Title(""A Quote from Newton"")
        quote = Text(
            ""If I have seen further than others, \n""
            ""it is by standing upon the shoulders of giants."",
            color=BLUE,
        ).scale(0.75)
        box = SurroundingRectangle(quote, color=YELLOW, buff=MED_LARGE_BUFF)

        t2 = Tex(r""Hello World"").scale(1.5)
        box2 = SurroundingRectangle(t2, corner_radius=0.2)
        mobjects = VGroup(VGroup(box, quote), VGroup(t2, box2)).arrange(DOWN)
        self.add(title, mobjects)","Design a Manim scene with the following elements displayed on screen simultaneously, starting from the beginning of the scene: 

1. A title at the top centered: ""A Quote from Newton"".
   
2. Below the title, two vertically stacked components:
   - First part: The blue text ""If I have seen further than others, it is by standing upon the shoulders of giants."" scaled to 0.75x, enclosed in a yellow rectangle with padding (buffer = MED_LARGE_BUFF). 
   - Second part: A LaTeX text ""Hello World"" (scaled to 1.5x size), enclosed in a rectangle with rounded corners (corner_radius=0.2).
   
The rectangle for the first quote must be yellow, while the second rectangle only needs the corner_radius parameter specified. The two components must be grouped together (text + their respective frame) then vertically arranged with VGroup and arrange(DOWN). Use Manim's Title, Text, Tex classes, SurroundingRectangle, and VGroup for grouping. The scene should not include any transitions or motion; all elements appear as described immediately when the scene starts. The first text uses Text() class with the specified blue color, the second uses Tex() class. Both rectangles are created with SurroundingRectangle, their respective parameters, and arranged in vertical order."
"from manim import *

class UnderLine(Scene):
    def construct(self):
        man = Tex(""Manim"")  # Full Word
        ul = Underline(man)  # Underlining the word
        self.add(man, ul)","Write Manim code to create an animation scene with the following elements:  
1. Display the text ""Manim"" on the screen  
2. Add a static underline beneath the text  
3. The underline should precisely align with the width of the text  
4. Show both elements (text and underline) simultaneously without any animations, movements, or transformations  
5. Use classes进口man library's Tex and Underline objects  
6. Structure the code with a custom Scene class named UnderLine"
"from manim import *

class ArrowTipsShowcase(Scene):
    def construct(self):
        tip_names = [
            'Default (YELLOW)', 'ArrowTriangleTip', 'Default', 'ArrowSquareTip',
            'ArrowSquareFilledTip', 'ArrowCircleTip', 'ArrowCircleFilledTip', 'StealthTip'
        ]

        big_arrows = [
            Arrow(start=[-4, 3.5, 0], end=[2, 3.5, 0], color=YELLOW),
            Arrow(start=[-4, 2.5, 0], end=[2, 2.5, 0], tip_shape=ArrowTriangleTip),
            Arrow(start=[-4, 1.5, 0], end=[2, 1.5, 0]),
            Arrow(start=[-4, 0.5, 0], end=[2, 0.5, 0], tip_shape=ArrowSquareTip),

            Arrow([-4, -0.5, 0], [2, -0.5, 0], tip_shape=ArrowSquareFilledTip),
            Arrow([-4, -1.5, 0], [2, -1.5, 0], tip_shape=ArrowCircleTip),
            Arrow([-4, -2.5, 0], [2, -2.5, 0], tip_shape=ArrowCircleFilledTip),
            Arrow([-4, -3.5, 0], [2, -3.5, 0], tip_shape=StealthTip)
        ]

        small_arrows = (
            arrow.copy().scale(0.5, scale_tips=True).next_to(arrow, RIGHT) for arrow in big_arrows
        )

        labels = (
            Text(tip_names[i], font='monospace', font_size=20, color=BLUE).next_to(big_arrows[i], LEFT) for i in range(len(big_arrows))
        )

        self.add(*big_arrows, *small_arrows, *labels)","Please generate Manim Python code to create an animation scene showcasing various arrow tip styles. The scene should display eight horizontal arrows arranged in rows spaced vertically across the screen. Each row must include: 1) a large arrow starting from the left edge pointing right, with tips using the following styles in order from top to bottom: Default (colored yellow), ArrowTriangleTip, Default (non-yellow), ArrowSquareTip, ArrowSquareFilledTip, ArrowCircleTip, ArrowCircleFilledTip, StealthTip. 2) A small scaled version (50% size) of each arrow positioned to the right of its corresponding large arrow. 3) A blue monospace text label (font size 20) containing the tip's name displayed to the left of each large arrow. The arrows should be evenly spaced vertically, with their labels properly aligned and their scaled versions clearly visible beside them. The scene should be static with all elements displayed simultaneously, no animated transitions."
"from manim import *

class MovingDiGraph(Scene):
    def construct(self):
        vertices = [1, 2, 3, 4]
        edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]

        g = DiGraph(vertices, edges)

        self.add(g)
        self.play(
            g[1].animate.move_to([1, 1, 1]),
            g[2].animate.move_to([-1, 1, 2]),
            g[3].animate.move_to([1, -1, -1]),
            g[4].animate.move_to([-1, -1, 0]),
        )
        self.wait()","Create a Manim animation scene that visualizes the transformation of a directed graph (DiGraph). The scene should start with a graph containing vertices labeled 1, 2, 3, and 4, connected by directed edges: (1→2), (2→3), (3→4), (1→3), and (1→4). Initially display the graph in its default layout, then animate each vertex moving to new positions:  
- Vertex 1 moves to coordinates (1, 1, 1)  
- Vertex 2 moves to (-1, 1, 2)  
- Vertex 3 moves to (1, -1, -1)  
- Vertex 4 moves to (-1, -1, 0)  

Ensure vertices and edges are visibly repositioned as separate animated movements, maintaining edge connections during the transition. The animation should include a brief pause after the movement completes. Use Manim's DiGraph class and explicit `.animate.move_to()` calls for each vertex."
"from manim import *

class CustomDiGraph(Scene):
    def construct(self):
        vertices = [i for i in range(5)]
        edges = [
            (0, 1),
            (1, 2),
            (3, 2),
            (3, 4),
        ]

        edge_config = {
            ""stroke_width"": 2,
            ""tip_config"": {
                ""tip_shape"": ArrowSquareTip,
                ""tip_length"": 0.15,
            },
            (3, 4): {
                ""color"": RED,
                ""tip_config"": {""tip_length"": 0.25, ""tip_width"": 0.25}
            },
        }

        g = DiGraph(
            vertices,
            edges,
            labels=True,
            layout=""circular"",
            edge_config=edge_config,
        ).scale(1.4)

        self.play(Create(g))
        self.wait()","Create a Manim animation scene for a directed graph (DiGraph) with 5 nodes labeled (0 to 4) arranged in a circular layout. The graph should have directed edges between nodes as follows: 0→1, 1→2, 3←2, 3→4. The edge from node 3 to 4 must be red with a thicker arrowhead (0.25 tip length, 0.25 tip width). All other edges should use square arrowheads with a tip length of 0.15 and a stroke width of 2. The entire graph should be scaled to 1.4x its default size. Animate the graph being fully constructed on screen (edges and nodes) then briefly pause."
"from manim import *

class UndirectedMovingDiGraph(Scene):
    def construct(self):
        vertices = [i for i in range(5)]
        edges = [
            (0, 1),
            (1, 2),
            (3, 2),
            (3, 4),
        ]

        edge_config = {
            ""stroke_width"": 2,
            ""tip_config"": {""tip_length"": 0, ""tip_width"": 0},
            (3, 4): {""color"": RED},
        }

        g = DiGraph(
            vertices,
            edges,
            labels=True,
            layout=""circular"",
            edge_config=edge_config,
        ).scale(1.4)

        self.play(Create(g))
        self.wait()

        self.play(
            g[1].animate.move_to([1, 1, 1]),
            g[2].animate.move_to([-1, 1, 2]),
            g[3].animate.move_to([-1.5, -1.5, -1]),
            g[4].animate.move_to([1, -2, -1]),
        )
        self.wait()","Create a Manim animation scene that starts by showing a circular undirected graph with 5 nodes labeled 0-4. The edges connect nodes (0-1), (1-2), (3-2), and (3-4. All edges have strokes width of 2 with no arrow tips (tip length/width =0), except the edge between nodes 3 and4 which is bright red. Display the graph at 140% scale. After an initial display, the nodes 1,2,3, and4 move to their respective new positions: Node1 moves to (1,1,1), node2 repositions to (-1,1,2), node3 moves to (-1.5,-1.5,-1., node4 positions to (1,-2,-1 while node0 stays stationary. Animate the graph creation first, then transition to moving these nodes to their new coordinates while maintaining their edge connections, with short pauses between these phases."
"from manim import *

class ChangeGraphLayout(Scene):
    def construct(self):
        G = Graph([1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)],
                  layout={1: [-2, 0, 0], 2: [-1, 0, 0], 3: [0, 0, 0],
                          4: [1, 0, 0], 5: [2, 0, 0]}
                  )
        self.play(Create(G))
        self.play(G.animate.change_layout(""circular""))
        self.wait()","Create a Manim animation scene that first displays a graph with 5 nodes (1 to 5) arranged in a straight horizontal line using specific coordinates: node 1 at (-2,0,0), 2 at (-1,0,0), 3 at (0,0,0), 4 at (1,0,0), and 5 at (2,0,0). The edges connect nodes consecutively (1-2, 2-3, 3-4, 4-5). Then, animate the graph layout changing smoothly to a circular arrangement. Include the creation animation for the initial graph, followed by the layout transformation animation, and end with a brief waiting period after the change. Use the Scene class named ChangeGraphLayout."
"from manim import *

class MovingVertices(Scene):
    def construct(self):
        vertices = [1, 2, 3, 4]
        edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]
        g = Graph(vertices, edges)
        self.play(Create(g))
        self.wait()
        self.play(g[1].animate.move_to([1, 1, 0]),
                  g[2].animate.move_to([-1, 1, 0]),
                  g[3].animate.move_to([1, -1, 0]),
                  g[4].animate.move_to([-1, -1, 0]))
        self.wait()","Create an animation scene that shows a graph with vertices labeled 1, 2, 3, and 4 connected by edges between (1-2), (2-3), (3-4), (1-3), and (1-4). First display the graph in its default layout, then simultaneously move vertex 1 to the top-right quadrant (coordinates [1, 1, 0]), vertex 2 to the top-left quadrant ([-1, 1, 0]), vertex 3 to the bottom-right quadrant ([1, -1, 0]), and vertex 4 to the bottom-left quadrant ([-1, -1, 0]). Include brief pauses before and after the transformation completes."
"from manim import *

class GraphAutoPosition(Scene):
    def construct(self):
        vertices = [1, 2, 3, 4, 5, 6, 7, 8]
        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),
                 (2, 8), (3, 4), (6, 1), (6, 2),
                 (6, 3), (7, 2), (7, 4)]
        autolayouts = [""spring"", ""circular"", ""kamada_kawai"",
                       ""planar"", ""random"", ""shell"",
                       ""spectral"", ""spiral""]
        graphs = [Graph(vertices, edges, layout=lt).scale(0.5)
                  for lt in autolayouts]
        r1 = VGroup(*graphs[:3]).arrange()
        r2 = VGroup(*graphs[3:6]).arrange()
        r3 = VGroup(*graphs[6:]).arrange()
        self.add(VGroup(r1, r2, r3).arrange(direction=DOWN))","Create a Manim animation scene where a graph with vertices [1, 2, 3, 4, 5, 6, 7, 8] and edges [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5), (2, 8), (3, 4), (6, 1), (6, 2), (6, 3), (7, 2), (7, 4)] is displayed using 8 different layout algorithms: spring, circular, kamada_kawai, planar, random, shell, spectral, spiral. Arrange the graphs in three horizontal rows (top, middle, bottom), with the first three layouts in the top row, next three in the middle row, and the last two in the bottom row. Ensure each graph is scaled to 50% of its size to fit in the rows. Each row must be positioned vertically stacked with spacing between them. The entire layout should show all visual variations of the graph's nodes and edges due to differing layout algorithms."
"from manim import *

class GraphManualPosition(Scene):
    def construct(self):
        vertices = [1, 2, 3, 4]
        edges = [(1, 2), (2, 3), (3, 4), (4, 1)]
        lt = {1: [0, 0, 0], 2: [1, 1, 0], 3: [1, -1, 0], 4: [-1, 0, 0]}
        G = Graph(vertices, edges, layout=lt)
        self.add(G)","Create a Manim Scene that animates the creation of a graph with four vertices (1, 2, 3, 4) connected by edges forming a cycle: (1-2), (2-3), (3-4), (4-1). Position the vertices manually at these coordinates: vertex 1 at (0, 0, 0), vertex 2 at (1, 1, 0), vertex 3 at (1, -1, 0), and vertex 4 at (-1, 0, 0). Display the graph as a static layout without any animated transitions or transformations."
"from manim import *

class LabeledModifiedGraph(Scene):
    def construct(self):
        vertices = [1, 2, 3, 4, 5, 6, 7, 8]
        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),
                 (2, 8), (3, 4), (6, 1), (6, 2),
                 (6, 3), (7, 2), (7, 4)]
        g = Graph(vertices, edges, layout=""circular"", layout_scale=3,
                  labels=True, vertex_config={7: {""fill_color"": RED}},
                  edge_config={(1, 7): {""stroke_color"": RED},
                               (2, 7): {""stroke_color"": RED},
                               (4, 7): {""stroke_color"": RED}})
        self.add(g)","Create a Manim animation scene showing a graph with vertices labeled 1 to 8 arranged in a circular layout scaled to radius 3. The graph should include edges between the following pairs: (1-7), (1-8), (2-3), (2-4), (2-5), (2-8), (3-4), (6-1), (6-2), (6-3), (7-2), (7-4). Vertex 7 must be highlighted in red, and all edges connected to vertex 7 (specifically the edges (1-7), (2-7), and (4-7)) should also appear in red. Include vertex labels for all nodes."
"from manim import *

import networkx as nx

class PartiteGraph(Scene):
    def construct(self):
        G = nx.Graph()
        G.add_nodes_from([0, 1, 2, 3])
        G.add_edges_from([(0, 2), (0,3), (1, 2)])
        graph = Graph(list(G.nodes), list(G.edges), layout=""partite"", partitions=[[0, 1]])
        self.play(Create(graph))","Create a Manim animation of a graph being drawn with the following specifications: The graph has 4 nodes (0, 1, 2, 3). Edges connect node 0 to 2, 0 to 3, and 1 to 2. The nodes should be arranged in a partite (bipartite) layout with nodes 0 and 1 in the first partition, and nodes 2 and 3 in the second partition. Animate the full creation of this graph, showing nodes and edges appearing sequentially. Nodes in different partitions should be visually separated into distinct horizontal or vertical layers corresponding to their partitions."
"from manim import *

class LinearNN(Scene):
    def construct(self):
        edges = []
        partitions = []
        c = 0
        layers = [2, 3, 3, 2]  # the number of neurons in each layer

        for i in layers:
            partitions.append(list(range(c + 1, c + i + 1)))
            c += i
        for i, v in enumerate(layers[1:]):
                last = sum(layers[:i+1])
                for j in range(v):
                    for k in range(last - layers[i], last):
                        edges.append((k + 1, j + last + 1))

        vertices = np.arange(1, sum(layers) + 1)

        graph = Graph(
            vertices,
            edges,
            layout='partite',
            partitions=partitions,
            layout_scale=3,
            vertex_config={'radius': 0.20},
        )
        self.add(graph)","Create a Manim animation scene that visualizes a fully connected feedforward neural network with 4 layers containing 2, 3, 3, and 2 neurons respectively. The neurons should be arranged in distinct horizontal layers using a partite layout. Each neuron in a layer must connect to every neuron in the next layer with visible edges. Nodes should have a consistent radius of 0.2 and be spaced apart with appropriate layout scaling to prevent overlap. The animation should display the complete static structure of this neural network graph without any movement or transformations."
"from manim import *

import networkx as nx

class Tree(Scene):
    def construct(self):
        G = nx.Graph()

        G.add_node(""ROOT"")

        for i in range(5):
            G.add_node(""Child_%i"" % i)
            G.add_node(""Grandchild_%i"" % i)
            G.add_node(""Greatgrandchild_%i"" % i)

            G.add_edge(""ROOT"", ""Child_%i"" % i)
            G.add_edge(""Child_%i"" % i, ""Grandchild_%i"" % i)
            G.add_edge(""Grandchild_%i"" % i, ""Greatgrandchild_%i"" % i)

        self.play(Create(
            Graph(list(G.nodes), list(G.edges), layout=""tree"", root_vertex=""ROOT"")))","Design an animation using Manim to visualize a multi-layer hierarchy tree. Start with a root node labeled “ROOT”. The root has five children nodes named “Child_0” to “Child_4”, each connected directly. Each “Child_i” node must be linked to a “Grandchild_i” node, which in turn connects to a “Greatgrandchild_i” node (i=0 to 4). Arrange this family tree structure in a vertical hierarchy using a tree-based layout where “ROOT” is the central topmost node. Nodes must form parent-child edge connections, and the layers must descend progressively downward from root to grandchild to great-grandchild levels. Use NetworkX to define node relationships first, then use Manim’s Graph class to display and animate the complete structure with proper hierarchical positioning in a single view."
"from manim import *

class CustomLayoutExample(Scene):
    def construct(self):
        import numpy as np
        import networkx as nx

        # create custom layout
        def custom_layout(
            graph: nx.Graph,
            scale: float | tuple[float, float, float] = 2,
            n: int | None = None,
            *args: Any,
            **kwargs: Any,
        ):
            nodes = sorted(list(graph))
            height = len(nodes) // n
            return {
                node: (scale * np.array([
                    (i % n) - (n-1)/2,
                    -(i // n) + height/2,
                    0
                ])) for i, node in enumerate(graph)
            }

        # draw graph
        n = 4
        graph = Graph(
            [i for i in range(4 * 2 - 1)],
            [(0, 1), (0, 4), (1, 2), (1, 5), (2, 3), (2, 6), (4, 5), (5, 6)],
            labels=True,
            layout=custom_layout,
            layout_config={'n': n}
        )
        self.add(graph)","Write a Manim animation scene that graphs nodes in a custom grid layout using a defined function. The graph must include 7 nodes (0-6) with edges: (0-1), 0-4; 1-2, 1-5; 2-3, 2-6; 4-5; 5-6. Nodes must display their numerical labels. The layout function should arrange nodes in a grid where each ""column"" has n=4 nodes (horizontal), calculating positions with numpy arrays. Positions must be centered horizontally and scaled. x-coordinates: ((index mod n) - centering offset) scaled by a factor. y-coordinates: adjusted based on rows to centralize the grid. The graph initializes with this custom layout function as the layout parameter and uses the networkx Graph structure."
"from manim import *

class CircularLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
            layout=""circular"",
            labels=True
        )
        self.add(graph)","Create a Manim animation scene that displays a graph with 6 nodes (labeled 1-6) arranged in a circular layout. Include edges connecting the nodes in the following pattern: (1-2), (2-3), (3-4), (4-5), (5-6), (6-1), (5-1), (1-3), and (3-5). The graph should be shown statically without any movement or transformations, ensuring nodes display their numerical labels."
"from manim import *

class KamadaKawaiLayout(Scene):
    def construct(self):
        from collections import defaultdict
        distances: dict[int, dict[int, float]] = defaultdict(dict)

        # set desired distances
        distances[1][2] = 1  # distance between vertices 1 and 2 is 1
        distances[2][3] = 1  # distance between vertices 2 and 3 is 1
        distances[3][4] = 2  # etc
        distances[4][5] = 3
        distances[5][6] = 5
        distances[6][1] = 8

        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)],
            layout=""kamada_kawai"",
            layout_config={""dist"": distances},
            layout_scale=4,
            labels=True
        )
        self.add(graph)","Create a Manim animation scene that visualizes a graph using the Kamada-Kawai layout algorithm. The graph should have nodes labeled 1 to 6 connected by edges forming a cycle: 1-2, 2-3, 3-4, 4-5, 5-6, and 6-1. Enforce specific desired distances in the Kamada-Kawai layout between connected nodes as follows: 1-2 = 1 unit, 2-3 =1 unit, 3-4 =2 units, 4-5 =3 units, 5-6 =5 units, and 6-1 =8 units. The graph should display node labels and use a scale factor of 4 to fit the screen. The animation should start by showing the final graph layout without any dynamic movements or transitions."
"from manim import *

class PartiteLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
            layout=""partite"",
            layout_config={""partitions"": [[1,2],[3,4],[5,6]]},
            labels=True
        )
        self.add(graph)","Create a Manim Scene that displays a graph with nodes labeled 1 to 6 connected through following edges: (1-2), (2-3), (3-4), (4-5), (5-6), (6-1), (5-1), (1-3), (3-5). Arrange the nodes using a partite layout with three vertical partitions: first partition contains nodes 1 and 2, second partition has nodes 3 and 4, third partition includes nodes 5 and 6. Ensure node labels are visible and the graph structure accurately reflects specified connections."
"from manim import *

class PlanarLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
            layout=""planar"",
            layout_scale=4,
            labels=True
        )
        self.add(graph)","Create an animation scene using Manim that displays a graph with 6 nodes labeled 1-6 arranged in a planar layout. The edges must connect the nodes as follows: 1-2, 2-3, 3-4, 4-5, 5-6, 6-1, 5-1, 1-3, and 3-5. The graph should use a layout_scale of 4 to enlarge it and must show node labels clearly."
"from manim import *

class RandomLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
            layout=""random"",
            labels=True
        )
        self.add(graph)","Design a Manim animation scene that displays a graph with the following characteristics: 

- **Nodes**: 6 nodes labeled numerically from 1 to 6.  
- **Edges**: The following connections must exist between the nodes:  
  (1-2), (2-3), (3-4), (4-5), (5-6), (6-1), (5-1), (1-3), (3-5).  
- **Layout**: Nodes must be arranged using the ""random"" layout algorithm so their positions are randomized.  
- **Labels**: Ensure all node labels are visibly displayed.  

Provide the Python code using Manim's `Graph` class inside a `Scene` to achieve this static visualization without any animations or transitions. Specify the exact edge pairs, layout parameter, and labeling configuration."
"from manim import *

class ShellLayout(Scene):
    def construct(self):
        nlist = [[1, 2, 3], [4, 5, 6, 7, 8, 9]]
        graph = Graph(
            [1, 2, 3, 4, 5, 6, 7, 8, 9],
            [(1, 2), (2, 3), (3, 1), (4, 1), (4, 2), (5, 2), (6, 2), (6, 3), (7, 3), (8, 3), (8, 1), (9, 1)],
            layout=""shell"",
            layout_config={""nlist"": nlist},
            labels=True
        )
        self.add(graph)","Create a Manim animation scene where a graph with nodes arranged in a shell layout is displayed. The graph should have 9 nodes numbered 1-9. Nodes 1, 2, and 3 should form the inner ring (first shell). Nodes 4, 5, 6, 7, 8, and 9 should form the outer ring (second shell in the ""shell"" layout with nlist=[[1,2,3],[4,5,6,7,8,9]). The edges must include: (1-2), (2-3), (3-1) forming a triangle in the inner ring. Additional connections from outer nodes to inner: 4 linked to 1 and 2; 5 to 2; 6 to 2 and 3; 7 to 3; 8 to 3 and 1; 9 to 1. Show node labels for all nodes. The graph should be initialized with the Graph class using these specifications."
"from manim import *

class SpectralLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
            layout=""spectral"",
            labels=True
        )
        self.add(graph)","Create a Manim animation scene that displays a graph with nodes labeled 1 to 6. The graph should include the following edges: (1-2), (2-3), (3-4), (4-5), (5-6), (6-1), (5-1), (1-3), and (3-5). Use the spectral layout algorithm to position nodes, and ensure each node displays its numeric label. The animation should start and end with this fully rendered graph without any transformations or movements."
"from manim import *

class SpiralLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
            layout=""spiral"",
            labels=True
        )
        self.add(graph)","Write Python code using Manim to create an animation scene where a graph with six labeled nodes (1-6) is displayed in a spiral layout. The graph should include edges connecting nodes in the following sequence: 1-2-3-4-5-6-1 (forming a hexagon), plus additional edges between 5-1, 1-3, and 3-5. The nodes must be arranged using Manim’s spiral layout algorithm, with visible numerical labels. The scene should initialize and display the graph without any movement or transformation animations."
"from manim import *

class SpringLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
            layout=""spring"",
            labels=True
        )
        self.add(graph)","Create a Manim animation scene that displays a graph with nodes labeled 1 to 6 connected by the following edges: (1-2), (2-3), (3-4), (4-5), (5-6), (6-1), (5-1), (1-3), and (3-5). The nodes should be arranged using a spring layout algorithm to naturally position them based on their connections. Ensure all node labels are visible and the graph's edges clearly show the specified connections."
"from manim import *

class TreeLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6, 7],
            [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)],
            layout=""tree"",
            layout_config={""root_vertex"": 1},
            labels=True
        )
        self.add(graph)","Write a Manim program that creates an animation showing a tree structure with nodes labeled 1 to 7. The tree should have node 1 as the root, connected to nodes 2 and 3. Node 2 connects to nodes 4 and 5, while node 3 connects to nodes 6 and 7. The graph should be laid out using Manim's tree layout algorithm with node 1 as the root vertex. Include node labels in the visualization."
"from manim import *

class LogScalingExample(Scene):
    def construct(self):
        ax = Axes(
            x_range=[0, 10, 1],
            y_range=[-2, 6, 1],
            tips=False,
            axis_config={""include_numbers"": True},
            y_axis_config={""scaling"": LogBase(custom_labels=True)},
        )

        # x_min must be > 0 because log is undefined at 0.
        graph = ax.plot(lambda x: x ** 2, x_range=[0.001, 10], use_smoothing=False)
        self.add(ax, graph)","Your task is to create a Manim animation scene showing a mathematical graph plotted on a coordinate system with a logarithmic y-axis. Provide the Python code that:  
1. Creates a coordinate system (Axes) with the following properties:  
   - x-axis range: 0 to 10 (inclusive), with tick step 1  
   - y-axis range: -2 to 6 (inclusive), with tick step 1, using logarithmic scaling (via `LogBase`).  
   - Disable arrow tips (""needles"") at axis ends (`tips=False`).  
   - Show numerical labels on both axes (`include_numbers=True`).  
2. Plot the function **y = x²** as a continuous curve on this axes system.  
   - Use a starting x-value slightly above 0 (e.g., 0.001) to avoid log(0) errors.  
   - The curve must adjust to the logarithmic scaling of the y-axis.  
3. Ensure the y-axis displays custom logarithmic labels (e.g., showing 10^-2, 10^0, 10^2, etc.) instead of raw numerical values. The graph should visibly curve according to the scaling transformation.  

The code must directly produce these visual components when run with Manim, using classes like `LogBase`, `Axes`, and `plot`."
"from manim import *

class AxesWithDifferentTips(Scene):
    def construct(self):
        ax = Axes(axis_config={'tip_shape': StealthTip})
        self.add(ax)","Create a Manim scene that displays a coordinate axes system where all axes have stealth-style arrow tips instead of the default arrowhead shape. The axes must be initialized using the Axes class with the ""tip_shape"" parameter set to StealthTip in their axis configurations. The scene should render the axes with the custom arrow tips without any additional animations or transformations."
"from manim import *

class CoordsToPointExample(Scene):
    def construct(self):
        ax = Axes().add_coordinates()

        # a dot with respect to the axes
        dot_axes = Dot(ax.coords_to_point(2, 2), color=GREEN)
        lines = ax.get_lines_to_point(ax.c2p(2,2))

        # a dot with respect to the scene
        # the default plane corresponds to the coordinates of the scene.
        plane = NumberPlane()
        dot_scene = Dot((2,2,0), color=RED)

        self.add(plane, dot_scene, ax, dot_axes, lines)","Create a Manim animation scene showing the following elements:  
1. A graph's axes with labeled coordinates.  
2. A green dot positioned at coordinates (2, 2) relative to the axes’ system, with lines drawn from both axes to the dot.  
3. A red dot placed at the position (2, 2) of the scene’s global coordinate system (not the axes’).  
4. A number plane/grid in the background as a reference.  
Ensure all elements are layered correctly for visibility."
"from manim import *

class GetAxisLabelsExample(Scene):
    def construct(self):
        ax = Axes()
        labels = ax.get_axis_labels(
            Tex(""x-axis"").scale(0.7), Text(""y-axis"").scale(0.45)
        )
        self.add(ax, labels)","Design a Manim animation scene that displays a coordinate axis system with customized axis labels. The x-axis label should be typeset as LaTeX text (""x-axis"") scaled to 70% of its original size, while the y-axis label should be standard text (""y-axis"") scaled to 45% of its original size. The axes lines and numbers should appear with default styling, but ensure both axis labels are properly positioned and formatted according to these scaling specifications."
"from manim import *

class LineGraphExample(Scene):
    def construct(self):
        plane = NumberPlane(
            x_range = (0, 7),
            y_range = (0, 5),
            x_length = 7,
            axis_config={""include_numbers"": True},
        )
        plane.center()
        line_graph = plane.plot_line_graph(
            x_values = [0, 1.5, 2, 2.8, 4, 6.25],
            y_values = [1, 3, 2.25, 4, 2.5, 1.75],
            line_color=GOLD_E,
            vertex_dot_style=dict(stroke_width=3,  fill_color=PURPLE),
            stroke_width = 4,
        )
        self.add(plane, line_graph)","Create a Manim animation scene that displays a 2D coordinate system (number plane) with x-axis ranging from 0 to 7 and y-axis from 0 to 5. The axes should be labeled with numbers and centered on the screen. On this plane, plot a line graph passing through the following points: (0,1), (1.5,3), (2,2.25), (2.8,4), (4,2.5), and (6.25,1.75). The connecting lines of the graph should be gold with thickness 4. Each vertex point on the graph should be highlighted with a purple dot that has a thick outline (stroke width 3). All elements should appear immediately without any movement, transformations, or animations."
"from manim import *

class PointToCoordsExample(Scene):
    def construct(self):
        ax = Axes(x_range=[0, 10, 2]).add_coordinates()
        circ = Circle(radius=0.5).shift(UR * 2)

        # get the coordinates of the circle with respect to the axes
        coords = np.around(ax.point_to_coords(circ.get_right()), decimals=2)

        label = (
            Matrix([[coords[0]], [coords[1]]]).scale(0.75).next_to(circ, RIGHT)
        )

        self.add(ax, circ, label, Dot(circ.get_right()))","Design a Manim scene displaying a static 2D coordinate system with an x-axis ranging from 0 to 10 (with intervals of 2 units) and tick labels. Include a circular shape with a radius of 0.5 placed 2 units in the upper-right diagonal direction. Show a small dot at the circle's farthest point to the right. Next to this circle, position a scaled-down 75% matrix (0.75 size) displaying the exact rounded (to two decimal places) coordinates of the dot’s position according to the coordinate system. All elements must appear simultaneously without any motion or transitions."
"from manim import *

class ComplexPlaneExample(Scene):
    def construct(self):
        plane = ComplexPlane().add_coordinates()
        self.add(plane)
        d1 = Dot(plane.n2p(2 + 1j), color=YELLOW)
        d2 = Dot(plane.n2p(-3 - 2j), color=YELLOW)
        label1 = MathTex(""2+i"").next_to(d1, UR, 0.1)
        label2 = MathTex(""-3-2i"").next_to(d2, UR, 0.1)
        self.add(
            d1,
            label1,
            d2,
            label2,
        )","Create a Manim Python script for an animation scene that shows the following elements in a coordinate system: a complex plane with coordinate axes and numerical labels, two yellow dots positioned at the complex points 2+i and -3-2i (converted via ComplexPlane.n2p method for coordinate mapping), and mathematical text labels (""2+i"" and ""-3-2i"") placed near each dot in the upper-right direction with a buffer distance of 0.1. Structure the code to include these elements in the Scene's construct method so they appear together on the screen."
"from manim import *

class CoordSysExample(Scene):
    def construct(self):
        # the location of the ticks depends on the x_range and y_range.
        grid = Axes(
            x_range=[0, 1, 0.05],  # step size determines num_decimal_places.
            y_range=[0, 1, 0.05],
            x_length=9,
            y_length=5.5,
            axis_config={
                ""numbers_to_include"": np.arange(0, 1 + 0.1, 0.1),
                ""font_size"": 24,
            },
            tips=False,
        )

        # Labels for the x-axis and y-axis.
        y_label = grid.get_y_axis_label(""y"", edge=LEFT, direction=LEFT, buff=0.4)
        x_label = grid.get_x_axis_label(""x"")
        grid_labels = VGroup(x_label, y_label)

        graphs = VGroup()
        for n in np.arange(1, 20 + 0.5, 0.5):
            graphs += grid.plot(lambda x: x ** n, color=WHITE)
            graphs += grid.plot(
                lambda x: x ** (1 / n), color=WHITE, use_smoothing=False
            )

        # Extra lines and labels for point (1,1)
        graphs += grid.get_horizontal_line(grid @ (1, 1, 0), color=BLUE)
        graphs += grid.get_vertical_line(grid @ (1, 1, 0), color=BLUE)
        graphs += Dot(point=grid @ (1, 1, 0), color=YELLOW)
        graphs += Tex(""(1,1)"").scale(0.75).next_to(grid @ (1, 1, 0))
        title = Title(
            # spaces between braces to prevent SyntaxError
            r""Graphs of $y=x^{ {1}\over{n} }$ and $y=x^n (n=1,2,3,...,20)$"",
            include_underline=False,
            font_size=40,
        )

        self.add(title, graphs, grid, grid_labels)","Create an animation scene using Manim where:
1. A coordinate system is displayed with axes ranging from 0 to 1 on both x and y with 0.05 step increments. Axes are 9 units wide and 5.5 units tall. Ticks are labeled every 0.1 units with font size 24, and no axis tips.
2. Label the x-axis as ""x"" and y-axis as ""y"", with the y-label positioned on the left side of the y-axis.
3. Plot all curves of the functions y = xⁿ and y = x^(1/n) for n ranging from 1 to 20 in increments of 0.5. Use white color for all curves. Apply smoothing to y = xⁿ curves but disable smoothing for y = x^(1/n) curves.
4. Add blue horizontal and vertical lines intersecting at the point (1,1) on the grid, along with a yellow dot at this intersection point. Include a small TeX label ""(1,1)"" near this point.
5. Display a title at the top: ""Graphs of y=x^{{1}/({n})} and y=x^n (n=1,2,3,...,20)"" in 40pt font without an underline.
6. All elements should be initialized and displayed simultaneously without animation transitions. Use grid alignment for the coordinate system and labels."
"from manim import *

class TLabelExample(Scene):
    def construct(self):
        # defines the axes and linear function
        axes = Axes(x_range=[-1, 10], y_range=[-1, 10], x_length=9, y_length=6)
        func = axes.plot(lambda x: x, color=BLUE)
        # creates the T_label
        t_label = axes.get_T_label(x_val=4, graph=func, label=Tex(""x-value""))
        self.add(axes, func, t_label)","Create a Manim Scene called TLabelExample that:  
1. Displays a coordinate system (Axes) with x and y ranges from -1 to 10, x_length=9, y_length=6.  
2. Plots a blue straight line graph of the function y = x on these axes.  
3. Adds a T-shaped label (T_label) anchored at the x-value 4 on this graph.  
4. Positions the label text ""x-value"" (using LaTeX formatting) near the T_label point.  
Ensure all elements (axes, graph, and T_label) are added to the scene.  

Provide the complete Python code using Manim library syntax, including class definition and proper method calls."
"from manim import *

class GetAreaExample(Scene):
    def construct(self):
        ax = Axes().add_coordinates()
        curve = ax.plot(lambda x: 2 * np.sin(x), color=DARK_BLUE)
        area = ax.get_area(
            curve,
            x_range=(PI / 2, 3 * PI / 2),
            color=(GREEN_B, GREEN_D),
            opacity=1,
        )

        self.add(ax, curve, area)","Prompt:  
""Create a Manim animation scene that displays a 2D coordinate system (Axes) with axis coordinates. Plot a dark blue curve representing the function y = 2*sin(x). Shade the area under the curve between x = π/2 and x = 3π/2 with a vertical gradient filling from light green (GREEN_B) to dark green (GREEN_D), full opacity. The elements (axes, curve, and shaded area) should appear statically without any movement, transformations, or animations. Generate the Python code using Manim library version allowing Axes.get_area method."""
"from manim import *

class GetGraphLabelExample(Scene):
    def construct(self):
        ax = Axes()
        sin = ax.plot(lambda x: np.sin(x), color=PURPLE_B)
        label = ax.get_graph_label(
            graph=sin,
            label= MathTex(r""\frac{\pi}{2}""),
            x_val=PI / 2,
            dot=True,
            direction=UR,
        )

        self.add(ax, sin, label)","Create a Manim animation scene that displays a 2D coordinate axis (Axes). Plot a purple sinusoidal graph (y = sin(x)) on the axes. Add a label showing the mathematical expression ""\frac{\pi}{2}"" positioned at the x-value of π/2 on the sine graph. The label should include a small dot marker at the specified point on the graph and be aligned in the upper-right (UR) diagonal direction from that point. The label text should be placed near the dot, with a line or arrow connecting it to the exact point on the graph curve. All elements (axes, graph, label, and dot) should be displayed simultaneously without any animated transitions."
"from manim import *

class GetHorizontalLineExample(Scene):
    def construct(self):
        ax = Axes().add_coordinates()
        point = ax @ (-4, 1.5)

        dot = Dot(point)
        line = ax.get_horizontal_line(point, line_func=Line)

        self.add(ax, line, dot)","""Design a Manim animation scene where a coordinate system with axes and numerical labels is shown. A horizontal line is drawn from the vertical (y-axis) to the point located at Cartesian coordinates (-4, 1.5). A small dot is placed precisely at that point. All elements (axes, line, and dot) should appear together in the scene."""
"from manim import *

class GetLinesToPointExample(Scene):
    def construct(self):
        ax = Axes()
        circ = Circle(radius=0.5).move_to([-4, -1.5, 0])

        lines_1 = ax.get_lines_to_point(circ.get_right(), color=GREEN_B)
        lines_2 = ax.get_lines_to_point(circ.get_corner(DL), color=BLUE_B)
        self.add(ax, lines_1, lines_2, circ)","Create a Manim animation scene where:  
1. A coordinate axes (Axes) is displayed.  
2. A small circle (radius 0.5) is placed at the coordinates (-4, -1.5).  
3. Multiple green (GREEN_B) lines radiate from the axes to the rightmost point of the circle.  
4. Multiple blue (BLUE_B) lines radiate from the axes to the lower-left (DL) corner of the circle.  
Ensure the lines are generated using the axes' method to connect to the specified points on the circle, and all elements are added to the scene together without any animated movement."
"from manim import *

class GetRiemannRectanglesExample(Scene):
    def construct(self):
        ax = Axes(y_range=[-2, 10])
        quadratic = ax.plot(lambda x: 0.5 * x ** 2 - 0.5)

        # the rectangles are constructed from their top right corner.
        # passing an iterable to `color` produces a gradient
        rects_right = ax.get_riemann_rectangles(
            quadratic,
            x_range=[-4, -3],
            dx=0.25,
            color=(TEAL, BLUE_B, DARK_BLUE),
            input_sample_type=""right"",
        )

        # the colour of rectangles below the x-axis is inverted
        # due to show_signed_area
        rects_left = ax.get_riemann_rectangles(
            quadratic, x_range=[-1.5, 1.5], dx=0.15, color=YELLOW
        )

        bounding_line = ax.plot(
            lambda x: 1.5 * x, color=BLUE_B, x_range=[3.3, 6]
        )
        bounded_rects = ax.get_riemann_rectangles(
            bounding_line,
            bounded_graph=quadratic,
            dx=0.15,
            x_range=[4, 5],
            show_signed_area=False,
            color=(MAROON_A, RED_B, PURPLE_D),
        )

        self.add(
            ax, bounding_line, quadratic, rects_right, rects_left, bounded_rects
        )","Write a Manim Python code for an animation scene that visualizes the following static elements:

1. A coordinate system with y-axis ranging from -2 to 10.
2. A parabolic curve defined by the equation f(x) = 0.5x² - 0.5 plotted on the axes.
3. Riemann rectangles for the curve between x=-4 and x=-3, with subinterval width=0.25, using right-endpoint sampling, and colored with a gradient from teal to blue to dark blue.
4. Riemann rectangles for the same curve between x=-1.5 and x=1.5, with width=0.15, filled in yellow, with rectangles below the x-axis having inverted colors to indicate signed area.
5. A straight line graph of y=1.5x drawn between x=3.3 and 6, colored blue.
6. Additional Riemann rectangles between the blue line and parabola from x=4 to 5, separated by width=0.15, with gradient colors maroon to red to purple, and without automatic color inversion even if the line is beneath the curve (show_signed_area disabled).
All listed elements should be placed simultaneously in the scene without any animations/transitions between them. Include appropriate parameters for gradient color transitions, graph bounding ranges, sampling positions, and area signing behavior."
"from manim import *

class GetSecantSlopeGroupExample(Scene):
    def construct(self):
        ax = Axes(y_range=[-1, 7])
        graph = ax.plot(lambda x: 1 / 4 * x ** 2, color=BLUE)
        slopes = ax.get_secant_slope_group(
            x=2.0,
            graph=graph,
            dx=1.0,
            dx_label=Tex(""dx = 1.0""),
            dy_label=""dy"",
            dx_line_color=GREEN_B,
            secant_line_length=4,
            secant_line_color=RED_D,
        )

        self.add(ax, graph, slopes)","Create a Manim animation scene showing:  
1. A coordinate system with y-axis ranging from -1 to 7  
2. A blue graph of the function f(x) = (1/4)x²  
3. A secant line group at x=2.0 with a horizontal change (dx=1.0) displayed as a green vertical line segment, connected by a red secant line of length 4  
4. The ""dx"" label explicitly showing the equation ""dx = 1.0"" typeset in LaTeX  
5. The corresponding ""dy"" label indicating the vertical change  
The animation should initialize all elements on screen simultaneously without any movement or transition effects. Use Manim's get_secant_slope_group method to construct the secant line components with specified colors (dark red for secant line, blue-green for dx line)."
"from manim import *

class GetVerticalLineExample(Scene):
    def construct(self):
        ax = Axes().add_coordinates()
        point = ax.coords_to_point(-3.5, 2)

        dot = Dot(point)
        line = ax.get_vertical_line(point, line_config={""dashed_ratio"": 0.85})

        self.add(ax, line, dot)","Create a Manim animation scene that displays a coordinate plane with labeled axes. Show a vertical dashed line extending from the point (-3.5, 2) down to the x-axis, using a dashed ratio of 0.85 between dashed segments and solid segments. Add a dot at the coordinates (-3.5, 2). The scene should only display these elements statically without any movement or transitions."
"from manim import *

class GetVerticalLinesToGraph(Scene):
    def construct(self):
        ax = Axes(
            x_range=[0, 8.0, 1],
            y_range=[-1, 1, 0.2],
            axis_config={""font_size"": 24},
        ).add_coordinates()

        curve = ax.plot(lambda x: np.sin(x) / np.e ** 2 * x)

        lines = ax.get_vertical_lines_to_graph(
            curve, x_range=[0, 4], num_lines=30, color=BLUE
        )

        self.add(ax, curve, lines)","Create an animation using Manim that shows the following elements: (1) a coordinate system with an x-axis ranging from 0–8 and y-axis from -1–1, including numerical axis labels. (2) a curve of the mathematical function f(x) = (sin(x) * x) divided by e squared. (3) 30 vertical blue lines rising from the x-axis to meet the curve between x-values 0–4. All elements must be displayed simultaneously in the final scene."
"from manim import *

class GetXAxisLabelExample(Scene):
    def construct(self):
        ax = Axes(x_range=(0, 8), y_range=(0, 5), x_length=8, y_length=5)
        x_label = ax.get_x_axis_label(
            Tex(""$x$-values"").scale(0.65), edge=DOWN, direction=DOWN, buff=0.5
        )
        self.add(ax, x_label)","Create a Manim animation scene that displays an axes with the following characteristics: 
- The x-axis ranges from 0 to 8, and the y-axis ranges from 0 to 5. 
- The x-axis has a label positioned below the axis, showing the text ""$x$-values"" scaled to 65% of its original size. 
- The label should be placed with a 0.5 unit buffer distance from the end of the x-axis. 
The scene should properly initialize the axes and label using_axes.get_x_axis_label() method, and add both elements to the scene. Provide the complete Python code including necessary imports."
"from manim import *

class GetYAxisLabelExample(Scene):
    def construct(self):
        ax = Axes(x_range=(0, 8), y_range=(0, 5), x_length=8, y_length=5)
        y_label = ax.get_y_axis_label(
            Tex(""$y$-values"").scale(0.65).rotate(90 * DEGREES),
            edge=LEFT,
            direction=LEFT,
            buff=0.3,
        )
        self.add(ax, y_label)","Create a Manim animation scene that visualizes a 2D coordinate system with the following elements: a custom y-axis label displaying ""$y$-values"" rotated 90 degrees, scaled down to 65% of its original size, positioned to the left of the y-axis with a small buffer distance (0.3 units). The coordinate system should have an x-axis range from 0 to 8 and y-axis range from 0 to 5, with the x-axis length set to 8 units and the y-axis length set to 5 units on the screen. The y-axis label must be statically positioned using the LEFT edge and direction parameters, without any animation transitions."
"from manim import *

class InputToGraphPointExample(Scene):
    def construct(self):
        ax = Axes()
        curve = ax.plot(lambda x : np.cos(x))

        # move a square to PI on the cosine curve.
        position = ax.input_to_graph_point(x=PI, graph=curve)
        sq = Square(side_length=1, color=YELLOW).move_to(position)

        self.add(ax, curve, sq)","Create a Manim scene animation that:  
1. Displays a coordinate system (Axes).  
2. Plots a cosine curve (y=cos(x)) using the axes.  
3. Moves a small yellow square (side length=1) to the exact point on the cosine curve at x=PI (position calculated using input_to_graph_point).  
4. Shows all elements (axes, curve, square) together in the final frame.  

Specify visual transformations:  
- The square should be positioned precisely where the curve is at x=π, which corresponds to the coordinates (PI, cos(π)).  
- Ensure the square is aligned with the graph’s point using the input_to_graph_point method."
"from manim import *

class PlotExample(Scene):
    def construct(self):
        # construct the axes
        ax_1 = Axes(
            x_range=[0.001, 6],
            y_range=[-8, 2],
            x_length=5,
            y_length=3,
            tips=False,
        )
        ax_2 = ax_1.copy()
        ax_3 = ax_1.copy()

        # position the axes
        ax_1.to_corner(UL)
        ax_2.to_corner(UR)
        ax_3.to_edge(DOWN)
        axes = VGroup(ax_1, ax_2, ax_3)

        # create the logarithmic curves
        def log_func(x):
            return np.log(x)

        # a curve without adjustments; poor interpolation.
        curve_1 = ax_1.plot(log_func, color=PURE_RED)

        # disabling interpolation makes the graph look choppy as not enough
        # inputs are available
        curve_2 = ax_2.plot(log_func, use_smoothing=False, color=ORANGE)

        # taking more inputs of the curve by specifying a step for the
        # x_range yields expected results, but increases rendering time.
        curve_3 = ax_3.plot(
            log_func, x_range=(0.001, 6, 0.001), color=PURE_GREEN
        )

        curves = VGroup(curve_1, curve_2, curve_3)

        self.add(axes, curves)","Prompt: ""Design a Manim animation scene that shows three vertical axes arranged on the screen. Place the first axis in the upper-left corner, the second in the upper-right corner, and the third centered at the bottom edge. Each axis should have an x-range from 0.001 to 6 and y-range from -8 to 2, with x_length=5 and y_length=3. Disable tips on all axes. 

On the first axis (left), plot the natural logarithmic curve in pure red with default smoothing. On the second axis (right), plot the same log function in orange but disable curve smoothing to show jagged interpolation. On the third axis (bottom), plot the log function in pure green while specifying a dense x-range step of 0.001 for smooth rendering despite longer computation. Group all axes and curves into separate VGroups and display them all together in the scene."""
"from manim import *

class AntiderivativeExample(Scene):
    def construct(self):
        ax = Axes()
        graph1 = ax.plot(
            lambda x: (x ** 2 - 2) / 3,
            color=RED,
        )
        graph2 = ax.plot_antiderivative_graph(graph1, color=BLUE)
        self.add(ax, graph1, graph2)","Create a Manim animation scene that displays a coordinate system (Axes) with two curves. The first curve is the function (x² - 2)/3 plotted in red. The second curve must represent the antiderivative of this function and be displayed in blue. Both graphs should be shown simultaneously without any animated transitions, movements, or transformations applied to them during the scene. Include the axes and ensure both graphs are visible at the same time."
"from manim import *

class DerivativeGraphExample(Scene):
    def construct(self):
        ax = NumberPlane(y_range=[-1, 7], background_line_style={""stroke_opacity"": 0.4})

        curve_1 = ax.plot(lambda x: x ** 2, color=PURPLE_B)
        curve_2 = ax.plot_derivative_graph(curve_1)
        curves = VGroup(curve_1, curve_2)

        label_1 = ax.get_graph_label(curve_1, ""x^2"", x_val=-2, direction=DL)
        label_2 = ax.get_graph_label(curve_2, ""2x"", x_val=3, direction=RIGHT)
        labels = VGroup(label_1, label_2)

        self.add(ax, curves, labels)","Create a Manim animation scene that visually demonstrates a function and its derivative using a coordinate system. The scene should display:  
1. A 2D coordinate plane with horizontal and vertical grid lines (semi-transparent background lines). The y-axis should range from -1 to 7.  
2. A purple graph of the function f(x) = x² displayed on the coordinate plane.  
3. A dynamic representation of its derivative function f’(x) = 2x shown as a separate curve on the same axes.  
4. Text labels ""x²"" and ""2x"" anchored near their respective curves: the first label positioned to the lower-left of the quadratic curve (near x=-2), and the second label positioned to the right of the linear derivative curve (near x=3).  

Both curves and labels must be visibly distinct and properly aligned to their respective functions. The coordinate plane, curves, and labels should appear simultaneously without any animated transitions."
"from manim import *

class ImplicitExample(Scene):
    def construct(self):
        ax = Axes()
        a = ax.plot_implicit_curve(
            lambda x, y: y * (x - y) ** 2 - 4 * x - 8, color=BLUE
        )
        self.add(ax, a)","Create a Manim animation scene showing a coordinate axis (Axes). On this axis, plot an implicit curve defined by the equation y*(x - y)^2 - 4x - 8. The implicit curve must be displayed in blue color. The scene should remain static without any moving parts, transformations, or animated transitions—only the axes and the plotted curve should be visible."
"from manim import *

class ParametricCurveExample(Scene):
    def construct(self):
        ax = Axes()
        cardioid = ax.plot_parametric_curve(
            lambda t: np.array(
                [
                    np.exp(1) * np.cos(t) * (1 - np.cos(t)),
                    np.exp(1) * np.sin(t) * (1 - np.cos(t)),
                    0,
                ]
            ),
            t_range=[0, 2 * PI],
            color=""#0FF1CE"",
        )
        self.add(ax, cardioid)","Create a Manim animation scene that starts with an empty screen, then gradually displays a Cartesian coordinate system (axes). Axes()). Then, plot a parametric curve defined by the equations x(t) = e * cos(t)*(1 - cos(t)), y(t) = e * sin(t)*(1 - cos(t)), for t ranging from 0 to 2π. The curve should be colored in the hex color #0FF1CE. The curve must be drawn fully within the axes, and both the axes and the curve remain visible until the end of the scene. No additional movements, transformations, or animations beyond drawing the objects as described are needed."
"from manim import *

class PolarGraphExample(Scene):
    def construct(self):
        plane = PolarPlane()
        r = lambda theta: 2 * np.sin(theta * 5)
        graph = plane.plot_polar_graph(r, [0, 2 * PI], color=ORANGE)
        self.add(plane, graph)",Create a Manim animation that shows a polar coordinate system with an orange-colored graph of the function r = 2*sin(5θ) plotted from θ = 0 to 2π. The scene should start by displaying the polar grid and the graph together without any animated drawing process. Ensure the graph is fully visible on the polar plane.
"from manim import *

class PlotSurfaceExample(ThreeDScene):
    def construct(self):
        resolution_fa = 16
        self.set_camera_orientation(phi=75 * DEGREES, theta=-60 * DEGREES)
        axes = ThreeDAxes(x_range=(-3, 3, 1), y_range=(-3, 3, 1), z_range=(-5, 5, 1))
        def param_trig(u, v):
            x = u
            y = v
            z = 2 * np.sin(x) + 2 * np.cos(y)
            return z
        trig_plane = axes.plot_surface(
            param_trig,
            resolution=(resolution_fa, resolution_fa),
            u_range = (-3, 3),
            v_range = (-3, 3),
            colorscale = [BLUE, GREEN, YELLOW, ORANGE, RED],
            )
        self.add(axes, trig_plane)","Create a 3D animation scene using Manim where:  
1. A 3D coordinate system (ThreeDAxes) is displayed with x, y, and z ranges set from -3 to 3 (x and y) and -5 to 5 (z).  
2. The camera angle is set to phi=75 degrees and theta=-60 degrees.  
3. A parametric surface is plotted using the function z = 2*sin(x) + 2*cos(y), where x and y range from -3 to 3.  
4. The surface uses a color gradient transitioning through [BLUE, GREEN, YELLOW, ORANGE, RED] based on z-values.  
5. The surface has a resolution of 16x16 segments for smooth curvature.  
6. Both the axes and the surface are added to the scene.  

Describe the animation where these elements are displayed statically without movement or transformation."
"from manim import *

class PolarToPointExample(Scene):
    def construct(self):
        polarplane_pi = PolarPlane(azimuth_units=""PI radians"", size=6)
        polartopoint_vector = Vector(polarplane_pi.polar_to_point(3, PI/4))
        self.add(polarplane_pi)
        self.add(polartopoint_vector)","""Design a Manim animation scene that displays a Polar coordinate system with azimuth labels in PI radians and a size of 6 units. Show a vector originating from the origin pointing to the polar coordinates (r=3, θ=π/4). Include the setup for both the polar grid background and the vector object without any explicit animation transitions."""
"from manim import *

class NumberPlaneExample(Scene):
    def construct(self):
        number_plane = NumberPlane(
            background_line_style={
                ""stroke_color"": TEAL,
                ""stroke_width"": 4,
                ""stroke_opacity"": 0.6
            }
        )
        self.add(number_plane)","Create a Manim animation scene that includes a NumberPlane with the following visual properties: the background lines must be teal in color, have a stroke width of 4, and an opacity of 0.6. The scene should render the NumberPlane as a static element without any animations or transformations. Explicitly define the NumberPlane's style parameters using a dictionary for background_line_style, and ensure the code uses proper class inheritance and structure for a Manim Scene."
"from manim import *

class NumberPlaneScaled(Scene):
    def construct(self):
        number_plane = NumberPlane(
            x_range=(-4, 11, 1),
            y_range=(-3, 3, 1),
            x_length=5,
            y_length=2,
        ).move_to(LEFT*3)

        number_plane_scaled_y = NumberPlane(
            x_range=(-4, 11, 1),
            x_length=5,
            y_length=4,
        ).move_to(RIGHT*3)

        self.add(number_plane)
        self.add(number_plane_scaled_y)","Design a Manim animation where two NumberPlanes are displayed side-by-side. The left NumberPlane has the following specifications: x-axis from -4 to 11 with step 1, y axis from -3 to 3 with step 1, x_length of 5 units, y_length of 2 units, positioned 3 units to the left of center. The right NumberPlane must strictly mirror the left’s x-axis parameters (x_range, step, and length), but its y_length is set to 4 units instead of 2, maintaining the same numerical y-axis range, and placed 3 units to the right of center. Both should be visible simultaneously in the scene."
"from manim import *

class PolarPlaneExample(Scene):
    def construct(self):
        polarplane_pi = PolarPlane(
            azimuth_units=""PI radians"",
            size=6,
            azimuth_label_font_size=33.6,
            radius_config={""font_size"": 33.6},
        ).add_coordinates()
        self.add(polarplane_pi)","Create a Manim animation that displays a polar coordinate system with the following specifications: 
- The azimuth (angle) units should be labeled in terms of ""PI radians"" (e.g., π/2, π, 3π/2, etc.). 
- The overall size of the plane should be 6 units. 
- Both the radius labels (distance from origin) and azimuth (angle) labels must have a consistent font size of 33.6. 
- Include coordinate lines and numerical labels for both radial and angular divisions."
"from manim import *

class GetAxisLabelsExample(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=2*PI/5, theta=PI/5)
        axes = ThreeDAxes()
        labels = axes.get_axis_labels(
            Text(""x-axis"").scale(0.7), Text(""y-axis"").scale(0.45), Text(""z-axis"").scale(0.45)
        )
        self.add(axes, labels)","Prompt:  
""Write Manim code for an animation scene that displays a 3D coordinate system. Set the camera orientation with phi=2π/5 and theta=PI/5. Create 3D axes using ThreeDAxes, then add labeled axes with scaled text: 'x-axis' scaled to 0.7, 'y-axis' scaled to 0.45, and 'z-axis' scaled to 0.45. Show both the axes and labels in the scene."""
"from manim import *

class GetYAxisLabelExample(ThreeDScene):
    def construct(self):
        ax = ThreeDAxes()
        lab = ax.get_y_axis_label(Tex(""$y$-label""))
        self.set_camera_orientation(phi=2*PI/5, theta=PI/5)
        self.add(ax, lab)","Create a 3D coordinate system (axes) animation. Add a ""$y$-label"" (rendered in LaTeX) attached to the y-axis. Position the camera view at a 72° angle (phi = 2π/5 radians) from the horizontal plane and a 36° angle (theta = π/5 radians) around the z-axis rotation to show the 3D axes and label in perspective. Ensure the label is displayed correctly on the y-axis and the camera orientation provides a clear angled view of the scene."
"from manim import *

class GetZAxisLabelExample(ThreeDScene):
    def construct(self):
        ax = ThreeDAxes()
        lab = ax.get_z_axis_label(Tex(""$z$-label""))
        self.set_camera_orientation(phi=2*PI/5, theta=PI/5)
        self.add(ax, lab)","Write a Python script using the Manim library to create an animation scene that: 

1. Initializes a 3D coordinate system with x, y, and z-axes.
2. Adds a LaTeX-rendered label Text ""z-label"" specifically positioned as the z-axis label.
3. Orients the 3D camera with a phi angle of 2π/5 (polar angle) and theta angle of π/5 (azimuthal angle).
4. Displays the coordinate axes and z-axis label together in the specified camera perspective without any additional elements or movements.

Provide code using the ThreeDScene class, ThreeDAxes, Tex, and get_z_axis_label method with correct parameters."
"from manim import *

class ExampleFunctionGraph(Scene):
    def construct(self):
        cos_func = FunctionGraph(
            lambda t: np.cos(t) + 0.5 * np.cos(7 * t) + (1 / 7) * np.cos(14 * t),
            color=RED,
        )

        sin_func_1 = FunctionGraph(
            lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),
            color=BLUE,
        )

        sin_func_2 = FunctionGraph(
            lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),
            x_range=[-4, 4],
            color=GREEN,
        ).move_to([0, 1, 0])

        self.add(cos_func, sin_func_1, sin_func_2)","Create a Manim animation scene class named ExampleFunctionGraph that displays three overlapping function graphs. The first graph is a red cosine function combining three components: cos(t) as the base, 0.5*cos(7t) as a higher frequency term, and (1/7)*cos(14t) as the highest frequency component. The second graph is a blue sine function that has the same three-term structure as the cosine function but uses sine instead of cosine for all components. The third graph is a green sine function identical in formula to the blue one, but it must be vertically shifted upward by 1 unit and restricted to the x-range from -4 to 4. All three graphs should appear simultaneously in the final frame. Use current Manim syntax with proper class structure and method definitions."
"from manim import *

class ImplicitFunctionExample(Scene):
    def construct(self):
        graph = ImplicitFunction(
            lambda x, y: x * y ** 2 - x ** 2 * y - 2,
            color=YELLOW
        )
        self.add(NumberPlane(), graph)","""Generate a Manim animation code for a scene that displays a yellow-colored implicit curve defined by the equation x*y² - x²*y = 2 on a coordinate plane. The animation should include a number plane grid as the background, with the implicit function graph rendered in yellow. Ensure the graph is plotted correctly as the zero-level set of the function and static (no movement or transformations), simply shown alongside the grid."""
"from manim import *

class ImplicitFunctionExample(Scene):
    def construct(self):
        graph = ImplicitFunction(
            lambda x, y: x * y ** 2 - x ** 2 * y - 2,
            color=YELLOW
        )
        self.add(NumberPlane(), graph)","Create a Manim scene that displays the implicit function graph defined by the equation x*y² - x²*y = 2, plotted over a number plane. The graph should be colored yellow. The scene should be static with no animations, simply showing both the number plane and the implicit function graph together."
"from manim import *

class PlotParametricFunction(Scene):
    def func(self, t):
        return (np.sin(2 * t), np.sin(3 * t), 0)

    def construct(self):
        func = ParametricFunction(self.func, t_range = (0, TAU), fill_opacity=0).set_color(RED)
        self.add(func.scale(3))",Create a Manim Python script that generates an animation scene showing a red parametric curve. The curve is defined by the parametric equations x = sin(2t) and y = sin(3t) evaluated from t = 0 to 2π (a full period). The curve should be scaled by a factor of 3 and displayed as an outline without any interior fill. The animation should show only the final static curve after full rendering.
"from manim import *

class ThreeDParametricSpring(ThreeDScene):
    def construct(self):
        curve1 = ParametricFunction(
            lambda u: (
                1.2 * np.cos(u),
                1.2 * np.sin(u),
                u * 0.05
            ), color=RED, t_range = (-3*TAU, 5*TAU, 0.01)
        ).set_shade_in_3d(True)
        axes = ThreeDAxes()
        self.add(axes, curve1)
        self.set_camera_orientation(phi=80 * DEGREES, theta=-60 * DEGREES)
        self.wait()","Create a 3D animation scene that displays a red helical spiral curve moving upward while rotating around the z-axis. The spiral should start below the xy-plane (due to its negative initial parameter range) and coil upward progressively with a consistent pitch. The x and y coordinates should form a circular path (radius 1.2 units) while the z-coordinate increases linearly as the parameter progresses. Include a 3D coordinate axis system in the scene. Set the camera perspective to a仰角 (phi) of 80 degrees and a azimuthal angle (theta) of -60 degrees to clearly show the spiral's 3D structure. The spiral should be shaded to enhance its three-dimensionality. The scene should render the static spiral and axes without additional transformations, ending with a brief pause."
"from manim import *

class DiscontinuousExample(Scene):
    def construct(self):
        ax1 = NumberPlane((-3, 3), (-4, 4))
        ax2 = NumberPlane((-3, 3), (-4, 4))
        VGroup(ax1, ax2).arrange()
        discontinuous_function = lambda x: (x ** 2 - 2) / (x ** 2 - 4)
        incorrect = ax1.plot(discontinuous_function, color=RED)
        correct = ax2.plot(
            discontinuous_function,
            discontinuities=[-2, 2],  # discontinuous points
            dt=0.1,  # left and right tolerance of discontinuity
            color=GREEN,
        )
        self.add(ax1, ax2, incorrect, correct)","Create a Manim animation scene showing two side-by-side graphs of the function f(x)=(x²-2)/(x²-4). The left graph (red) should plot the function without handling its discontinuities, while the right graph (green) must clearly show vertical asymptotes with breaks at x=-2 and x=2 using small gap tolerances. Both coordinate planes should be aligned horizontally to visually contrast correct/incorrect plotting of the function's discontinuities."
"from manim import *

class NumberLineExample(Scene):
    def construct(self):
        l0 = NumberLine(
            x_range=[-10, 10, 2],
            length=10,
            color=BLUE,
            include_numbers=True,
            label_direction=UP,
        )

        l1 = NumberLine(
            x_range=[-10, 10, 2],
            unit_size=0.5,
            numbers_with_elongated_ticks=[-2, 4],
            include_numbers=True,
            font_size=24,
        )
        num6 = l1.numbers[8]
        num6.set_color(RED)

        l2 = NumberLine(
            x_range=[-2.5, 2.5 + 0.5, 0.5],
            length=12,
            decimal_number_config={""num_decimal_places"": 2},
            include_numbers=True,
        )

        l3 = NumberLine(
            x_range=[-5, 5 + 1, 1],
            length=6,
            include_tip=True,
            include_numbers=True,
            rotation=10 * DEGREES,
        )

        line_group = VGroup(l0, l1, l2, l3).arrange(DOWN, buff=1)
        self.add(line_group)","Create an animation scene using Manim with four distinct horizontal NumberLine objects arranged vertically. The first line (topmost) is a blue line spanning -10 to 10 with ticks every 2 units, numbers displayed above the line. The second line below has the same numerical range (-10 to 10 with 2-unit steps) but shorter spacing (unit_size=0.5), thicker ticks at -2 and 4, smaller text (font size 24), and the number ""6"" colored red. The third line spans -2.5 to 3 with 0.5-unit steps, numbers shown with two decimal places (e.g., -2.50, 0.00). The fourth line is shortest, rotated 10 degrees, includes arrowtips at both ends, and ranges from -5 to 6 with 1-unit steps. Arrange all four lines vertically with 1 unit spacing between them, centered on the screen. Display them static without animation transitions."
"from manim import *

class BarChartExample(Scene):
    def construct(self):
        chart = BarChart(
            values=[-5, 40, -10, 20, -3],
            bar_names=[""one"", ""two"", ""three"", ""four"", ""five""],
            y_range=[-20, 50, 10],
            y_length=6,
            x_length=10,
            x_axis_config={""font_size"": 36},
        )

        c_bar_lbls = chart.get_bar_labels(font_size=48)

        self.add(chart, c_bar_lbls)","Create a Manim animation scene that displays a static bar chart with the following specifications: Five vertical bars representing the values [-5, 40, -10, 20, -3]. The bars must be horizontally labeled with ""one"", ""two"", ""three"", ""four"", and ""five"" along the x-axis. The y-axis should span from -20 to 50 with tick intervals of 10 units, and bars extend upward/downward proportionally to their values (allowing negative values to show downward bars). The chart's vertical (y-axis) size should occupy 6 units of height, while the horizontal (x-axis) spans 10 units. X-axis labels must be displayed in 36pt font. Each bar must have its numeric value clearly centered above/below the top of the bar in 48pt text. The complete chart and all labels must appear immediately without any animations, transitions, or movements."
"from manim import *

class ChangeBarValuesExample(Scene):
    def construct(self):
        values=[-10, -8, -6, -4, -2, 0, 2, 4, 6, 8, 10]

        chart = BarChart(
            values,
            y_range=[-10, 10, 2],
            y_axis_config={""font_size"": 24},
        )
        self.add(chart)

        chart.change_bar_values(list(reversed(values)))
        self.add(chart.get_bar_labels(font_size=24))","Design an animation using Manim where a vertical bar chart initially displays values -10, -8, -6, -4, -2, 0, 2, 4, 6, 8, 10 along a y-axis labeled from -10 to 10 in increments of 2 units. The y-axis labels must use a 24-point font size. The bars should then smoothly transform their heights to reflect the reversed list of values (now 10, 8, 6, 4, 2, 0, -2, -4, -6, -8, -10). After the transformation completes, numerical labels with a 24-point font size must appear on top of each bar, indicating the updated values corresponding to the reversed data."
"from manim import *

class GetBarLabelsExample(Scene):
    def construct(self):
        chart = BarChart(values=[10, 9, 8, 7, 6, 5, 4, 3, 2, 1], y_range=[0, 10, 1])

        c_bar_lbls = chart.get_bar_labels(
            color=WHITE, label_constructor=MathTex, font_size=36
        )

        self.add(chart, c_bar_lbls)","Create a Manim animation scene that displays a bar chart with 10 vertical bars where each bar's height corresponds to the values [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]. The y-axis should be labeled from 0 to 10 with increments of 1. Each bar must have a numerical label centered on top of it using LaTeX math text (MathTex), with white color and 36pt font size. The scene should initialize and display both the bar chart and the labels simultaneously without any animations or transitions."
"from manim import *

class ExampleSampleSpace(Scene):
    def construct(self):
        poly1 = SampleSpace(stroke_width=15, fill_opacity=1)
        poly2 = SampleSpace(width=5, height=3, stroke_width=5, fill_opacity=0.5)
        poly3 = SampleSpace(width=2, height=2, stroke_width=5, fill_opacity=0.1)
        poly3.divide_vertically(p_list=np.array([0.37, 0.13, 0.5]), colors=[BLACK, WHITE, GRAY], vect=RIGHT)
        poly_group = VGroup(poly1, poly2, poly3).arrange()
        self.add(poly_group)","Create a Manim animation scene showing three rectangles (SampleSpace objects) arranged in a group. The first rectangle has no stroke and fill completely (1.0 fill_opacity), with a thick black stroke (stroke_width=15). The second rectangle is 5 units wide and 3 units tall, with a stroke width of 5 and 50% fill opacity (fill_opacity=0.5). The third rectangle is a smaller 2x2 unit square, with stroke width 5 and 10% opacity (0.1 fill_opacity). 

The third rectangle must be divided vertically into **three regions** in proportions corresponding to probabilities [0.37, 0.13, 0.5], colored black (BLACK), white (WHITE), and gray (GRAY) respectively. The vertical division should use a division direction vector aligned to the right (using the ""RIGHT"" direction parameter). 

Finally, arrange all three rectangles side-by-side horizontally with spacing between them using a VGroup group and arrange() layout. Include code for proper initialization and rendering."
"from manim import *

class DarkThemeBanner(Scene):
    def construct(self):
        banner = ManimBanner()
        self.play(banner.create())
        self.play(banner.expand())
        self.wait()
        self.play(Unwrite(banner))","Design a Manim animation scene where a banner first appears by being drawn stroke-by-stroke, then scales up to full size, pauses briefly, and finally has its text erased line-by-line. Use the ManimBanner class with its built-in create(), expand(), and Unwrite() animations."
"from manim import *

class LightThemeBanner(Scene):
    def construct(self):
        self.camera.background_color = ""#ece6e2""
        banner = ManimBanner(dark_theme=False)
        self.play(banner.create())
        self.play(banner.expand())
        self.wait()
        self.play(Unwrite(banner))","Create an animation scene using Manim where a light-themed Manim banner appears. The banner should start as a small logo, expand to show full text and graphics, pause briefly, then fade away by unwriting its elements. Use a light background color (#ece6e2). Include smooth transition animations between each state change."
"from manim import *

class ExpandDirections(Scene):
    def construct(self):
        banners = [ManimBanner().scale(0.5).shift(UP*x) for x in [-2, 0, 2]]
        self.play(
            banners[0].expand(direction=""right""),
            banners[1].expand(direction=""center""),
            banners[2].expand(direction=""left""),
        )","Create a Manim animation scene where three scaled-down (50% size) Manim banners are arranged vertically: the first shifted 2 units downward (y=-2), the second centered (y=0), and the third shifted 2 units upward (y=2). Animate all three banners expanding simultaneously: the bottom banner expands to the right, the center banner expands outward from its center point, and the top banner expands to the left. Use the expand() method with the specific direction parameters (""right"", ""center"", ""left"") for each banner respectively."
"from manim import *

class MatrixExamples(Scene):
    def construct(self):
        m0 = Matrix([[""\\pi"", 0], [-1, 1]])
        m1 = IntegerMatrix([[1.5, 0.], [12, -1.3]],
            left_bracket=""("",
            right_bracket="")"")
        m2 = DecimalMatrix(
            [[3.456, 2.122], [33.2244, 12.33]],
            element_to_mobject_config={""num_decimal_places"": 2},
            left_bracket=r""\{"",
            right_bracket=r""\}"")
        m3 = MobjectMatrix(
            [[Circle().scale(0.3), Square().scale(0.3)],
            [MathTex(""\\pi"").scale(2), Star().scale(0.3)]],
            left_bracket=""\\langle"",
            right_bracket=""\\rangle"")
        g = Group(m0, m1, m2, m3).arrange_in_grid(buff=2)
        self.add(g)","""Create a Manim animation scene displaying four matrices arranged in a grid with 2 units of spacing between them. The first matrix (top-left) contains symbols and integers: π, 0, -1, and 1 within square brackets. The second matrix (next in grid) shows numerical values like 1.5, 0, 12, -1.3 in parentheses. The third matrix uses curly braces with decimals rounded to two places (e.g., 3.46, 2.12, 33.22, 12.33). The fourth matrix includes geometric shapes: a small circle, square, a large π symbol, and a star, enclosed by angle brackets. All matrices must be placed together in a grid layout with the described elements and formatting."""
"from manim import *

class DeterminantOfAMatrix(Scene):
    def construct(self):
        matrix = Matrix([
            [2, 0],
            [-1, 1]
        ])

        # scaling down the `det` string
        det = get_det_text(matrix,
                    determinant=3,
                    initial_scale_factor=1)

        # must add the matrix
        self.add(matrix)
        self.add(det)","Create a Manim Python class named ""DeterminantOfAMatrix"" that constructs a scene displaying a 2x2 matrix with entries [[2, 0], [-1, 1]]. Include the determinant value 3 positioned next to the matrix using the get_det_text function. Specify the initial_scale_factor parameter of get_det_text as 1. Add the matrix and determinant text directly to the scene without transitions or animations. Include all required imports and structure for the Scene class."
"from manim import *

class DecimalMatrixExample(Scene):
    def construct(self):
        m0 = DecimalMatrix(
            [[3.456, 2.122], [33.2244, 12]],
            element_to_mobject_config={""num_decimal_places"": 2},
            left_bracket=""\\{"",
            right_bracket=""\\}"")
        self.add(m0)","Create a Manim animation scene that displays a 2x2 decimal matrix with the following specifications:  
1. The matrix elements are [[3.456, 2.122], [33.2244, 12]]. Each number should be rounded and displayed to exactly **2 decimal places**.  
2. The matrix uses **curly braces** ( ""{"" and ""}"") as its left and right brackets instead of square or parentheses.  
3. The matrix should appear statically on the screen without any movement or transformation.  

Provide the Python code using the DecimalMatrix mobject to achieve this visual scene."
"from manim import *

class IntegerMatrixExample(Scene):
    def construct(self):
        m0 = IntegerMatrix(
            [[3.7, 2], [42.2, 12]],
            left_bracket=""("",
            right_bracket="")"")
        self.add(m0)","Please write a Manim scene that displays a 2x2 matrix with numerical entries 3.7, 2, 42.2, and 12. The matrix must use parentheses ( ) instead of square brackets as delimiters. Use the IntegerMatrix class, explicitly set the left_bracket to ""("" and right_bracket to "")"". The animation should show the matrix in a stationary state on the screen without any scaling, shifting, fading, or transformations. Include all code elements necessary for initialization within a Scene subclass and its construct method."
"from manim import *

class MatrixExamples(Scene):
    def construct(self):
        m0 = Matrix([[2, r""\pi""], [-1, 1]])
        m1 = Matrix([[2, 0, 4], [-1, 1, 5]],
            v_buff=1.3,
            h_buff=0.8,
            bracket_h_buff=SMALL_BUFF,
            bracket_v_buff=SMALL_BUFF,
            left_bracket=r""\{"",
            right_bracket=r""\}"")
        m1.add(SurroundingRectangle(m1.get_columns()[1]))
        m2 = Matrix([[2, 1], [-1, 3]],
            element_alignment_corner=UL,
            left_bracket=""("",
            right_bracket="")"")
        m3 = Matrix([[2, 1], [-1, 3]],
            left_bracket=r""\langle"",
            right_bracket=r""\rangle"")
        m4 = Matrix([[2, 1], [-1, 3]],
        ).set_column_colors(RED, GREEN)
        m5 = Matrix([[2, 1], [-1, 3]],
        ).set_row_colors(RED, GREEN)
        g = Group(
            m0,m1,m2,m3,m4,m5
        ).arrange_in_grid(buff=2)
        self.add(g)","Create a manim animation scene that displays six different matrix examples arranged in a grid. The first matrix (m0) is a 2x2 matrix with entries: top row [2, π], bottom row [-1, 1]. The second matrix (m1) shows a 2x3 matrix with entries [2, 0, 4] and [-1, 1, 5], using custom vertical spacing (v_buff=1.3) and horizontal spacing (h_buff=0.8), with curly braces { } as brackets. Highlight the middle column (columns indexed as 1) with a rectangular frame. The third matrix (m2) has entries 2/1 over -1/3 arranged in a 2x2 grid, with elements aligned to the top-left corner and surrounded by parentheses. The fourth matrix (m3) replicates m2's entries but uses angle brackets ⟨ and ⟩ as brackets. The fifth matrix (m4) copies m2's entries but colors columns red and green respectively. The sixth matrix (m5) matches m2's entries but colors the first row red and second row green. Position all matrices in a properly spaced grid layout on the screen."
"from manim import *

class BackgroundRectanglesExample(Scene):
    def construct(self):
        background= Rectangle().scale(3.2)
        background.set_fill(opacity=.5)
        background.set_color([TEAL, RED, YELLOW])
        self.add(background)
        m0 = Matrix([[12, -30], [-1, 15]],
            add_background_rectangles_to_entries=True)
        m1 = Matrix([[2, 0], [-1, 1]],
            include_background_rectangle=True)
        m2 = Matrix([[12, -30], [-1, 15]])
        g = Group(m0, m1, m2).arrange(buff=2)
        self.add(g)","Design a Manim animation scene that shows a gradient-filled rectangular background spanning the screen. The background should be large (scaled 3.2x), semi-transparent (50% opacity) with a gradual color transition from teal at the top, through red, to yellow at the bottom. On top of this background, display three matrices arranged horizontally. The first matrix must have small rectangular backgrounds behind each individual entry. The second matrix should have a single rectangular background behind the entire matrix. The third matrix must have no backgrounds at all. The three matrices should be spaced evenly with 2 units of distance between them."
"from manim import *

class GetBracketsExample(Scene):
    def construct(self):
        m0 = Matrix([[""\\pi"", 3], [1, 5]])
        bra = m0.get_brackets()
        colors = [BLUE, GREEN]
        for k in range(len(colors)):
            bra[k].set_color(colors[k])
        self.add(m0)","Create an animation using Manim showing a 2x2 matrix with elements π, 3, 1, and 5. The matrix must display its left bracket in blue and right bracket in green, with both brackets remaining stationary and visibly colored throughout the scene."
"from manim import *

class GetColumnsExample(Scene):
    def construct(self):
        m0 = Matrix([[r""\pi"", 3], [1, 5]])
        m0.add(SurroundingRectangle(m0.get_columns()[1]))
        self.add(m0)","Create a Manim scene that visually highlights the second column of a matrix. The matrix should display elements as follows: first row entries are symbol π (using LaTeX \pi) and 3, second row entries are 1 and 5. Show the second column (index 1) enclosed in a surrounding rectangle. Ensure the matrix and highlight are static elements displayed together in the scene."
"from manim import *

class GetEntriesExample(Scene):
    def construct(self):
        m0 = Matrix([[2, 3], [1, 5]])
        ent = m0.get_entries()
        colors = [BLUE, GREEN, YELLOW, RED]
        for k in range(len(colors)):
            ent[k].set_color(colors[k])
        self.add(m0)","Create a Manim Python code for an animation scene showing a 2x2 matrix with entries [[2, 3], [1, 5]]. Each numerical entry must be individually colored using the colors blue, green, yellow, and red in the order they appear in the matrix (top-left entry is blue, top-right green, bottom-left yellow, bottom-right red). The colors should be applied by first retrieving all matrix entries as individual elements and looping through them, then assigning each with the corresponding color from the provided list. The final display should show the colored matrix without any movement or transformations."
"from manim import *

class GetRowsExample(Scene):
    def construct(self):
        m0 = Matrix([[""\\pi"", 3], [1, 5]])
        m0.add(SurroundingRectangle(m0.get_rows()[1]))
        self.add(m0)","Design a Manim animation scene showing a 2x2 matrix. The first row of the matrix contains the elements π and 3, while the second row has 1 and 5. The second row must be highlighted using a surrounding rectangle. The scene should present this arrangement without any movements or animated transitions."
"from manim import *

class SetColumnColorsExample(Scene):
    def construct(self):
        m0 = Matrix([[""\\pi"", 1], [-1, 3]],
        ).set_column_colors([RED,BLUE], GREEN)
        self.add(m0)","Design a Manim animation scene that displays a 2x2 matrix with the following entries: the first column contains π and -1, while the second column contains 1 and 3. The columns are styled using the Matrix.set_column_colors method with parameters ( [RED, BLUE], GREEN ), ensuring the method call directly matches this syntax for color application."
"from manim import *

class SetRowColorsExample(Scene):
    def construct(self):
        m0 = Matrix([[""\\pi"", 1], [-1, 3]],
        ).set_row_colors([RED,BLUE], GREEN)
        self.add(m0)","Write Manim code to create an animation scene that displays a 2x2 matrix with the following specifications:  
1. The matrix entries are:  
   - First row: π (represented as ""\\pi"") and 1  
   - Second row: -1 and 3  
2. The first row is colored **RED**, and the second row is colored **BLUE**.  
3. The background grid (matrix rectangle) of the entire matrix is colored **GREEN**.  
4. The matrix should be statically displayed without any movement or additional transformations.  

Include the necessary Manim imports, class definition, and scene construction logic. Use `set_row_colors` method to apply the row and background colors correctly."
"from manim import *

class MobjectMatrixExample(Scene):
    def construct(self):
        a = Circle().scale(0.3)
        b = Square().scale(0.3)
        c = MathTex(""\\pi"").scale(2)
        d = Star().scale(0.3)
        m0 = MobjectMatrix([[a, b], [c, d]])
        self.add(m0)","Create a Manim animation scene where the following elements are displayed in a 2x2 grid: a small circle (scaled 0.3), a small square (scaled 0.3), the Greek letter π (scaled to size 2), and a small star (scaled 0.3). The first row of the grid should contain the circle and square, while the second row should have the π symbol and star. Display this matrix arrangement on the screen."
"from manim import *

class CircleWithContent(VGroup):
    def __init__(self, content):
        super().__init__()
        self.circle = Circle()
        self.content = content
        self.add(self.circle, content)
        content.move_to(self.circle.get_center())

    def clear_content(self):
        self.remove(self.content)
        self.content = None

    @override_animate(clear_content)
    def _clear_content_animation(self, anim_args=None):
        if anim_args is None:
            anim_args = {}
        anim = Uncreate(self.content, **anim_args)
        self.clear_content()
        return anim

class AnimationOverrideExample(Scene):
    def construct(self):
        t = Text(""hello!"")
        my_mobject = CircleWithContent(t)
        self.play(Create(my_mobject))
        self.play(my_mobject.animate.clear_content())
        self.wait()","Create an animation using Manim where a circle initially contains the text ""hello!"". The scene should first display the circle with the text centered inside. Then, the text must disappear with an explicit animation (not just removal) while leaving the circle intact. Specify the use of a custom composite object class that combines a circle and content. Include methods for content removal with animation override, showing the text being uncreated while preserving the circle's position. The animation sequence should include: 1) creating the circle-text combination, 2) animating the text’s disappearance via its own uncreation animation, and 3) ending with the empty circle remaining on screen."
"from manim import *

class NextToUpdater(Scene):
    def construct(self):
        def dot_position(mobject):
            mobject.set_value(dot.get_center()[0])
            mobject.next_to(dot)

        dot = Dot(RIGHT*3)
        label = DecimalNumber()
        label.add_updater(dot_position)
        self.add(dot, label)

        self.play(Rotating(dot, about_point=ORIGIN, angle=TAU, run_time=TAU, rate_func=linear))","""Create an animation where a dot starts at the far right of the screen and rotates around the center point in a full 360-degree circular path at a constant speed. During the rotation, a decimal number label must dynamically display the current x-coordinate of the dot and remain positioned directly next to it at all times. The label's numerical value and its position must update smoothly and continuously as the dot moves along its circular trajectory without any lag or interruption."""
"from manim import *

class DtUpdater(Scene):
    def construct(self):
        square = Square()

        #Let the square rotate 90° per second
        square.add_updater(lambda mobject, dt: mobject.rotate(dt*90*DEGREES))
        self.add(square)
        self.wait(2)","Create a Manim Python script for an animation where a square continuously rotates at a rate of 90 degrees per second. The rotation must be implemented using an updater function that uses the time delta (dt) parameter to ensure a smooth and accurate rotational speed. The animation should run for exactly 2 seconds. Specify the full code including scene structure, imports, and comments explaining the rotation mechanism and timing."
"from manim import *

class AnimateExample(Scene):
    def construct(self):
        s = Square()
        self.play(Create(s))
        self.play(s.animate.shift(RIGHT))
        self.play(s.animate.scale(2))
        self.play(s.animate.rotate(PI / 2))
        self.play(Uncreate(s))","Create a Manim animation scene that shows a square undergoing the following transformations in sequence: first, the square is drawn onto the screen. Next, it smoothly shifts to the right. Then, it enlarges to twice its original size. After that, it rotates 90 degrees clockwise. Finally, it dissipates from the screen. Each transformation should occur as a separate animated step with clear transitions between them."
"from manim import *

class AnimateChainExample(Scene):
    def construct(self):
        s = Square()
        self.play(Create(s))
        self.play(s.animate.shift(RIGHT).scale(2).rotate(PI / 2))
        self.play(Uncreate(s))","Create a Manim animation scene with the following sequence: 
1. A square is drawn onto the screen. 
2. The square simultaneously moves to the right, scales up to twice its size, and rotates 90 degrees. 
3. The square is then completely undrawn. Include all transformation parameters and simultaneity of movements in the animation code."
"from manim import *

class AnimateWithArgsExample(Scene):
    def construct(self):
        s = Square()
        c = Circle()

        VGroup(s, c).arrange(RIGHT, buff=2)
        self.add(s, c)

        self.play(
            s.animate(run_time=2).rotate(PI / 2),
            c.animate(rate_func=there_and_back).shift(RIGHT),
        )","Create a Manim animation scene where: 1) A square and circle are initially displayed side by side with 2 units of space between them. 2) The square rotates 180 degrees (π/2 radians) over 2 seconds while the circle simultaneously moves to the right and back to its original position using the ""there_and_back"" rate function. Both animations should occur simultaneously in parallel."
"from manim import *

class ApplyFuncExample(Scene):
    def construct(self):
        circ = Circle().scale(1.5)
        circ_ref = circ.copy()
        circ.apply_complex_function(
            lambda x: np.exp(x*1j)
        )
        t = ValueTracker(0)
        circ.add_updater(
            lambda x: x.become(circ_ref.copy().apply_complex_function(
                lambda x: np.exp(x+t.get_value()*1j)
            )).set_color(BLUE)
        )
        self.add(circ_ref)
        self.play(TransformFromCopy(circ_ref, circ))
        self.play(t.animate.set_value(TAU), run_time=3)","Design a Manim animation scene that shows a circle initially displayed as a static reference. Create a second circle that first appears via a TransformFromCopy from the reference, then begins continuously spinning in place. The spinning motion is generated by applying an exponential complex function which incorporates an angle parameter. This angle starts at 0 and increases to 2π (TAU) over 3 seconds, driving the rotation. The rotating circle must stay blue during its motion. The animation should first show the static reference circle. Then transition via TransformFromCopy to initiate the rotating circle, followed by a smooth full rotation cycle as the parameter reaches TAU. Use a ValueTracker for the angle parameter, ensuring the rotation updates dynamically linked to the tracker's value while the reference remains static. The rotation should follow the complex function's transformation for smooth animation, completing a full cycle over 3 seconds."
"from manim import *

class Example(Scene):
    def construct(self):
        s1 = Square()
        s2 = Square()
        s3 = Square()
        s4 = Square()
        x = VGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.0)
        self.add(x)","Write a Python code using Manim library to create an animation scene where four squares are arranged in a horizontal row, equally spaced with 1 unit distance between their centers. The entire group of squares should be centered horizontally on the screen. The code should construct this arrangement using a VGroup to group all squares, apply the set_x(0) positioning, and use the arrange() method with specified buffer. No animations or transformations beyond the initial setup are required."
"from manim import *

class ExampleBoxes(Scene):
    def construct(self):
        boxes=VGroup(*[Square() for s in range(0,6)])
        boxes.arrange_in_grid(rows=2, buff=0.1)
        self.add(boxes)","Create a Manim animation scene that starts with six squares arranged in a 2-row grid layout with a small spacing of 0.1 units between each square. The squares should be grouped together as a single VGroup and displayed statically on the screen. The grid should have 2 rows, and the squares must be evenly spaced with no movements or transformations after appearing. The scene class should be named ""ExampleBoxes""."
"from manim import *

class ArrangeInGrid(Scene):
    def construct(self):
        boxes = VGroup(*[
            Rectangle(WHITE, 0.5, 0.5).add(Text(str(i+1)).scale(0.5))
            for i in range(24)
        ])
        self.add(boxes)

        boxes.arrange_in_grid(
            buff=(0.25,0.5),
            col_alignments=""lccccr"",
            row_alignments=""uccd"",
            col_widths=[1, *[None]*4, 1],
            row_heights=[1, None, None, 1],
            flow_order=""dr""
        )","Create an animation showing 24 boxes arranged in a grid with specific formatting. Each box contains a numbered text from 1 to 24 centered inside. The grid should have columns left-aligned, then four centered columns, and right-aligned last column. Rows should be top-aligned, two centered middle rows, and bottom-aligned last row. Column widths: first and last columns fixed width 1, others auto-sized. Row heights: first and last rows fixed height 1, middle rows auto-sized. Use vertical and horizontal buffers of 0.25 and 0.5 respectively. The boxes should be arranged in a ""down then right"" flow order. The boxes and text must scale appropriately to maintain proportions within the grid layout."
"from manim import *

class ArrangeSumobjectsExample(Scene):
    def construct(self):
        s= VGroup(*[Dot().shift(i*0.1*RIGHT*np.random.uniform(-1,1)+UP*np.random.uniform(-1,1)) for i in range(0,15)])
        s.shift(UP).set_color(BLUE)
        s2= s.copy().set_color(RED)
        s2.arrange_submobjects()
        s2.shift(DOWN)
        self.add(s,s2)","""Create an animation of two groups of 15 dots in Manim. The first group (blue) should display scattered dots arranged randomly in a cluster, slightly shifted upwards. The second group (red) must be an exact copy of the first, but rearranged into straight horizontal lineup using arrange_submobjects(), positioned below the original. Both groups should appear simultaneously on screen with clear vertical separation."""
"from manim import *

class BecomeScene(Scene):
    def construct(self):
        circ = Circle(fill_color=RED, fill_opacity=0.8)
        square = Square(fill_color=BLUE, fill_opacity=0.2)
        self.add(circ)
        self.wait(0.5)
        circ.become(square)
        self.wait(0.5)","Create a Manim animation that starts by displaying a red-filled circle (opacity 0.8). After 0.5 seconds, the circle instantly transforms into a blue-filled square (opacity 0.2) in its place. The scene pauses for an additional 0.5 seconds after the transformation before ending. Use the ""become"" method to replace the circle with the square, ensuring smooth visual replacement without intermediate animation steps."
"from manim import *

class FlipExample(Scene):
    def construct(self):
        s= Line(LEFT, RIGHT+UP).shift(4*LEFT)
        self.add(s)
        s2= s.copy().flip()
        self.add(s2)","Create a Manim animation scene where a line is initially positioned 4 units to the left of its default position. Then, generate a second line by copying and flipping the original line using the flip() method. Both the original and flipped line must be displayed simultaneously in the scene."
"from manim import *

class AngleMidPoint(Scene):
    def construct(self):
        line1 = Line(ORIGIN, 2*RIGHT)
        line2 = Line(ORIGIN, 2*RIGHT).rotate_about_origin(80*DEGREES)

        a = Angle(line1, line2, radius=1.5, other_angle=False)
        d = Dot(a.get_midpoint()).set_color(RED)

        self.add(line1, line2, a, d)
        self.wait()","Create a Manim animation scene showing two straight lines originating from the same point. The first line is horizontal, extending 2 units to the right. The second line starts at the same origin and is rotated 80 degrees upward from the first. An angle arc should be drawn between the two lines with a radius of 1.5 units, indicating the angle between them. Place a red dot precisely at the midpoint position along this angle arc. All elements must remain stationary once displayed."
"from manim import *

class HeightExample(Scene):
    def construct(self):
        decimal = DecimalNumber().to_edge(UP)
        rect = Rectangle(color=BLUE)
        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)

        decimal.add_updater(lambda d: d.set_value(rect.height))

        self.add(rect_copy, rect, decimal)
        self.play(rect.animate.set(height=5))
        self.wait()","Generate Manim code for an animation scene that includes the following visual elements and actions:  
1. A gray semi-transparent rectangle (opacity 0.5) displayed as a static reference at the scene's starting position.  
2. A blue rectangle initially overlapping the gray rectangle, which dynamically resizes vertically to a height of 5 units.  
3. A decimal number displayed at the top of the screen that real-time updates its value to show the current height of the blue rectangle during its transformation.  
4. The animation should first show both rectangles overlapping, then play the vertical expansion of the blue rectangle while the decimal number updates, and finally pause briefly to display the final state."
"from manim import *

class DotInterpolation(Scene):
    def construct(self):
        dotR = Dot(color=DARK_GREY)
        dotR.shift(2 * RIGHT)
        dotL = Dot(color=WHITE)
        dotL.shift(2 * LEFT)

        dotMiddle = VMobject().interpolate(dotL, dotR, alpha=0.3)

        self.add(dotL, dotR, dotMiddle)",Create a Manim animation scene featuring three dots. Position a dark grey dot 2 units to the right and a white dot 2 units to the left. Create a third dot by interpolating the positions of the left and right dots with an alpha value of 0.3 (30% towards the right dot from the left). Display all three dots simultaneously in the scene without any movement or transitions.
"from manim import *

class InvertSumobjectsExample(Scene):
    def construct(self):
        s = VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])
        s2 = s.copy()
        s2.invert()
        s2.shift(DOWN)
        self.play(Write(s), Write(s2))","""Create a Manim animation showing two horizontal rows of small dots. The top row displays dots evenly spaced horizontally from left to right, while the bottom row (positioned below) shows the dots in reverse order. Both rows must be displayed simultaneously using the Write animation, maintaining consistent 0.1-unit spacing between adjacent dots in each row."""
"from manim import *

class MatchPointsScene(Scene):
    def construct(self):
        circ = Circle(fill_color=RED, fill_opacity=0.8)
        square = Square(fill_color=BLUE, fill_opacity=0.2)
        self.add(circ)
        self.wait(0.5)
        self.play(circ.animate.match_points(square))
        self.wait(0.5)","Design a Manim animation scene where a red, solid-filled circle (fill_opacity 0.8) appears first. After 0.5 seconds, the circle smoothly transitions into a translucent blue square (fill_opacity 0.2) by exactly matching its points. The transition should use Manim's match_points animation. After completing the shape change, the final square remains visible for an additional half-second before the scene ends. Specify timing pauses and object properties clearly in the code."
"from manim import *

class GeometricShapes(Scene):
    def construct(self):
        d = Dot()
        c = Circle()
        s = Square()
        t = Triangle()
        d.next_to(c, RIGHT)
        s.next_to(c, LEFT)
        t.next_to(c, DOWN)
        self.add(d, c, s, t)","Create a Manim animation scene that displays a Circle at the center of the screen. Position a Dot to the right of the Circle, a Square to the left of the Circle, and a Triangle below the Circle. All four shapes (Dot, Circle, Square, Triangle) should be visible on the screen simultaneously without overlapping, arranged in a cross formation relative to the central Circle. Describe their initial positions and any required spatial relationships for precise alignment."
"from manim import *

class MobjectScaleExample(Scene):
    def construct(self):
        f1 = Text(""F"")
        f2 = Text(""F"").scale(2)
        f3 = Text(""F"").scale(0.5)
        f4 = Text(""F"").scale(-1)

        vgroup = VGroup(f1, f2, f3, f4).arrange(6 * RIGHT)
        self.add(vgroup)","""Create a Manim scene that displays four 'F' text elements with varying scales. The first 'F' should maintain its default size. The second 'F' must be scaled up by a factor of 2, the third should be scaled down to 50% size, and the fourth 'F' must be inverted in orientation using a -1 scale factor. Arrange all four elements horizontally in a single row spaced using an explicit 6*RIGHT parameter within a VGroup's arrange() method. Include all elements in the scene without any animation transitions."""
"from manim import *

config.background_color = WHITE

class ChangedDefaultTextcolor(Scene):
    def construct(self):
        Text.set_default(color=BLACK)
        self.add(Text(""Changing default values is easy!""))

        # we revert the colour back to the default to prevent a bug in the docs.
        Text.set_default(color=WHITE)","Create a Manim animation scene that displays the text ""Changing default values is easy!"" in black color on a white background. The text's default color should first be temporarily changed to black using Manim's default settings method, then immediately reverted to white after adding the text to the scene. The animation should not include any movements or transformations beyond the initial display of the text. Provide the complete Python code using Manim's latest library syntax."
"from manim import *

class SetZIndex(Scene):
    def construct(self):
        text = Text('z_index = 3', color = PURE_RED).shift(UP).set_z_index(3)
        square = Square(2, fill_opacity=1).set_z_index(2)
        tex = Tex(r'zIndex = 1', color = PURE_BLUE).shift(DOWN).set_z_index(1)
        circle = Circle(radius = 1.7, color = GREEN, fill_opacity = 1) # z_index = 0

        # Displaying order is now defined by z_index values
        self.add(text)
        self.add(square)
        self.add(tex)
        self.add(circle)","Create a Manim animation scene demonstrating the z-index layering effect with four visual elements. The scene should include the following elements with specified properties and stacking order determined by z-index values:

1. A red text saying ""z_index = 3"" positioned at the top (shifted UP) with z-index 3.
2. A filled green square (radius/side size 2) with z-index 2 positioned behind the red text but in front of the blue TEX.
3. A blue TEX/math text displaying ""zIndex = 1"" positioned at the bottom (shifted DOWN) with z-index 1.
4. A filled green circle (radius 1.7) with default z-index 0 at the lowest layer.

The elements must be drawn in the order: red text first, then square, then blue TEX, then circle (via self.add sequence). However, their final visual stacking should prioritize z-index values over the drawing order, showing the red text (z=3) on top, followed by square (z=2), blue TEX (z=1), and circle (z=0) at the bottom. Maintain accurate color specifications (PURE_RED, PURE_BLUE, GREEN) and positions as specified."
"from manim import *

class ShuffleSubmobjectsExample(Scene):
    def construct(self):
        s= VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])
        s2= s.copy()
        s2.shuffle_submobjects()
        s2.shift(DOWN)
        self.play(Write(s), Write(s2))","Create a Manim scene that animates two rows of dots. The top row should be a horizontal line of evenly spaced dots. The bottom row must be an identical copy of the top row, but with its submobjects randomly shuffled in arrangement while remaining in the same overall horizontal line. Both rows should be displayed using the Write animation simultaneously. The bottom row should be positioned directly below the top row with a consistent vertical offset."
"from manim import *

class ToCornerExample(Scene):
    def construct(self):
        c = Circle()
        c.to_corner(UR)
        t = Tex(""To the corner!"")
        t2 = MathTex(""x^3"").shift(DOWN)
        self.add(c,t,t2)
        t.to_corner(DL, buff=0)
        t2.to_corner(UL, buff=1.5)","Create an animation scene where three elements are displayed and positioned as follows visually: a circle settles exactly in the upper-right corner. The phrase ""To the corner!"" starts centered but slides to the very edge of the lower-left corner with zero spacing. The mathematical expression x³ begins slightly shifted downward from center but ends positioned in the upper-left corner with a 1.5-unit margin from the top-left edge. All elements must be displayed simultaneously, with final positions fixed by explicit corner alignments."
"from manim import *

class ToEdgeExample(Scene):
    def construct(self):
        tex_top = Tex(""I am at the top!"")
        tex_top.to_edge(UP)
        tex_side = Tex(""I am moving to the side!"")
        c = Circle().shift(2*DOWN)
        self.add(tex_top, tex_side, c)
        tex_side.to_edge(LEFT)
        c.to_edge(RIGHT, buff=0)","Create a Manim animation scene with three elements: ""I am at the top!"" positioned at the top edge of the screen, ""I am moving to the side!"" placed at the left edge, and a circle positioned at the right edge with zero buffer. The elements should appear simultaneously in their respective edge positions from the start of the scene."
"from manim import *

class WidthExample(Scene):
    def construct(self):
        decimal = DecimalNumber().to_edge(UP)
        rect = Rectangle(color=BLUE)
        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)

        decimal.add_updater(lambda d: d.set_value(rect.width))

        self.add(rect_copy, rect, decimal)
        self.play(rect.animate.set(width=7))
        self.wait()","Create a Manim animation scene demonstrating the width change of a rectangle with real-time numerical feedback. The scene must contain: 1) A blue rectangle and a gray semi-transparent copy of it positioned underneath, 2) A decimal number displayed at the top of the screen that dynamically updates to show the current width value of the main rectangle, 3) An animation where the blue rectangle smoothly expands horizontally from its default size to a width of 7 units while maintaining its center position, and 4) The gray copy must remain stationary as the original rectangle animates. Include all visual element properties (colors, transparency, positioning) and specify that the numerical value must continuously reflect the live width measurement throughout the transformation."
"from manim import *

class ArcBraceExample(Scene):
    def construct(self):
        arc_1 = Arc(radius=1.5,start_angle=0,angle=2*PI/3).set_color(RED)
        brace_1 = ArcBrace(arc_1,LEFT)
        group_1 = VGroup(arc_1,brace_1)

        arc_2 = Arc(radius=3,start_angle=0,angle=5*PI/6).set_color(YELLOW)
        brace_2 = ArcBrace(arc_2)
        group_2 = VGroup(arc_2,brace_2)

        arc_3 = Arc(radius=0.5,start_angle=-0,angle=PI).set_color(BLUE)
        brace_3 = ArcBrace(arc_3)
        group_3 = VGroup(arc_3,brace_3)

        arc_4 = Arc(radius=0.2,start_angle=0,angle=3*PI/2).set_color(GREEN)
        brace_4 = ArcBrace(arc_4)
        group_4 = VGroup(arc_4,brace_4)

        arc_group = VGroup(group_1, group_2, group_3, group_4).arrange_in_grid(buff=1.5)
        self.add(arc_group.center())","Create a Manim animation scene that displays four arcs with their corresponding arc-shaped braces arranged in a grid layout. The first arc is radius 1.5, 120 degrees (angle 2π/3), colored red with the brace on the left side. The second is radius 3, 150 degrees (5π/6), yellow with default brace placement. The third is a semicircle (π radians) of radius 0.5, blue, and the fourth is a 270-degree (3π/2) arc of radius 0.2, green. All elements should be grouped such that each arc and its brace form a sub-group. Arrange all four sub-groups in evenly spaced grid positions and center the entire arrangement on the screen."
"from manim import *

class BraceExample(Scene):
    def construct(self):
        s = Square()
        self.add(s)
        for i in np.linspace(0.1,1.0,4):
            br = Brace(s, sharpness=i)
            t = Text(f""sharpness= {i}"").next_to(br, RIGHT)
            self.add(t)
            self.add(br)
        VGroup(*self.mobjects).arrange(DOWN, buff=0.2)","""Create a Manim animation that starts with a square on the screen. Iterate over four sharpness values from 0.1 to 1.0 (inclusive) divided into four equal intervals. For each value: draw a brace around the square using the current sharpness, add a text label to the right of each brace showing its sharpness value. Finally, arrange all components—the square, all braces, and their corresponding text labels—vertically downward with a 0.2 spacing between them. Use the Manim Brace, Text, and VGroup arrangment methods."""
"from manim import *

class BraceBPExample(Scene):
    def construct(self):
        p1 = [0,0,0]
        p2 = [1,2,0]
        brace = BraceBetweenPoints(p1,p2)
        self.play(Create(NumberPlane()))
        self.play(Create(brace))
        self.wait(2)","Write a Manim Python program that creates an animation scene. First, a number plane is displayed using a Create animation. Next, a brace appears between the exact points (0,0,0) and (1,2,0). After the brace appears, it must stay visible for 2 seconds. The scene must be named BraceBPExample and follow these precise steps: show the number plane, then the brace between those specific coordinates, then pause on the final frame for two seconds. Include all required class definitions and imports for execution."
"from manim import *

class TableExamples(Scene):
    def construct(self):
        t0 = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")],
            top_left_entry=Text(""TOP""))
        t0.add_highlighted_cell((2,2), color=GREEN)
        x_vals = np.linspace(-2,2,5)
        y_vals = np.exp(x_vals)
        t1 = DecimalTable(
            [x_vals, y_vals],
            row_labels=[MathTex(""x""), MathTex(""f(x)"")],
            include_outer_lines=True)
        t1.add(t1.get_cell((2,2), color=RED))
        t2 = MathTable(
            [[""+"", 0, 5, 10],
            [0, 0, 5, 10],
            [2, 2, 7, 12],
            [4, 4, 9, 14]],
            include_outer_lines=True)
        t2.get_horizontal_lines()[:3].set_color(BLUE)
        t2.get_vertical_lines()[:3].set_color(BLUE)
        t2.get_horizontal_lines()[:3].set_z_index(1)
        cross = VGroup(
            Line(UP + LEFT, DOWN + RIGHT),
            Line(UP + RIGHT, DOWN + LEFT))
        a = Circle().set_color(RED).scale(0.5)
        b = cross.set_color(BLUE).scale(0.5)
        t3 = MobjectTable(
            [[a.copy(),b.copy(),a.copy()],
            [b.copy(),a.copy(),a.copy()],
            [a.copy(),b.copy(),b.copy()]])
        t3.add(Line(
            t3.get_corner(DL), t3.get_corner(UR)
        ).set_color(RED))
        vals = np.arange(1,21).reshape(5,4)
        t4 = IntegerTable(
            vals,
            include_outer_lines=True
        )
        g1 = Group(t0, t1).scale(0.5).arrange(buff=1).to_edge(UP, buff=1)
        g2 = Group(t2, t3, t4).scale(0.5).arrange(buff=1).to_edge(DOWN, buff=1)
        self.add(g1, g2)","""Design a Manim animation scene named 'TableExamples' that displays several tables arranged into two main groups on opposite edges of the screen, with precise styling and positions as follows:

- **First Table (top-left in top group):**
  This table has:
  - 2 main data rows with labels 'R1' (first row) and 'R2' (second row),
  - 2 column labels 'C1' and 'C2'.
  - The top-left cell (where row and column headers meet) contains the text ""TOP"".
  - Highlight the cell at row index 2, column 2 with green color.

- **Second Table (top group's second table:**
  A DecimalTable with two columns displaying data in 5 rows (for x values from -2 to 2 in regular intervals, and their exponential results. Row headers are 'x' and 'f(x)'. The second table should show the computed values. The cell at position (2,2) is outlined in red.

- **Third Table (bottom side's first element) a 4x4 MathTable filled with the entries:
  Row 1 headers [+ , 0, 5, 10]
  Row 2: 0,0,5,10
  Row 3:2,2,7,12
  Row 4:4,4,9,14
  Styling: The first three horizontal lines (horizontal lines between the first three rows) and first three vertical lines (seperating first three columns) are colored blue. The horizontal lines have a higher layer (z_index 1) to be in front.

- **Fourth Element (middle of bottom group):**
  A 3x3 grid (MobjectTable) alternating between red circles and blue crosses. The cells are arranged as:
  - First row: red circle, blue cross, red circle;
  - Second row: blue cross, red circle, red circle;
  - Third row: red circle, blue cross, blue cross.
  Add a red line from its bottom-left corner to the top-right corner (diagonal from DL to UR).

- **Fifth Element (last of the bottom group):**
  A 5-row by 4-column IntegerTable displaying numbers 1 to 20 arranged in row-wise order. Include outer borders.

Arrange the first two elements (tables) in the top half, scaled to 50% of their original size, arranged next to each other with space, and placed at the top edge. The bottom three elements are arranged in the bottom half, similarly sized and spaced, at the bottom edge.

Highlight all specified cells with the colors described. Ensure all tables in the bottom group are appropriately colored, including the z-index settings for the MathTable's lines.""
"
"from manim import *

class DecimalTableExample(Scene):
    def construct(self):
        x_vals = [-2,-1,0,1,2]
        y_vals = np.exp(x_vals)
        t0 = DecimalTable(
            [x_vals, y_vals],
            row_labels=[MathTex(""x""), MathTex(""f(x)=e^{x}"")],
            h_buff=1,
            element_to_mobject_config={""num_decimal_places"": 2})
        self.add(t0)","Create a Manim animation scene that displays a table containing two rows of numerical values. The top row should label ""x"" and show integer values -2, -1, 0, 1, 2. The bottom row should label ""f(x)=e^{x}"" and show corresponding exponential calculations of the x values (e^{-2} to e^{2}), formatted to 2 decimal places. The table columns should be horizontally aligned with consistent spacing between each numerical entry. The row labels must appear vertically on the left side of the table. The table should appear as a static element without any animations, transformations or motion."
"from manim import *

class IntegerTableExample(Scene):
    def construct(self):
        t0 = IntegerTable(
            [[0,30,45,60,90],
            [90,60,45,30,0]],
            col_labels=[
                MathTex(r""\frac{\sqrt{0}}{2}""),
                MathTex(r""\frac{\sqrt{1}}{2}""),
                MathTex(r""\frac{\sqrt{2}}{2}""),
                MathTex(r""\frac{\sqrt{3}}{2}""),
                MathTex(r""\frac{\sqrt{4}}{2}"")],
            row_labels=[MathTex(r""\sin""), MathTex(r""\cos"")],
            h_buff=1,
            element_to_mobject_config={""unit"": r""^{\circ}""})
        self.add(t0)","Create a Manim Python code for an animation scene that displays an integer table with the following specifics: The table has two rows of numerical data - first row: [0, 30, 45, 60, 90], second row: [90, 60, 45, 30, 0]. The column headers must be mathematical expressions: for each column, the label should be a fraction with numerator √0/2, √1/2, √2/2, √3/2, and √4/2 (using LaTeX). The row headers on the left should be labeled ""sin"" (first row) and ""cos"" (second row). Each numerical value in the table must display with a degree symbol (°) as a superscript. The horizontal spacing between columns (h_buff) should be set to 1. Use IntegerTable class with proper col_labels, row_labels, and configuration for degree symbols."
"from manim import *

class MathTableExample(Scene):
    def construct(self):
        t0 = MathTable(
            [[""+"", 0, 5, 10],
            [0, 0, 5, 10],
            [2, 2, 7, 12],
            [4, 4, 9, 14]],
            include_outer_lines=True)
        self.add(t0)","Create a Manim animation scene that displays a static mathematical table with four rows and four columns. The table should have the following contents:  
- First row: ""+"", 0, 5, 10  
- Second row: 0, 0, 5, 10  
- Third row: 2, 2, 7, 12  
- Fourth row: 4, 4, 9, 14  
Include outer borders around the entire table. The table should appear immediately without any animation transitions or movements."
"from manim import *

class MobjectTableExample(Scene):
    def construct(self):
        cross = VGroup(
            Line(UP + LEFT, DOWN + RIGHT),
            Line(UP + RIGHT, DOWN + LEFT),
        )
        a = Circle().set_color(RED).scale(0.5)
        b = cross.set_color(BLUE).scale(0.5)
        t0 = MobjectTable(
            [[a.copy(),b.copy(),a.copy()],
            [b.copy(),a.copy(),a.copy()],
            [a.copy(),b.copy(),b.copy()]]
        )
        line = Line(
            t0.get_corner(DL), t0.get_corner(UR)
        ).set_color(RED)
        self.add(t0, line)","Create an animation scene using Manim library with the following visual elements and configurations:

1. A 3x3 grid (MobjectTable) consisting of alternating red circles and blue crosses. The arrangement should follow this pattern:
   - Row 1: Red circle, Blue cross, Red circle
   - Row 2: Blue cross, Red circle, Red circle
   - Row 3: Red circle, Blue cross, Blue cross

2. All shapes (circles and crosses) are scaled to 50% of their default size.

3. The blue crosses are constructed from two diagonal intersecting lines forming an 'X' shape.

4. A thick red line must be drawn diagonally from the bottom-left corner to the top-right corner of the grid.

5. Both the grid and the diagonal line must be displayed simultaneously in the scene. Ensure the grid elements are arranged in centered formation with proper spacing between cells."
"from manim import *

class TableExamples(Scene):
    def construct(self):
        t0 = Table(
            [[""This"", ""is a""],
            [""simple"", ""Table in \\n Manim.""]])
        t1 = Table(
            [[""This"", ""is a""],
            [""simple"", ""Table.""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        t1.add_highlighted_cell((2,2), color=YELLOW)
        t2 = Table(
            [[""This"", ""is a""],
            [""simple"", ""Table.""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")],
            top_left_entry=Star().scale(0.3),
            include_outer_lines=True,
            arrange_in_grid_config={""cell_alignment"": RIGHT})
        t2.add(t2.get_cell((2,2), color=RED))
        t3 = Table(
            [[""This"", ""is a""],
            [""simple"", ""Table.""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")],
            top_left_entry=Star().scale(0.3),
            include_outer_lines=True,
            line_config={""stroke_width"": 1, ""color"": YELLOW})
        t3.remove(*t3.get_vertical_lines())
        g = Group(
            t0,t1,t2,t3
        ).scale(0.7).arrange_in_grid(buff=1)
        self.add(g)","Create an animation scene in Manim with four different table examples displayed in a grid layout. The first table should be a basic 2x2 table showing the text (""This"", ""is a"") in the first row and (""simple"", ""Table in \n Manim"") in the second row. The second table must include row labels (R1/R2) and column labels (C1/C2), with the cell at position (2,2) highlighted in yellow. The third table should feature a small star as its top-left entry, have right-aligned text in cells, include outer table borders, and mark the (2,2) cell with a red border. The fourth table requires yellow-stroked lines (thinner than default), removed vertical lines, while retaining the star, outer borders, and other configurations. All tables must be scaled down and arranged evenly spaced in a grid layout."
"from manim import *

class BackgroundRectanglesExample(Scene):
    def construct(self):
        background = Rectangle(height=6.5, width=13)
        background.set_fill(opacity=.5)
        background.set_color([TEAL, RED, YELLOW])
        self.add(background)
        t0 = Table(
            [[""This"", ""is a""],
            [""simple"", ""Table.""]],
            add_background_rectangles_to_entries=True)
        t1 = Table(
            [[""This"", ""is a""],
            [""simple"", ""Table.""]],
            include_background_rectangle=True)
        g = Group(t0, t1).scale(0.7).arrange(buff=0.5)
        self.add(g)","Design a Manim animation that constructs a scene as follows:

1. The scene starts with a rectangular background (13 units wide and 6.5 units tall) with vertical gradient fill transitioning from TEAL at the top, through RED in the middle, to YELLOW at the bottom, with 50% opacity. 

2. Two identical text tables are displayed on this background, with rows: [""This"", ""is a""] and [""simple"", ""Table.""]. 

- The first table (left) must have individual background rectangles applied to **every cell** inside.
- The second table (right) must have a **single background rectangle** covering the entire table. 

3. The two tables are positioned side-by-side horizontally. They are scaled down to 70% of their original size and spaced 0.5 units apart from each other. 

4. All elements (the background rectangle and both tables) must appear **static on the screen** simultaneously without any movement or transition animations."
"from manim import *

class AddHighlightedCellExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        table.add_highlighted_cell((2,2), color=GREEN)
        self.add(table)","Create a Manim animation scene that displays a static table with two rows and two columns of data. The first row contains the text ""First"" and ""Second"", and the second row contains ""Third"" and ""Fourth"". The table must include row labels ""R1"" (for the first data row) and ""R2"" (for the second data row), along with column labels ""C1"" (for the first data column) and ""C2"" (for the second data column). The cell at position (2,2) in the table (corresponding to the second row and second column of the data) must be highlighted with a green color. The table should appear immediately in the scene without any movement or transformation effects."
"from manim import *

class CreateTableExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")],
            include_outer_lines=True)
        self.play(table.create())
        self.wait()","Write a Python Manim code to create an animation scene showing the step-by-step creation of a 2×2 table with the following specifications:  
- Rows contain text entries: ""First"", ""Second"" in the first row; ""Third"", ""Fourth"" in the second row  
- Row labels: ""R1"" (first row) and ""R2"" (second row)  
- Column labels: ""C1"" (first column) and ""C2"" (second column)  
- Display outer table borders  
- The animation should show the table being constructed (piece by piece with a creation animation) followed by a brief pause  

Use Manim's Table class and ensure all text elements are rendered as Text objects. Include necessary imports and scene structure."
"from manim import *

class GetCellExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        cell = table.get_cell((2,2), color=RED)
        self.add(table, cell)","Please provide the Python code using Manim library to create a scene that displays a table with two rows and two columns. The table must have row labels ""R1"" and ""R2"" on the left, and column labels ""C1"" and ""C2"" on top. The table cells should contain the text ""First"" (row 1, column 1), ""Second"" (row 1, column 2), ""Third"" (row 2, column 1), and ""Fourth"" (row 2, column 2). The cell at position (2,2) containing ""Fourth"" must be colored red. The scene should show these elements statically without any animations or movement. Use the latest Manim Community syntax."
"from manim import *

class GetColLabelsExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        lab = table.get_col_labels()
        for item in lab:
            item.set_color(random_bright_color())
        self.add(table)","Create a Manim animation scene that displays a table with 2 rows and 2 columns containing the entries: first row [""First"", ""Second""], second row [""Third"", ""Fourth""]. The table should have row labels ""R1"" (for the first row) and ""R2"" (for the second row) on the left side. The column headers (top of the table) should be labeled ""C1"" and ""C2"". Each of these two column header labels must be individually colored with random bright colors, while the row labels and table data cells remain in default colors. The final table should appear static on the screen without any movement or fading effects."
"from manim import *

class GetColumnsExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        table.add(SurroundingRectangle(table.get_columns()[1]))
        self.add(table)","Create a Manim animation scene that displays a table with two data rows and two columns, containing the text ""First"", ""Second"", ""Third"", and ""Fourth"". The table must have row labels ""R1"" (top row) and ""R2"" (bottom row), and column labels ""C1"" (left column) and ""C2"" (right column). Highlight the second column (containing ""Second"" and ""Fourth"") using a full surrounding rectangle. Specify all visual elements, their arrangement, and the highlighting effect in the animation."
"from manim import *

class GetEntriesExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        ent = table.get_entries()
        for item in ent:
            item.set_color(random_bright_color())
        table.get_entries((2,2)).rotate(PI)
        self.add(table)","Design a Manim animation scene that displays a table with 2 rows and 2 columns containing the entries ""First"", ""Second"", ""Third"", and ""Fourth"". The table should have row labels ""R1"" and ""R2"", and column labels ""C1"" and ""C2"". Apply a random bright color to each of the table cells (entries) individually using a for-loop. Then, specifically rotate the entry located at cell position (2,2) (second row, second column) 180 degrees clockwise (PI radians). The entire table with labels and transformed cell must appear in the final animation frame."
"from manim import *

class GetEntriesWithoutLabelsExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        ent = table.get_entries_without_labels()
        colors = [BLUE, GREEN, YELLOW, RED]
        for k in range(len(colors)):
            ent[k].set_color(colors[k])
        table.get_entries_without_labels((2,2)).rotate(PI)
        self.add(table)","""Create an animation scene using Manim where: 1. A table with two rows and two columns is displayed. The rows have vertical labels 'R1' and 'R2' on the left, and the columns have horizontal labels 'C1' and 'C2' along the top. The four main table entries (without labels) show the text: 'First', 'Second', 'Third', and 'Fourth. 2. Each of the four main entries changes to a different color in this exact order: first entry (top-left) turns blue, next to its right turns green, the one below the first turns yellow, and the final entry (bottom-right) turns red. 3. After coloring, the bottom-right entry ('Fourth') spins 180 degrees in place. Show the full table with these transformations in the final scene."""
"from manim import *

class GetHighlightedCellExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        highlight = table.get_highlighted_cell((2,2), color=GREEN)
        table.add_to_back(highlight)
        self.add(table)","Create a Manim animation scene that displays a table with two rows and two columns. The rows are labeled ""R1"" and ""R2"", and the columns are labeled ""C1"" and ""C2"". The table's content cells should contain ""First"", ""Second"", ""Third"", and ""Fourth"". Highlight the second cell in the second row (cell at position (2,2)) with a green color, ensuring the highlight appears behind the cell's text. The scene should show the table and highlighted cell without any movement or transformations."
"from manim import *

class GetHorizontalLinesExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        table.get_horizontal_lines().set_color(RED)
        self.add(table)","Create a Manim animation scene showing a table with two rows and two columns. The rows are labeled ""R1"" and ""R2"", and the columns are labeled ""C1"" and ""C2"". The table cells contain the text ""First"", ""Second"" in the first row, and ""Third"", ""Fourth"" in the second row. Highlight the horizontal lines between rows by changing their color to red."
"from manim import *

class GetLabelsExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        lab = table.get_labels()
        colors = [BLUE, GREEN, YELLOW, RED]
        for k in range(len(colors)):
            lab[k].set_color(colors[k])
        self.add(table)","Create a Manim animation scene where a table is displayed with two rows and columns of data. The first row has entries [""First"", ""Second""], and the second row has [""Third"", ""Fourth""]. The table must include row labels ""R1"" and ""R2"", and column labels ""C1"" and ""C2"". All row and column labels (four total) should be individually colored using the following order: the first row label ""R1"" is blue, second row label ""R2"" green, first column label ""C1"" yellow, and second column ""C2"" red. The data cells remain uncolored. Use a loop to assign the colors [BLUE, GREEN, YELLOW, RED] to each label sequentially via table.get_labels(). Finally, display the full table in the scene using self.add(table)."
"from manim import *

class GetRowLabelsExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        lab = table.get_row_labels()
        for item in lab:
            item.set_color(random_bright_color())
        self.add(table)","Create a Manim animation scene showing a table with two rows and two columns of text data (""First"", ""Second"", ""Third"", ""Fourth""). The table should have visible row labels (""R1"", ""R2"") and column labels (""C1"", ""C2""). After creating the table, individually highlight each row label (R1 and R2) with different random bright colors while keeping the column labels and table data unchanged. Display the fully colored table on the scene."
"from manim import *

class GetRowsExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        table.add(SurroundingRectangle(table.get_rows()[1]))
        self.add(table)","""Create a Manim animation scene where a table with two rows and two columns is displayed. The first row has the text 'First' and 'Second', while the second row contains 'Third' and 'Fourth'. Add row labels 'R1' and 'R2', and column labels 'C1' and 'C2'. The second row should be highlighted with a solid colored rectangular border surrounding it. Keep the animation static, only showing the table with the highlighted row."""
"from manim import *

class GetVerticalLinesExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        table.get_vertical_lines()[0].set_color(RED)
        self.add(table)","Create a Manim animation scene that displays a table with two data rows ([""First"", ""Second""], [""Third"", ""Fourth""]) and explicit row labels ""R1"" and ""R2"", and column labels ""C1"" and ""C2"". The first vertical line of the table must be highlighted in red. The scene should be named ""GetVerticalLinesExample"". The table's row/column labels must be created using the Text mobject. Include code to set the color of the first vertical line and add the table to the scene."
"from manim import *

class MobjectScaleExample(Scene):
    def construct(self):
        c1 = Circle(1, RED).set_x(-1)
        c2 = Circle(1, GREEN).set_x(1)

        vg = VGroup(c1, c2)
        vg.set_stroke(width=50)
        self.add(vg)

        self.play(
            c1.animate.scale(.25),
            c2.animate.scale(.25,
                scale_stroke=True)
        )","Design a Manim scene where two circles (radius 1) start positioned at x=-1 (red) and x=1 (green). Both have initial strokes of 50 units thick. Animate both shrinking uniformly to 25% scale simultaneously. The green circle's stroke width decreases proportionally during its scaling, but the red's stroke remains at 50 pixels thick while shrinking. Use scaled animations with distinct parameters for stroke scaling behavior between the two circles."
"from manim import *

class SetColumnColorsExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")]
        ).set_column_colors([RED,BLUE], GREEN)
        self.add(table)","Create an animation scene displaying a table with the following specifications:  
1. The table contains two data rows and two columns, with the following text entries:  
   - First row: ""First"" and ""Second""  
   - Second row: ""Third"" and ""Fourth""  
2. Row labels on the left side show ""R1"" and ""R2"".  
3. Column headers at the top display ""C1"" and ""C2"".  
4. The first data column (containing ""First"" and ""Third"") is colored red.  
5. The second data column (containing ""Second"" and ""Fourth"") is colored blue.  
6. The column headers (""C1"" and ""C2"") have a green background.  
7. The table is displayed statically without any movements, transitions, or animations."
"from manim import *

class SetRowColorsExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")]
        ).set_row_colors([RED,BLUE], GREEN)
        self.add(table)","Write a Manim animation scene that creates and displays a 2x2 table with the following specifications:
- Table data entries: First, Second in the first row; Third, Fourth in the second row.
- Row labels on left: R1 (for first row) and R2 (for second row).
- Column labels on top: C1 (for first column) and C2 (for second column).
- Row background colors: First row filled with RED, second row filled with BLUE.
- Column headers and all table cells have GREEN background color.
- The table should be fully rendered and displayed on the scene without any animated transitions or movements."
"from manim import *

class CodeFromString(Scene):
    def construct(self):
        code = '''from manim import Scene, Square

class FadeInSquare(Scene):
    def construct(self):
        s = Square()
        self.play(FadeIn(s))
        self.play(s.animate.scale(2))
        self.wait()'''

        rendered_code = Code(
            code_string=code,
            language=""python"",
            background=""window"",
            background_config={""stroke_color"": ""maroon""},
        )
        self.add(rendered_code)","Write Manim code to create an animation scene that displays the provided Python code snippet as a formatted code block on screen. The code to display should show a scene (FadeInSquare) that: 
1. Creates a square 
2. Applies a fade-in animation 
3. Scales the square to twice its size 
4. Pauses at the end

The displayed code must use: 
- A ""window"" style background for the code block 
- Maroon-colored border around the code window 
- Python syntax highlighting 

Specify the full Scene class that renders this code block as a static visualization, including proper Manim Code mobject configuration."
"from manim import *

class MovingSquareWithUpdaters(Scene):
    def construct(self):
        decimal = DecimalNumber(
            0,
            show_ellipsis=True,
            num_decimal_places=3,
            include_sign=True,
            unit=r""\text{M-Units}"",
            unit_buff_per_font_unit=0.003
        )
        square = Square().to_edge(UP)

        decimal.add_updater(lambda d: d.next_to(square, RIGHT))
        decimal.add_updater(lambda d: d.set_value(square.get_center()[1]))
        self.add(square, decimal)
        self.play(
            square.animate.to_edge(DOWN),
            rate_func=there_and_back,
            run_time=5,
        )
        self.wait()","Create a Manim animation scene where a square starts at the top edge (UP) of the screen. The square moves downward to the bottom edge (DOWN) and then reverses back to its starting position in a continuous motion over 5 seconds, using the ""there_and_back"" easing function. A decimal number is positioned to the right of the square at all times, dynamically updating to display the square's current vertical (y-axis) coordinate with three decimal places. The decimal number must include a sign symbol (+/-) and the unit ""M-Units"" following the numerical value. The number’s displayed value should continuously reflect the square’s changing y-coordinate during its motion, while its position remains adjacent to the square throughout the movement. After completing the motion, the scene should pause briefly."
"from manim import *

class IntegerExample(Scene):
    def construct(self):
        self.add(Integer(number=2.5).set_color(ORANGE).scale(2.5).set_x(-0.5).set_y(0.8))
        self.add(Integer(number=3.14159, show_ellipsis=True).set_x(3).set_y(3.3).scale(3.14159))
        self.add(Integer(number=42).set_x(2.5).set_y(-2.3).set_color_by_gradient(BLUE, TEAL).scale(1.7))
        self.add(Integer(number=6.28).set_x(-1.5).set_y(-2).set_color(YELLOW).scale(1.4))","Create a Manim animation scene that displays four Integer elements. The first shows the number 2.5 with orange color, scaled to 2.5x, positioned at (x=-0.5, y=0.8). The second displays 3.14159 with ellipsis enabled, scaled by 3.14159, placed at (x=3, y=3.3). The third shows 42 with a gradient from blue to teal, scaled 1.7x at (2.5, -2.3). The fourth element is 6.28 colored yellow, scaled 1.4x at (-1.5, -2. All elements should be added to the scene using their respective Manim properties and positioning functions."
"from manim import *

class VariablesWithValueTracker(Scene):
    def construct(self):
        var = 0.5
        on_screen_var = Variable(var, Text(""var""), num_decimal_places=3)

        # You can also change the colours for the label and value
        on_screen_var.label.set_color(RED)
        on_screen_var.value.set_color(GREEN)

        self.play(Write(on_screen_var))
        # The above line will just display the variable with
        # its initial value on the screen. If you also wish to
        # update it, you can do so by accessing the `tracker` attribute
        self.wait()
        var_tracker = on_screen_var.tracker
        var = 10.5
        self.play(var_tracker.animate.set_value(var))
        self.wait()

        int_var = 0
        on_screen_int_var = Variable(
            int_var, Text(""int_var""), var_type=Integer
        ).next_to(on_screen_var, DOWN)
        on_screen_int_var.label.set_color(RED)
        on_screen_int_var.value.set_color(GREEN)

        self.play(Write(on_screen_int_var))
        self.wait()
        var_tracker = on_screen_int_var.tracker
        var = 10.5
        self.play(var_tracker.animate.set_value(var))
        self.wait()

        # If you wish to have a somewhat more complicated label for your
        # variable with subscripts, superscripts, etc. the default class
        # for the label is MathTex
        subscript_label_var = 10
        on_screen_subscript_var = Variable(subscript_label_var, ""{a}_{i}"").next_to(
            on_screen_int_var, DOWN
        )
        self.play(Write(on_screen_subscript_var))
        self.wait()","Create an animation using Manim where three variables are displayed on the screen. The first variable, labeled ""var"", starts with a value of 0.5. Its label should be red and value green. Animate the value smoothly updating to 10.5. Below it, a second variable named ""int_var"" begins at 0. After appearing, its value should also transition to 10.5. Finally, add a third variable below the second, with its label showing ""a_i"" (using LaTeX subscript formatting) and an initial value of 10. Ensure all labels and values use red/green colors respectively, and each variable appears sequentially with smooth value changes where applicable."
"from manim import *

class VariableExample(Scene):
    def construct(self):
        start = 2.0

        x_var = Variable(start, 'x', num_decimal_places=3)
        sqr_var = Variable(start**2, 'x^2', num_decimal_places=3)
        Group(x_var, sqr_var).arrange(DOWN)

        sqr_var.add_updater(lambda v: v.tracker.set_value(x_var.tracker.get_value()**2))

        self.add(x_var, sqr_var)
        self.play(x_var.tracker.animate.set_value(5), run_time=2, rate_func=linear)
        self.wait(0.1)","Create a Manim Scene where two variables ""x"" and ""x²"" are displayed vertically. The initial x value is 2.0, and x² shows its squared value (4.0). As x animates to 5.0 over 2 seconds with linear movement, x² updates dynamically to always show x², maintaining 3 decimal places throughout the transition."
"from manim import *

class BulletedListExample(Scene):
    def construct(self):
        blist = BulletedList(""Item 1"", ""Item 2"", ""Item 3"", height=2, width=2)
        blist.set_color_by_tex(""Item 1"", RED)
        blist.set_color_by_tex(""Item 2"", GREEN)
        blist.set_color_by_tex(""Item 3"", BLUE)
        self.add(blist)","Please provide the Python Manim code to create an animation scene featuring a vertical bulleted list containing the text: ""Item 1"", ""Item 2"", and ""Item 3"". Each bullet point's text color must match their label: ""Item 1"" in red (RED), ""Item 2"" in green (GREEN), and ""Item 3"" in blue (BLUE). The entire bulleted list should be scaled to 2 units in height and width. The elements must display statically on the screen without any transitions, animations, or transformations after being initialized."
"from manim import *

class Formula(Scene):
    def construct(self):
        t = MathTex(r""\int_a^b f'(x) dx = f(b)- f(a)"")
        self.add(t)",Write Manim code to create an animation scene that displays the Fundamental Theorem of Calculus formula: the integral from a to b of f'(x) dx equals f(b) minus f(a). The equation should be rendered using LaTeX math formatting and remain stationary at the center of the screen throughout the scene.
"from manim import *

import manim

class TitleExample(Scene):
    def construct(self):
        banner = ManimBanner()
        title = Title(f""Manim version {manim.__version__}"")
        self.add(banner, title)","Write a Manim Python script to create an animation scene that starts with a Manim banner displayed at its default position and a centered title at the top of the screen showing the precise current version of the Manim library. The title text must format the version number dynamically using the manim.__version__ variable. Both visual elements should remain stationary and appear immediately without any motion, transformations, or transitions during the scene."
"from manim import *

class HelloWorld(Scene):
    def construct(self):
        text = Text('Hello world').scale(3)
        self.add(text)","Create a Manim animation that displays the static text ""Hello world"" scaled to 3x its original size. The text should appear immediately without any movement, fade, or transformation effects. The scene should start with an empty screen and simply show the scaled text centered on the screen throughout the entire animation duration. Use Manim's Scene class and Text mobject with appropriate scaling parameter."
"from manim import *

class TextAlignment(Scene):
    def construct(self):
        title = Text(""K-means clustering and Logistic Regression"", color=WHITE)
        title.scale(0.75)
        self.add(title.to_edge(UP))

        t1 = Text(""1. Measuring"").set_color(WHITE)

        t2 = Text(""2. Clustering"").set_color(WHITE)

        t3 = Text(""3. Regression"").set_color(WHITE)

        t4 = Text(""4. Prediction"").set_color(WHITE)

        x = VGroup(t1, t2, t3, t4).arrange(direction=DOWN, aligned_edge=LEFT).scale(0.7).next_to(ORIGIN,DR)
        x.set_opacity(0.5)
        x.submobjects[1].set_opacity(1)
        self.add(x)","Create a Manim animation scene that starts with the title ""K-means clustering and Logistic Regression"" at the top of the screen (scaled down to 75% of its original size). Below the title, position four numbered text items (1. Measuring, 2. Clustering, 3. Regression, 4. Prediction) in a vertical column aligned to the left, located in the bottom-right corner of the screen. The text items should be scaled to 70% of their original size, arranged downward with consistent spacing. All texts start with 50% opacity except for the second item (""2. Clustering""), which remains fully opaque. The elements should appear immediately without movement or transitions."
"from manim import *

class MarkupExample(Scene):
    def construct(self):
        text = MarkupText('<span foreground=""blue"" size=""x-large"">Blue text</span> is <i>cool</i>!""')
        self.add(text)","Design a Manim animation scene where the text ""Blue text is cool!"" is presented. The words 'Blue text' should be displayed in a bold blue color and extra-large font size (x-large), while the term 'cool' must appear in italics. The text sequence should transition or remain stationary on the screen, maintaining these specific styling attributes for each segment. Provide the full Python code using Manim's MarkupText for styled text rendering."
"from manim import *

class MarkupElaborateExample(Scene):
    def construct(self):
        text = MarkupText(
            '<span foreground=""purple"">ا</span><span foreground=""red"">َ</span>'
            'ل<span foreground=""blue"">ْ</span>ع<span foreground=""red"">َ</span>ر'
            '<span foreground=""red"">َ</span>ب<span foreground=""red"">ِ</span>ي'
            '<span foreground=""green"">ّ</span><span foreground=""red"">َ</span>ة'
            '<span foreground=""blue"">ُ</span>'
        )
        self.add(text)","""Create a Manim animation scene that displays the Arabic word 'العربية' using colored diacritics and letters. The first letter 'ا' should be purple, followed by a red َ, then a blue ْ under the letter ل, a red َ after it, the subsequent 'ع' with red َ, the letter 'ر' with red ِ, a绿色ّ (gemination mark) in green, another red َ, and finally a blue ُ. Each character and diacritic should be individually colored as specified and arranged to form the full word. Ensure the text remains static without any movement or transformation."""
"from manim import *

class BasicMarkupExample(Scene):
    def construct(self):
        text1 = MarkupText(""<b>foo</b> <i>bar</i> <b><i>foobar</i></b>"")
        text2 = MarkupText(""<s>foo</s> <u>bar</u> <big>big</big> <small>small</small>"")
        text3 = MarkupText(""H<sub>2</sub>O and H<sub>3</sub>O<sup>+</sup>"")
        text4 = MarkupText(""type <tt>help</tt> for help"")
        text5 = MarkupText(
            '<span underline=""double"">foo</span> <span underline=""error"">bar</span>'
        )
        group = VGroup(text1, text2, text3, text4, text5).arrange(DOWN)
        self.add(group)","Create a Manim animation scene that displays five text elements arranged vertically. The first text shows ""foo"" in bold, ""bar"" in italic, and ""foobar"" in bold-italic. The second text displays ""foo"" with a strike-through, ""bar"" underlined, ""big"" in larger font, and ""small"" in smaller font. The third text includes the chemical formulas ""H₂O"" and ""H₃O⁺"" with proper subscripts and superscripts. The fourth text shows ""help"" in a typewriter font within the sentence ""type help for help"". The fifth text has ""foo"" with a double underline and ""bar"" with an error-style (wavy) underline. All text elements must be vertically centered and spaced downward in sequence."
"from manim import *

class ColorExample(Scene):
    def construct(self):
        text1 = MarkupText(
            f'all in red <span fgcolor=""{YELLOW}"">except this</span>', color=RED
        )
        text2 = MarkupText(""nice gradient"", gradient=(BLUE, GREEN))
        text3 = MarkupText(
            'nice <gradient from=""RED"" to=""YELLOW"">intermediate</gradient> gradient',
            gradient=(BLUE, GREEN),
        )
        text4 = MarkupText(
            'fl ligature <gradient from=""RED"" to=""YELLOW"">causing trouble</gradient> here'
        )
        text5 = MarkupText(
            'fl ligature <gradient from=""RED"" to=""YELLOW"" offset=""1"">defeated</gradient> with offset'
        )
        text6 = MarkupText(
            'fl ligature <gradient from=""RED"" to=""YELLOW"" offset=""1"">floating</gradient> inside'
        )
        text7 = MarkupText(
            'fl ligature <gradient from=""RED"" to=""YELLOW"" offset=""1,1"">floating</gradient> inside'
        )
        group = VGroup(text1, text2, text3, text4, text5, text6, text7).arrange(DOWN)
        self.add(group)","Create an animation scene displaying seven text blocks arranged vertically. The first text has the phrase:  
- ""all in red"" in red, except the words ""except this"" are yellow.  
The second text shows ""nice gradient"" with a smooth transition from blue to green.  
The third text says ""nice intermediate"" where ""intermediate"" displays a red-to-yellow gradient. The remaining words follow a different color transition.  
The fourth text demonstrates a ""fl ligature"" problem: the gradient over ""causing trouble"" appears misaligned due to ligature characters like ""fl"".  
The next texts resolve this:  
- ""defeated"" uses an offset of 1 to fix the misalignment in ""fl"" ligatures.  
- The following text ""floating inside"" applies an offset of 1 to address the same issue.  
- The last text ""floating"" uses a dual offset ""1,1"" to fully correct alignment on ""fl"" ligatures.  
All elements should be placed in a vertical sequence without animate actions."
"from manim import *

class UnderlineExample(Scene):
    def construct(self):
        text1 = MarkupText(
            '<span underline=""double"" underline_color=""green"">bla</span>'
        )
        text2 = MarkupText(
            '<span underline=""single"" underline_color=""green"">xxx</span><gradient from=""#ffff00"" to=""RED"">aabb</gradient>y'
        )
        text3 = MarkupText(
            '<span underline=""single"" underline_color=""green"">xxx</span><gradient from=""#ffff00"" to=""RED"" offset=""-1"">aabb</gradient>y'
        )
        text4 = MarkupText(
            '<span underline=""double"" underline_color=""green"">xxx</span><gradient from=""#ffff00"" to=""RED"">aabb</gradient>y'
        )
        text5 = MarkupText(
            '<span underline=""double"" underline_color=""green"">xxx</span><gradient from=""#ffff00"" to=""RED"" offset=""-2"">aabb</gradient>y'
        )
        group = VGroup(text1, text2, text3, text4, text5).arrange(DOWN)
        self.add(group)","Create a Manim animation scene named UnderlineExample that displays five text elements arranged vertically (DOWN) demonstrating different text styling combinations. Each text must include: 

1. ""bla"" with double green underline.
2. ""xxx"" with single green underline followed by ""aabb"" with a yellow-to-red gradient text and ""y"", with the gradient on ""aabb"" starting at default position.
3. Same as text2 but with the ""aabb"" gradient shifted left by 1 unit.
4. ""xxx"" with double green underline followed by ""aabb"" with yellow-to-red gradient and ""y"" (no offset).
5. Same as text4 but the ""aabb"" gradient is shifted left by 2 units. 

Show all five examples in a vertical sequence using VGroup arrangement. Include markup syntax for underlines, gradients, colors, and offset parameters where applicable."
"from manim import *

class FontExample(Scene):
    def construct(self):
        text1 = MarkupText(
            'all in sans <span font_family=""serif"">except this</span>', font=""sans""
        )
        text2 = MarkupText(
            '<span font_family=""serif"">mixing</span> <span font_family=""sans"">fonts</span> <span font_family=""monospace"">is ugly</span>'
        )
        text3 = MarkupText(""special char > or &gt;"")
        text4 = MarkupText(""special char &lt; and &amp;"")
        group = VGroup(text1, text2, text3, text4).arrange(DOWN)
        self.add(group)","Please create a Manim animation scene that shows four text elements arranged vertically. The first text displays ""all in sans except this"" with the initial part in sans font and the phrase ""except this"" in serif font. The second text shows ""mixing fonts is ugly"" with ""mixing"" in serif, ""fonts"" in sans, and ""is ugly"" in monospace. The third text reads ""special char > or &gt;"", and the fourth shows ""special char &lt; and &"". The texts should be placed in a vertical column to demonstrate font family mixing and proper special character rendering."
"from manim import *

class NewlineExample(Scene):
    def construct(self):
        text = MarkupText('foooo<span foreground=""red"">oo\nbaa</span>aar')
        self.add(text)","
""Create a Manim animation scene that displays a text with markup. The text should start with 'foooo', followed by 'oo' in red on the same line. After that, it should move to a new line with 'baa' in red. Finally, after that, show 'aar' in default color."""
"from manim import *

class NoLigaturesExample(Scene):
    def construct(self):
        text1 = MarkupText('fl<gradient from=""RED"" to=""GREEN"">oat</gradient>ing')
        text2 = MarkupText('fl<gradient from=""RED"" to=""GREEN"">oat</gradient>ing', disable_ligatures=True)
        group = VGroup(text1, text2).arrange(DOWN)
        self.add(group)","Create a Manim animation scene that compares text with and without ligatures. Show two lines of text arranged vertically centered on the screen. The text should both display the word ""floating"" with the ""oat"" portion as a gradient from red to green using markup gradients. The top text should use default ligatures while the bottom text should explicitly disable ligatures (disable_ligatures=True). Both texts must use MarkupText and maintain identical styling except for the ligature setting."
"from manim import *

class MultiLanguage(Scene):
    def construct(self):
        morning = MarkupText(""வணக்கம்"", font=""sans-serif"")
        japanese = MarkupText(
            '<span fgcolor=""blue"">日本</span>へようこそ'
        )  # works as in ``Text``.
        mess = MarkupText(""Multi-Language"", weight=BOLD)
        russ = MarkupText(""Здравствуйте मस नम म "", font=""sans-serif"")
        hin = MarkupText(""नमस्ते"", font=""sans-serif"")
        chinese = MarkupText(""臂猿「黛比」帶著孩子"", font=""sans-serif"")
        group = VGroup(morning, japanese, mess, russ, hin, chinese).arrange(DOWN)
        self.add(group)","Create a Manim animation scene where multiple multilingual text elements are displayed in a vertical arrangement. The scene should include the following elements: 
1. A Tamil greeting ""வணக்கம்"" using a sans-serif font.
2. A Japanese text ""<span fgcolor='blue'>日本</span>へようこそ"" with the word '日本' in blue color.
3. A bold English text ""Multi-Language"".
4. A Russian-Hindi混合 text ""Здравствуйте मस नम म"" with sans-serif font.
5. A Chinese text ""臂猿「黛比」带着孩子"" using sans-serif font. 
The texts must be organized in a vertical sequence (aligned downward) without any movement or transformation animations. The elements should appear statically arranged from top to bottom in the specified order."
"from manim import *

class JustifyText(Scene):
    def construct(self):
        ipsum_text = (
            ""Lorem ipsum dolor sit amet, consectetur adipiscing elit.""
            ""Praesent feugiat metus sit amet iaculis pulvinar. Nulla posuere ""
            ""quam a ex aliquam, eleifend consectetur tellus viverra. Aliquam ""
            ""fermentum interdum justo, nec rutrum elit pretium ac. Nam quis ""
            ""leo pulvinar, dignissim est at, venenatis nisi.""
        )
        justified_text = MarkupText(ipsum_text, justify=True).scale(0.4)
        not_justified_text = MarkupText(ipsum_text, justify=False).scale(0.4)
        just_title = Title(""Justified"")
        njust_title = Title(""Not Justified"")
        self.add(njust_title, not_justified_text)
        self.play(
            FadeOut(not_justified_text),
            FadeIn(justified_text),
            FadeOut(njust_title),
            FadeIn(just_title),
        )
        self.wait(1)","""Create a Manim animation scene that visually compares justified and non-justified text formatting. Start by displaying 'Not Justified' as a title followed by a long paragraph of Latin lorem ipsum text (4-5 sentences) that is not justified (words per line unevenly spaced). Then transition to a 'Justified' title with the same text block reformatted so all lines have even left/right edges through letter spacing adjustments. Use fade transitions to swap the non-justified text/title with the justified version: fading out the original text/title while simultaneously fading in the new ones. Both text blocks should be scaled down to 40% of original size for visibility. The scene should end with a 1-second pause on the final justified text."""
"from manim import *

class Example1Text(Scene):
    def construct(self):
        text = Text('Hello world').scale(3)
        self.add(text)","Create a Manim animation scene that starts with an empty screen. Introduce the text ""Hello world"" centered on the screen, initially scaled to three times its original size. The text should appear instantly without any fading, sliding, or transitioning effects and remain stationary without any subsequent movements, transformations, or animations for the duration of the scene."
"from manim import *

class TextColorExample(Scene):
    def construct(self):
        text1 = Text('Hello world', color=BLUE).scale(3)
        text2 = Text('Hello world', gradient=(BLUE, GREEN)).scale(3).next_to(text1, DOWN)
        self.add(text1, text2)","Create a Manim animation scene showing two instances of the text ""Hello world"". The first text should be displayed in solid blue color and scaled to 3 times its original size. The second text should have a gradient color transition from blue to green and also scaled to 3 times its original size. Position the second text directly below the first text. Both texts should appear on screen simultaneously without any movement or transformation animations between them."
"from manim import *

class TextItalicAndBoldExample(Scene):
    def construct(self):
        text1 = Text(""Hello world"", slant=ITALIC)
        text2 = Text(""Hello world"", t2s={'world':ITALIC})
        text3 = Text(""Hello world"", weight=BOLD)
        text4 = Text(""Hello world"", t2w={'world':BOLD})
        text5 = Text(""Hello world"", t2c={'o':YELLOW}, disable_ligatures=True)
        text6 = Text(
            ""Visit us at docs.manim.community"",
            t2c={""docs.manim.community"": YELLOW},
            disable_ligatures=True,
       )
        text6.scale(1.3).shift(DOWN)
        self.add(text1, text2, text3, text4, text5 , text6)
        Group(*self.mobjects).arrange(DOWN, buff=.8).set(height=config.frame_height-LARGE_BUFF)","Create a Manim Scene that displays six text objects vertically arranged with spacing. The first text shows ""Hello world"" in fully italicized font. The second shows ""Hello world"" with only the word ‘world’ italicized (rest default). The third uses bold font for entire text. The fourth has only ‘world’ in bold. The fifth replaces all 'o' characters with yellow color. The sixth text says ""Visit us at docs.manim.community"" with the URL substring colored yellow, scaled 1.3x larger, and positioned lower on screen. All texts must disable ligatures, and the entire group should size to fit the frame height while maintaining vertical spacing between elements."
"from manim import *

class TextMoreCustomization(Scene):
    def construct(self):
        text1 = Text(
            'Google',
            t2c={'[:1]': '#3174f0', '[1:2]': '#e53125',
                 '[2:3]': '#fbb003', '[3:4]': '#3174f0',
                 '[4:5]': '#269a43', '[5:]': '#e53125'}, font_size=58).scale(3)
        self.add(text1)","Create a Manim animation scene that displays the text ""Google"" with each character individually colored using the following hex codes: first character (#3174f0), second (#e53125), third (#fbb003), fourth (#3174f0), fifth (#269a43), and sixth (#e55325). The text should initially be sized with font_size=58 and then scaled up by a factor of 3. The scene should render the stationary text with precise color segmentation for each letter."
"from manim import *

class MultipleFonts(Scene):
    def construct(self):
        morning = Text(""வணக்கம்"", font=""sans-serif"")
        japanese = Text(
            ""日本へようこそ"", t2c={""日本"": BLUE}
        )  # works same as ``Text``.
        mess = Text(""Multi-Language"", weight=BOLD)
        russ = Text(""Здравствуйте मस नम म "", font=""sans-serif"")
        hin = Text(""नमस्ते"", font=""sans-serif"")
        arb = Text(
            ""صباح الخير \n تشرفت بمقابلتك"", font=""sans-serif""
        )  # don't mix RTL and LTR languages nothing shows up then ;-)
        chinese = Text(""臂猿「黛比」帶著孩子"", font=""sans-serif"")
        self.add(morning, japanese, mess, russ, hin, arb, chinese)
        for i,mobj in enumerate(self.mobjects):
            mobj.shift(DOWN*(i-3))","Create a Manim animation scene that displays multiple multilingual texts arranged vertically. The scene should include: 1) ""வணக்கம்"" in Tamil, 2) ""日本へようこそ"" in Japanese with ""日本"" in blue, 3) ""Multi-Language"" in bold, 4) a Russian/Hindi mix ""Здравствуйте मस नम म"", 5) Hindi ""नमस्ते"", 6) Arabic ""صباح الخير تشرفت بمقابلتك"" (ensure proper right-to-left rendering), and 7) Chinese ""臂猿「黛比」帶著孩子"". All texts except ""Multi-Language"" should use the sans-serif font. Arrange them vertically without overlapping using appropriate spacing."
"from manim import *

class PangoRender(Scene):
    def construct(self):
        morning = Text(""வணக்கம்"", font=""sans-serif"")
        self.play(Write(morning))
        self.wait(2)","Create a Manim animation scene that displays the Tamil text ""வணக்கம்"" using a sans-serif font. The text should be written onto the screen with a smooth drawing animation. After the text appears, the scene should pause for 2 seconds before ending. Use modern Manim imports (from manim import *) and ensure the scene class is named PangoRender."
"from manim import *

class ConvexHull3DExample(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        points = [
            [ 1.93192757,  0.44134585, -1.52407061],
            [-0.93302521,  1.23206983,  0.64117067],
            [-0.44350918, -0.61043677,  0.21723705],
            [-0.42640268, -1.05260843,  1.61266094],
            [-1.84449637,  0.91238739, -1.85172623],
            [ 1.72068132, -0.11880457,  0.51881751],
            [ 0.41904805,  0.44938012, -1.86440686],
            [ 0.83864666,  1.66653337,  1.88960123],
            [ 0.22240514, -0.80986286,  1.34249326],
            [-1.29585759,  1.01516189,  0.46187522],
            [ 1.7776499,  -1.59550796, -1.70240747],
            [ 0.80065226, -0.12530398,  1.70063977],
            [ 1.28960948, -1.44158255,  1.39938582],
            [-0.93538943,  1.33617705, -0.24852643],
            [-1.54868271,  1.7444399,  -0.46170734]
        ]
        hull = ConvexHull3D(
            *points,
            faces_config = {""stroke_opacity"": 0},
            graph_config = {
                ""vertex_type"": Dot3D,
                ""edge_config"": {
                    ""stroke_color"": BLUE,
                    ""stroke_width"": 2,
                    ""stroke_opacity"": 0.05,
                }
            }
        )
        dots = VGroup(*[Dot3D(point) for point in points])
        self.add(hull)
        self.add(dots)","Create a Manim animation showing a 3D convex hull of specific points in a 3D coordinate system. The scene must use a ThreeDScene class. First, set the camera orientation to phi=75*DEGREES and theta=30*DEGREES. The points are: [[1.93192757, 0.44134585, -1.52407061], [-0.93302521, 1.23206983, 0.64117067], [-0.44350918, -0.61043677, 0.21723705], [-0.42640268, -1.05260843, 1.61266094], [-1.84449637, 0.91238739, -1.85172623], [1.72068132, -0.11880457, 0.51881751], [0.41904805, 0.44938012, -1.86440686], [0.83864666, 1.66653337, 1.88960123], [0.22240514, -0.80986286, 1.34249326], [-1.29585759, 1.01516189, 0.46187522], [1.7776499, -1.59550796, -1.70240747], [0.80065226, -0.12530398, 1.70063977], [1.28960948, -1.44158255, 1.39938582]]. The convex hull must be drawn using ConvexHull3D. Configure convex hull edges as blue lines (color: BLUE) with stroke_width=2 and stroke_opacity=0.05. The faces of the convex hull must be transparent (set face stroke_opacity to 0).). The vertices of the convex hull's graph should use Dot3D. Finally, add all points as small dots (Dot3D) overlaid on top of the hull edges. Ensure the convex hull is added first to the screen, followed by the individual dots so they appear on top. Specify all numerical parameters (coordinates, colors, opacities, styles) precisely as described here.

The prompt must explicitly list all points with their exact coordinates, and state the parameters for each element (hull edges, hull faces, vertices, and the supplementary dots). The code must use exactly the points provided, configure the convex hull with the given styles, and layer the dots over the edges for visibility. Ensure that the edges have low transparency, edges are blue, and faces are invisible. Include all these details to replicate the animation precisely."""
"from manim import *

class DodecahedronScene(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        obj = Dodecahedron()
        self.add(obj)","""Write a Python script using Manim to create a 3D animation scene showing a static dodecahedron. The camera should be set to an initial orientation with phi of 75 degrees and theta of 30 degrees. The scene must display only the dodecahedron with no additional movements, transformations, or objects. Include all required imports and define a class using the proper ThreeDScene inheritance for rendering the scene."""
"from manim import *

class IcosahedronScene(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        obj = Icosahedron()
        self.add(obj)","Design a Manim Python code for a ThreeDScene that displays a static 3D icosahedron. Set the camera perspective to phi=75 degrees (elevation) and theta=30 degrees (azimuthal angle). The icosahedron should be rendered without rotating, moving, or transforming throughout the scene. Ensure the camera orientation is established first before adding the icosahedron to the scene."
"from manim import *

class OctahedronScene(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        obj = Octahedron()
        self.add(obj)","Create a Manim scene that displays a 3D octahedron. Set the camera perspective with a phi of 75 degrees and theta of 30 degrees. The scene should initialize an Octahedron object and add it to the display without any animations or transformations. Keep the scene static, only showing the 3D shape from the specified angle."
"from manim import *

class SquarePyramidScene(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        vertex_coords = [
            [1, 1, 0],
            [1, -1, 0],
            [-1, -1, 0],
            [-1, 1, 0],
            [0, 0, 2]
        ]
        faces_list = [
            [0, 1, 4],
            [1, 2, 4],
            [2, 3, 4],
            [3, 0, 4],
            [0, 1, 2, 3]
        ]
        pyramid = Polyhedron(vertex_coords, faces_list)
        self.add(pyramid)","Create a Manim Python script to construct a 3D animation scene showing a square pyramid. The pyramid must have vertices at coordinates (1,1,0), (1,-1,0), (-1,-1,0), (-1,1,0) for the base square's four corners, and an apex vertex at (0,0,2). Its faces should include four triangular sides connecting each base edge to the apex, forming the pyramid's sides, plus the base square as a face. The 3D scene must set the camera angle with phi=75 degrees and theta=30 degrees to view the pyramid in perspective. The animation should display the pyramid as a static 3D shape without any motion, transformations, or rotations."
"from manim import *

class PolyhedronSubMobjects(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        octahedron = Octahedron(edge_length = 3)
        octahedron.graph[0].set_color(RED)
        octahedron.faces[2].set_color(YELLOW)
        self.add(octahedron)","Write a Manim Python code to create a 3D animation scene where an octahedron is displayed with specific submobjects highlighted. The camera should start with a viewpoint oriented at phi=75 degrees and theta=30 degrees. The first vertex (index 0) of the octahedron's graph should be colored red. Additionally, the third face (index 2) of its faces should be colored yellow. Use an Octahedron object with edge length set to 3. Ensure the scene uses ThreeDScene and proper 3D camera setup."
"from manim import *

class TetrahedronScene(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        obj = Tetrahedron()
        self.add(obj)","Create a Manim Python code to generate an animation scene showing a stationary tetrahedron rendered in 3D space. The camera perspective should be set to a fixed orientation with phi=75 degrees (elevation) and theta=30 degrees (azimuth). The tetrahedron must be displayed without any rotations, translations, or transformations. Only the 3D setup and static object rendering are required."
"from manim import *

class ExampleArrow3D(ThreeDScene):
    def construct(self):
        axes = ThreeDAxes()
        arrow = Arrow3D(
            start=np.array([0, 0, 0]),
            end=np.array([2, 2, 2]),
            resolution=8
        )
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        self.add(axes, arrow)","Create a Manim animation scene that visually demonstrates the following: A 3D coordinate system with axes, and a 3D arrow starting at the origin (0,0,0) and pointing towards the point (2,2,2). The arrow should have a resolution of 8 to give it a smooth cylindrical appearance. The camera should be oriented at a 75-degree angle of elevation (phi) and 30-degree azimuthal angle (theta) to provide a clear 3D perspective. The scene should include the 3D axes and the arrow as static elements without any motion animations."
"from manim import *

class ExampleCone(ThreeDScene):
    def construct(self):
        axes = ThreeDAxes()
        cone = Cone(direction=X_AXIS+Y_AXIS+2*Z_AXIS, resolution=8)
        self.set_camera_orientation(phi=5*PI/11, theta=PI/9)
        self.add(axes, cone)",Create a 3D animation using Manim that displays a coordinate system (axes) and a cone oriented along a diagonal direction determined by the vector (X + Y + 2Z). The cone should have low-resolution facets visible due to its resolution parameter. Position the camera angle to show the cone and axes from a specific viewpoint: phi = 5π/11 (elevation) and theta = π/9 (rotation). The scene must render these elements statically without any movement or transformations.
"from manim import *

class CubeExample(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)

        axes = ThreeDAxes()
        cube = Cube(side_length=3, fill_opacity=0.7, fill_color=BLUE)
        self.add(cube)",Create a Manim animation scene where a solid blue cube with 70% fill opacity appears stationary in a 3D coordinate system. The cube has a side length of 3 units. The camera viewpoint must be set to a perspective with phi=75 degrees (elevation) and theta=-45 degrees (azimuth angle). The 3D axes should be visible in the scene but not shaded. The cube must be centered and fully visible without any rotation or movement during the animation.
"from manim import *

class ExampleCylinder(ThreeDScene):
    def construct(self):
        axes = ThreeDAxes()
        cylinder = Cylinder(radius=2, height=3)
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        self.add(axes, cylinder)","Write Manim code for a 3D animation scene that displays a 3D coordinate system (ThreeDAxes) and a cylinder. The cylinder should have a radius of 2 units and a height of 3 units. The scene should set the camera perspective to a phi angle of 75 degrees and a theta angle of 30 degrees, ensuring both the axes and cylinder are visible and static in the scene."
"from manim import *

class Dot3DExample(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)

        axes = ThreeDAxes()
        dot_1 = Dot3D(point=axes.coords_to_point(0, 0, 1), color=RED)
        dot_2 = Dot3D(point=axes.coords_to_point(2, 0, 0), radius=0.1, color=BLUE)
        dot_3 = Dot3D(point=[0, 0, 0], radius=0.1, color=ORANGE)
        self.add(axes, dot_1, dot_2,dot_3)","Design a 3D animation using Manim where:  
- A ThreeDAxes coordinate system is displayed.  
- The camera is oriented with phi = 75°, theta = -45°.  
- Three Dot3D elements:  
  1. **Red Dot**: positioned at (0, 0, 1) in the coordinate system.  
  2. **Blue Dot**: located at (2, 0, 0), with radius 0.1.  
  3. **Orange Dot**: placed at (0, 0, 0 with radius 0.1.  
- All elements are added to the scene for initial display."
"from manim import *

class ExampleLine3D(ThreeDScene):
    def construct(self):
        axes = ThreeDAxes()
        line = Line3D(start=np.array([0, 0, 0]), end=np.array([2, 2, 2]))
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        self.add(axes, line)","Create a 3D animation scene showing a 3D coordinate system with axes and a straight line extending from the origin (0,0,0) to the point (2,2,2). The line should be rendered as a 3D object. The camera视角 should be positioned at a 75-degree angle of elevation (phi) and 30-degree azimuthal angle (theta) to provide a clear perspective view of the 3D space. Both the axes and line must be visible simultaneously in the scene without any animations or transformations."
"from manim import *

class ParallelLineExample(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(PI / 3, -PI / 4)
        ax = ThreeDAxes((-5, 5), (-5, 5), (-5, 5), 10, 10, 10)
        line1 = Line3D(RIGHT * 2, UP + OUT, color=RED)
        line2 = Line3D.parallel_to(line1, color=YELLOW)
        self.add(ax, line1, line2)","Create a Manim Python class for a 3D animation scene showing two parallel lines in a 3D coordinate system. The scene must:  
1. Set the camera orientation to **phi=π/3** (elevation) and **theta=-pi/4** (azimuth) for the 3D view.  
2. Display 3D axes (ThreeDAxes) with ranges from -5 to +5 on all x, y, and z axes.  
3. Draw a **red line** (Line3D) **from (2,0,0) to (0,1,-1**). A second **yellow line** must be created **parallel to the first line**, positioned in another part of the space while preserving parallelism. Ensure both lines are displayed together with the coordinate axes in the scene."
"from manim import *

class PerpLineExample(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(PI / 3, -PI / 4)
        ax = ThreeDAxes((-5, 5), (-5, 5), (-5, 5), 10, 10, 10)
        line1 = Line3D(RIGHT * 2, UP + OUT, color=RED)
        line2 = Line3D.perpendicular_to(line1, color=BLUE)
        self.add(ax, line1, line2)","Create a 3D animation scene showing two perpendicular lines in a 3D coordinate system. First, display a 3D axis system spanning from -5 to 5 on all x, y, and z axes with 10 divisions per axis. Set the camera perspective to a 60-degree elevation angle (PI/3) and -45-degree azimuthal angle (-PI/4) to show the 3D space. Then draw a red line segment from the point (2, 0, 0) to (0, 1, -1). Next, draw a blue line segment that is exactly perpendicular to the red line, starting from the red line's endpoint (0, 1, -1). The blue line should automatically calculate its direction based on the red line's orientation to form a right angle between them. Both lines must be permanently displayed without any movement or transformation after being drawn."
"from manim import *

class ExamplePrism(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=60 * DEGREES, theta=150 * DEGREES)
        prismSmall = Prism(dimensions=[1, 2, 3]).rotate(PI / 2)
        prismLarge = Prism(dimensions=[1.5, 3, 4.5]).move_to([2, 0, 0])
        self.add(prismSmall, prismLarge)","Create a Manim animation scene showing two 3D prisms. The first prism (smaller) has dimensions [1,2,3] and is rotated 90 degrees around the z-axis. The second prism (larger) has dimensions [1.5,3,4.5] and is shifted to the right along the x-axis by 2 units. Both prisms must be displayed simultaneously in the initial scene setup. Use a 3D camera perspective with phi=60 degrees (elevation) and theta=150 degrees (azimuth) orientation. Include all necessary Manim imports and class structure to render this static arrangement without any movement or transformations between the objects."
"from manim import *

class ExampleSphere(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=PI / 6, theta=PI / 6)
        sphere1 = Sphere(
            center=(3, 0, 0),
            radius=1,
            resolution=(20, 20),
            u_range=[0.001, PI - 0.001],
            v_range=[0, TAU]
        )
        sphere1.set_color(RED)
        self.add(sphere1)
        sphere2 = Sphere(center=(-1, -3, 0), radius=2, resolution=(18, 18))
        sphere2.set_color(GREEN)
        self.add(sphere2)
        sphere3 = Sphere(center=(-1, 2, 0), radius=2, resolution=(16, 16))
        sphere3.set_color(BLUE)
        self.add(sphere3)","Create a Manim Python animation scene that displays three stationary spheres in a 3D environment. The first sphere is centered at (3, 0, 0), has a radius of 1, and is colored red. It uses a resolution of (20, 20), with u_range between 0.001 and π - 0.001 and v_range spanning 0 to τ (2π). The second sphere is placed at (-1, -3, 0), has a radius of 2, and is colored green with a resolution of (18, 18). The third sphere is located at (-1, 2, 0), also has a radius of 2, is colored blue, and uses a resolution of (16, 16. Position the camera with φ=π/6 (elevation) and θ=π/6 (azimuth) to view all spheres simultaneously. Ensure all spheres are added to the scene without any transformations or movements."
"from manim import *

class ParaSurface(ThreeDScene):
    def func(self, u, v):
        return np.array([np.cos(u) * np.cos(v), np.cos(u) * np.sin(v), u])

    def construct(self):
        axes = ThreeDAxes(x_range=[-4,4], x_length=8)
        surface = Surface(
            lambda u, v: axes.c2p(*self.func(u, v)),
            u_range=[-PI, PI],
            v_range=[0, TAU],
            resolution=8,
        )
        self.set_camera_orientation(theta=70 * DEGREES, phi=75 * DEGREES)
        self.add(axes, surface)","Create a Manim animation scene that displays a parametric 3D surface defined by the equations:  
- x = cos(u) * cos(v)  
- y = cos(u) * sin(v)  
- z = u  
The surface's parameters (u, v) should range over u ∈ [-π, π] and v ∈ [0, 2π], with a grid resolution of 8x8. The scene must include a 3D coordinate system where the x-axis uses a numerical range from -4 to 4 but visually spans 8 units in length. Position the 3D camera with an azimuthal rotation of 70 degrees (θ) and a polar angle of 75 degrees (φ) relative to the coordinate axes. The final visualization should statically show both the coordinate axes and the surface without any dynamic movements or transformations."
"from manim import *

class FillByValueExample(ThreeDScene):
    def construct(self):
        resolution_fa = 8
        self.set_camera_orientation(phi=75 * DEGREES, theta=-160 * DEGREES)
        axes = ThreeDAxes(x_range=(0, 5, 1), y_range=(0, 5, 1), z_range=(-1, 1, 0.5))
        def param_surface(u, v):
            x = u
            y = v
            z = np.sin(x) * np.cos(y)
            return z
        surface_plane = Surface(
            lambda u, v: axes.c2p(u, v, param_surface(u, v)),
            resolution=(resolution_fa, resolution_fa),
            v_range=[0, 5],
            u_range=[0, 5],
            )
        surface_plane.set_style(fill_opacity=1)
        surface_plane.set_fill_by_value(axes=axes, colorscale=[(RED, -0.5), (YELLOW, 0), (GREEN, 0.5)], axis=2)
        self.add(axes, surface_plane)","Create a Manim animation scene that visualizes a 3D surface plot defined by the equation z = sin(x)*cos(y). The scene should include:  
1. Three-dimensional axes with x and y ranges from 0–5, and z from -1 to 1.  
2. A surface plot colored based on z-values using a gradient:  
   - Red when z < -0.5  
   - Yellow at z = 0  
   - Green when z > 0.5  
   Use Manim's `fill_by_value` method with color thresholds at -0.5 (RED), 0 (YELLOW), and 0.5 (GREEN).  
3. Set the camera angle to a 75° elevation and -160° azimuth (theta).  
4. Ensure the surface has full opacity (fill_opacity=1).  
Describe the scene step-by-step to generate this visualization.  

No additional animations (e.g., movements or transitions) are required."
"from manim import *

class ExampleTorus(ThreeDScene):
    def construct(self):
        axes = ThreeDAxes()
        torus = Torus()
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        self.add(axes, torus)","""Write a Manim Python script to animate a 3D scene with a torus and 3D coordinate axes. The camera perspective must be set to an elevation of 75 degrees and an azimuth angle of 30 degrees. The scene should display both objects statically without any movement, rotation, scaling, or transformation. Include code details for initializing the 3D axes, positioning the camera, and rendering the torus within the 3D environment."""
"from manim import *

class ImageFromArray(Scene):
    def construct(self):
        image = ImageMobject(np.uint8([[0, 100, 30, 200],
                                       [255, 0, 5, 33]]))
        image.height = 7
        self.add(image)","Design a Manim animation scene that displays a static image generated from a 2D numpy array [[0, 100, 30, 200],[255, 0, 5, 33]] using ImageMobject. The image should be scaled to a height of 7 units and remain stationary without any movements or transformations during the animation."
"from manim import *

class ImageInterpolationEx(Scene):
    def construct(self):
        img = ImageMobject(np.uint8([[63, 0, 0, 0],
                                        [0, 127, 0, 0],
                                        [0, 0, 191, 0],
                                        [0, 0, 0, 255]
                                        ]))

        img.height = 2
        img1 = img.copy()
        img2 = img.copy()
        img3 = img.copy()
        img4 = img.copy()
        img5 = img.copy()

        img1.set_resampling_algorithm(RESAMPLING_ALGORITHMS[""nearest""])
        img2.set_resampling_algorithm(RESAMPLING_ALGORITHMS[""lanczos""])
        img3.set_resampling_algorithm(RESAMPLING_ALGORITHMS[""linear""])
        img4.set_resampling_algorithm(RESAMPLING_ALGORITHMS[""cubic""])
        img5.set_resampling_algorithm(RESAMPLING_ALGORITHMS[""box""])
        img1.add(Text(""nearest"").scale(0.5).next_to(img1,UP))
        img2.add(Text(""lanczos"").scale(0.5).next_to(img2,UP))
        img3.add(Text(""linear"").scale(0.5).next_to(img3,UP))
        img4.add(Text(""cubic"").scale(0.5).next_to(img4,UP))
        img5.add(Text(""box"").scale(0.5).next_to(img5,UP))

        x= Group(img1,img2,img3,img4,img5)
        x.arrange()
        self.add(x)","Create a Manim animation scene that visually demonstrates different image resampling algorithms. The scene should display five images side by side, each showing an interpolation example using one of the following algorithms: ""nearest"", ""lanczos"", ""linear"", ""cubic"", and ""box"". 

Each image should represent a 4x4 grayscale test pattern matrix:
[[63, 0, 0, 0],
 [0, 127, 0, 0],
 [0, 0, 191, 0],
 [0, 0, 0, 255]]

For each algorithm:
1. Create a copy of the base image
2. Apply the corresponding resampling algorithm to the image
3. Add the algorithm's name as text (scaled to 50% size) positioned above the image
4. Set each image to have a height of 2 units

Arrange all the labeled images horizontally in a row as a single group. Do not include any animations or transitions—only display the final arrangement."
"from manim import *

class PgroupExample(Scene):
    def construct(self):

        p1 = PointCloudDot(radius=1, density=20, color=BLUE)
        p1.move_to(4.5 * LEFT)
        p2 = PointCloudDot()
        p3 = PointCloudDot(radius=1.5, stroke_width=2.5, color=PINK)
        p3.move_to(4.5 * RIGHT)
        pList = PGroup(p1, p2, p3)

        self.add(pList)","Create a Manim Scene that displays three PointCloudDots arranged as follows: the first is a blue PointCloudDot with radius=1, density=20 positioned 4.5 units to the left; the second is a default PointCloudDot centered, and the third is a pink PointCloudDot with radius=1.5, stroke_width=2.5 placed 4.5 units to the right. Group all three using PGroup and add them to the scene."
"from manim import *

class PMobjectExample(Scene):
    def construct(self):

        pG = PGroup()  # This is just a collection of PMobject's

        # As the scale factor increases, the number of points
        # removed increases.
        for sf in range(1, 9 + 1):
            p = PointCloudDot(density=20, radius=1).thin_out(sf)
            # PointCloudDot is a type of PMobject
            # and can therefore be added to a PGroup
            pG.add(p)

        # This organizes all the shapes in a grid.
        pG.arrange_in_grid()

        self.add(pG)","Create a Manim animation scene that displays a grid of PointCloudDot objects. Each dot in the grid should have a progressively higher 'thin_out' factor applied to it, starting from 1 and increasing up to 9. The dots must be arranged in a grid layout to visually demonstrate how the thin_out parameter reduces the number of visible points when applied. Each PointCloudDot should have a fixed radius of 1 and a base density of 20, with the thinning effect becoming more pronounced for each subsequent dot in the grid. Use PMobject-based grouping and arrangement methods to organize the shapes."
"from manim import *

class ExamplePoint(Scene):
    def construct(self):
        colorList = [RED, GREEN, BLUE, YELLOW]
        for i in range(200):
            point = Point(location=[0.63 * np.random.randint(-4, 4), 0.37 * np.random.randint(-4, 4), 0], color=np.random.choice(colorList))
            self.add(point)
        for i in range(200):
            point = Point(location=[0.37 * np.random.randint(-4, 4), 0.63 * np.random.randint(-4, 4), 0], color=np.random.choice(colorList))
            self.add(point)
        self.add(point)","Create a Manim Python code for an animation scene where: 

1. Two groups of points are displayed: 
   - First group has 200 points with coordinates (0.63 * random_int, 0.37 * random_int), 0). Here, random_int is a randomly selected integer between -4 and 3 (inclusive range) for each coordinate individually (different integers for x and y axes). Colors are randomly chosen from [RED, GREEN, BLUE, YELLOW]. 
   
2. Second group has 200 points swapping multipliers: x-coordinate uses 0.37*random_int and y uses 0.63*random_int, maintaining the same coordinate ranges and color selection.
   
3. After both groups are created and added using self.add(), the last point (from the second group) is added one extra time with an additional self.add() call.

The points must be initialized as Point objects with precise coordinate formulas. The scene should display them all statically without animations."
"from manim import *

class PointCloudDotExample(Scene):
    def construct(self):
        cloud_1 = PointCloudDot(color=RED)
        cloud_2 = PointCloudDot(stroke_width=4, radius=1)
        cloud_3 = PointCloudDot(density=15)

        group = Group(cloud_1, cloud_2, cloud_3).arrange()
        self.add(group)",Create a Manim scene that displays three PointCloudDot objects arranged in a row. The first dot should be colored red. The second dot must have a stroke width of 4 and a larger radius of 1. The third dot needs to have a higher density value of 15. All three dots should be positioned next to each other horizontally on the screen.
"from manim import *

class PointCloudDotExample2(Scene):
    def construct(self):
        plane = ComplexPlane()
        cloud = PointCloudDot(color=RED)
        self.add(
            plane, cloud
        )
        self.wait()
        self.play(
            cloud.animate.apply_complex_function(lambda z: np.exp(z))
        )","Create a Manim animation scene where a red PointCloudDot is initially displayed on a ComplexPlane. The animation should start by showing both the coordinate plane and the dot stationary for a short moment. Then, animate the dot undergoing a smooth transformation as it moves according to the application of the complex exponential function e^z to its position. The transformation should visually represent how each point's complex coordinate is transformed by the function over time. Maintain the red color of the PointCloudDot throughout the animation."
"from manim import *

class LineGradientExample(Scene):
    def construct(self):
        curve = ParametricFunction(lambda t: [t, np.sin(t), 0], t_range=[-PI, PI, 0.01], stroke_width=10)
        new_curve = CurvesAsSubmobjects(curve)
        new_curve.set_color_by_gradient(BLUE, RED)
        self.add(new_curve.shift(UP), curve)","Design a Manim animation scene showing two overlapping sine wave curves traced from t = -π to π with stroke width 10. The bottom curve shows the standard line version, while the top curve is the same sine wave but lifted one unit upwards and colored with a gradient that progresses smoothly from blue on the leftmost end to red on the rightmost end. The gradient must visibly transition along the entire length of the top curve's path. Both curves must appear simultaneously in their respective positions."
"from manim import *

class DashedVMobjectExample(Scene):
    def construct(self):
        r = 0.5

        top_row = VGroup()  # Increasing num_dashes
        for dashes in range(1, 12):
            circ = DashedVMobject(Circle(radius=r, color=WHITE), num_dashes=dashes)
            top_row.add(circ)

        middle_row = VGroup()  # Increasing dashed_ratio
        for ratio in np.arange(1 / 11, 1, 1 / 11):
            circ = DashedVMobject(
                Circle(radius=r, color=WHITE), dashed_ratio=ratio
            )
            middle_row.add(circ)

        func1 = FunctionGraph(lambda t: t**5,[-1,1],color=WHITE)
        func_even = DashedVMobject(func1,num_dashes=6,equal_lengths=True)
        func_stretched = DashedVMobject(func1, num_dashes=6, equal_lengths=False)
        bottom_row = VGroup(func_even,func_stretched)

        top_row.arrange(buff=0.3)
        middle_row.arrange()
        bottom_row.arrange(buff=1)
        everything = VGroup(top_row, middle_row, bottom_row).arrange(DOWN, buff=1)
        self.add(everything)","""Create a Manim animation scene that displays three horizontal rows of dashed shapes arranged vertically on the screen. The top row shows a series of white circles where each subsequent circle has an increased number of dashes, starting from 1 dash up to 11 dashes. The middle row shows circles where the dash pattern gradually changes from small dashes with large gaps to almost solid lines by varying the dashed_ratio parameter. The bottom row has two versions of a fifth-degree polynomial graph (f(x)=x⁵) displayed side-by-side: the first uses equally spaced dashes and the second uses dashes with uneven lengths. All elements should be arranged in three main rows with vertical spacing between rows and horizontal spacing between elements. Each row should showcase how different parameters affect the dashed styling of shapes and graphs."""
"from manim import *

class ShapesWithVDict(Scene):
    def construct(self):
        square = Square().set_color(RED)
        circle = Circle().set_color(YELLOW).next_to(square, UP)

        # create dict from list of tuples each having key-mobject pair
        pairs = [(""s"", square), (""c"", circle)]
        my_dict = VDict(pairs, show_keys=True)

        # display it just like a VGroup
        self.play(Create(my_dict))
        self.wait()

        text = Tex(""Some text"").set_color(GREEN).next_to(square, DOWN)

        # add a key-value pair by wrapping it in a single-element list of tuple
        # after attrs branch is merged, it will be easier like `.add(t=text)`
        my_dict.add([(""t"", text)])
        self.wait()

        rect = Rectangle().next_to(text, DOWN)
        # can also do key assignment like a python dict
        my_dict[""r""] = rect

        # access submobjects like a python dict
        my_dict[""t""].set_color(PURPLE)
        self.play(my_dict[""t""].animate.scale(3))
        self.wait()

        # also supports python dict styled reassignment
        my_dict[""t""] = Tex(""Some other text"").set_color(BLUE)
        self.wait()

        # remove submobject by key
        my_dict.remove(""t"")
        self.wait()

        self.play(Uncreate(my_dict[""s""]))
        self.wait()

        self.play(FadeOut(my_dict[""c""]))
        self.wait()

        self.play(FadeOut(my_dict[""r""], shift=DOWN))
        self.wait()

        # you can also make a VDict from an existing dict of mobjects
        plain_dict = {
            1: Integer(1).shift(DOWN),
            2: Integer(2).shift(2 * DOWN),
            3: Integer(3).shift(3 * DOWN),
        }

        vdict_from_plain_dict = VDict(plain_dict)
        vdict_from_plain_dict.shift(1.5 * (UP + LEFT))
        self.play(Create(vdict_from_plain_dict))

        # you can even use zip
        vdict_using_zip = VDict(zip([""s"", ""c"", ""r""], [Square(), Circle(), Rectangle()]))
        vdict_using_zip.shift(1.5 * RIGHT)
        self.play(Create(vdict_using_zip))
        self.wait()","Develop a Manim animation scene that displays the following visual elements and their transitions with VDict (Visual Dictionary):
1. Start with a red square. Above it, a yellow circle appears. 
2. Show a dictionary-style display (VDict) with keys 's' (square) and 'c' (circle), showing both elements and their labels.
3. A green ""Some Text"" appears below the square, added to VDict under 't'.
4. Add a rectangle below the text as key 'r' in the dictionary. Change text 't' to purple, scale it up, then replace it with a smaller blue text before removing the 't' entry.
5. Animate:
   - Remove square with 'Uncreate',
   - Fade-out the circle ,
   - Fade down the rectangle.
6. Create VDict #2 on the left upper side: keys 1, 2, 3 with correspondin numbers displayed vertically (1 top, 3 bottom).
7. Finally show VDict #3 on the right with keys 's', 'c', 'r' linked to square, circle, rectangle arranged together.
Ensure all key-based additions/updates/deletions are shown dynamically with transitions between actions. Use Create/FadeOut animations between steps, with key-based manipulation syntax (e.g., my_dict['key'].set_color()). Include shifts where needed (rect at text's bottom; numbered keys shifted up-left; final VDict on rightside via zip pairing)."
"from manim import *

class ArcShapeIris(Scene):
    def construct(self):
        colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]
        radius = [1 + rad * 0.1 for rad in range(len(colors))]

        circles_group = VGroup()

        # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]
        circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)
                            for rad, col in zip(radius, colors)])
        self.add(circles_group)","Create a Manim animation scene displaying concentric circles starting from the center. The circles should have increasing radii, each 0.1 units larger than the previous, with the first circle (smallest) having a radius of 1.0. The colors of the circles must follow this exact sequence: DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E. Arrange the circles so they are perfectly centered and visually overlap each other, creating a layered iris-like shape. The animation should display all circles static on the screen without any movement or transformation after rendering."
"from manim import *

class AddToVGroup(Scene):
    def construct(self):
        circle_red = Circle(color=RED)
        circle_green = Circle(color=GREEN)
        circle_blue = Circle(color=BLUE)
        circle_red.shift(LEFT)
        circle_blue.shift(RIGHT)
        gr = VGroup(circle_red, circle_green)
        gr2 = VGroup(circle_blue) # Constructor uses add directly
        self.add(gr,gr2)
        self.wait()
        gr += gr2 # Add group to another
        self.play(
            gr.animate.shift(DOWN),
        )
        gr -= gr2 # Remove group
        self.play( # Animate groups separately
            gr.animate.shift(LEFT),
            gr2.animate.shift(UP),
        )
        self.play( #Animate groups without modification
            (gr+gr2).animate.shift(RIGHT)
        )
        self.play( # Animate group without component
            (gr-circle_red).animate.shift(RIGHT)
        )","Design an animation scene in Manim where three colored circles (red, green, blue) are initially positioned left, center, and right. The red and green form a group ""gr"", while blue is in a separate group ""gr2"". Show the following sequence: 1) Both groups move down together when merged temporarily. 2) Split the groups to move the original ""gr"" left and blue up separately. 3) Re-combine groups to shift all right collectively. 4) Remove red and shift the remaining green and blue right. Highlight group operations (add/remove elements) and synchronized/individual movements using VGroup manipulations like addition/subtraction of subgroups."
"from manim import *

class AddIterableToVGroupExample(Scene):
    def construct(self):
        v = VGroup(
            Square(),               # Singular VMobject instance
            [Circle(), Triangle()], # List of VMobject instances
            Dot(),
            (Dot() for _ in range(2)), # Iterable that generates VMobjects
        )
        v.arrange()
        self.add(v)","Create a Manim animation scene demonstrating the following:  
1. Create a VGroup containing:  
   - A single Square,  
   - A list containing a Circle and a Triangle,  
   - A Dot,  
   - An iterable (e.g., a generator expression) producing two additional Dots.  
2. Automatically position all these elements in an arranged layout.  
3. Ensure the final composition shows all elements spaced and organized in the scene. Specify their initialization as part of the VGroup and their static arrangement using `arrange()`. Include necessary syntax for mixed VMobject types (individual instances, lists, and iterables) in the VGroup constructor."
"from manim import *

class PointFromProportion(Scene):
    def construct(self):
        line = Line(2*DL, 2*UR)
        self.add(line)
        colors = (RED, BLUE, YELLOW)
        proportions = (1/4, 1/2, 3/4)
        for color, proportion in zip(colors, proportions):
            self.add(Dot(color=color).move_to(
                    line.point_from_proportion(proportion)
            ))","Create a Manim animation scene where a line is drawn from the point 2 times the bottom-left direction (2*DL) to 2 times the upper-right direction (2*UR). Along this line, position a red dot at 25% (1/4 proportion), a blue dot at 50% (1/2), and a yellow dot at 75% (3/4) of the line's length. The dots should be placed exactly at those proportional points along the line and remain stationary after being added to the scene."
"from manim import *

class ChangeOfDirection(Scene):
    def construct(self):
        ccw = RegularPolygon(5)
        ccw.shift(LEFT)
        cw = RegularPolygon(5)
        cw.shift(RIGHT).reverse_direction()

        self.play(Create(ccw), Create(cw),
        run_time=4)","""Create a Manim animation scene showing two regular pentagons (5-sided polygons). Position the first pentagon on the left side of the screen and the second on the right. Reverse the direction (orientation) of the pentagon on the right. Simultaneously animate both shapes being drawn/stroked from start to finish with a 4-second duration for both animations."""
"from manim import *

class MobjectScaleExample(Scene):
    def construct(self):
        c1 = Circle(1, RED).set_x(-1)
        c2 = Circle(1, GREEN).set_x(1)

        vg = VGroup(c1, c2)
        vg.set_stroke(width=50)
        self.add(vg)

        self.play(
            c1.animate.scale(.25),
            c2.animate.scale(.25,
                scale_stroke=True)
        )","""Design a Manim scene where two circles (red on the left at x=-1, green on the right at x=1) are initially grouped with a stroke width of 50. Animate both circles shrinking to 25% of their size. During the scaling, ensure the green circle’s stroke width reduces proportionally while the red circle’s stroke remains unchanged. Output the Python code using the Manim library."""
"from manim import *

class CapStyleExample(Scene):
    def construct(self):
        line = Line(LEFT, RIGHT, color=YELLOW, stroke_width=20)
        line.set_cap_style(CapStyleType.ROUND)
        self.add(line)","""Create a Manim animation scene that demonstrates a line with a round cap style. The line should be positioned horizontally spanning from the left edge to the right edge of the screen. Use yellow color for the line with a stroke width of 20 units. The endpoints should clearly show rounded caps. The scene should be a static display without any movement or transformations."""
"from manim import *

class SetFill(Scene):
    def construct(self):
        square = Square().scale(2).set_fill(WHITE,1)
        circle1 = Circle().set_fill(GREEN,0.8)
        circle2 = Circle().set_fill(YELLOW) # No fill_opacity
        circle3 = Circle().set_fill(color = '#FF2135', opacity = 0.2)
        group = Group(circle1,circle2,circle3).arrange()
        self.add(square)
        self.add(group)","""Create a Manim animation for a scene containing a white square scaled to twice its original size (100% fill opacity), overlapped with three horizontally arranged circles. The circles must be: first circle filled with green at 80% opacity, second with yellow at default fill opacity, and third using hex color '#FF2135' with 20% opacity. Arrange the circles side-by-side as a group positioned over the square."""
"from manim import *

class PointsAsCornersExample(Scene):
    def construct(self):
        corners = (
            # create square
            UR, UL,
            DL, DR,
            UR,
            # create crosses
            DL, UL,
            DR
        )
        vmob = VMobject(stroke_color=RED)
        vmob.set_points_as_corners(corners).scale(2)
        self.add(vmob)","Write a Manim Python code to create an animation where a red line forms the following sequence of connections between corner points: starting at top-right (UR), moving to top-left (UL), bottom-left (DL), bottom-right (DR), returning to starting UR, then going to DL again, moving to UL, and ending at bottom-right DR. The figure should be drawn as a single unbroken path and scaled to twice the default size."
"from manim import *

class SetSheen(Scene):
    def construct(self):
        circle = Circle(fill_opacity=1).set_sheen(-0.3, DR)
        self.add(circle)","Design a Manim animation scene that displays a solid filled circle (100% fill opacity). The circle must have a sheen effect applied with a value of -0.3 directed toward the down-right (DR) direction. The animation should only show the static circle without any movement, transformations, or additional elements."
"from manim import *

class HeightExample(Scene):
    def construct(self):
        decimal = DecimalNumber().to_edge(UP)
        rect = Rectangle(color=BLUE)
        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)

        decimal.add_updater(lambda d: d.set_value(rect.height))

        self.add(rect_copy, rect, decimal)
        self.play(rect.animate.set(height=5))
        self.wait()","Create a Manim animation scene where a blue rectangle dynamically changes its vertical size. Include a gray semi-transparent rectangle (with 50% opacity) positioned behind the blue one as a static reference. Add a DecimalNumber at the top of the screen that continuously updates to display the current height value of the blue rectangle in real-time. Initially, both rectangles share the same position and size. The scene should then animate the blue rectangle expanding vertically to a final height of 5 units while the gray rectangle remains unchanged. Ensure the animation runs smoothly, and the number updates continuously during the transformation. After the animation, pause the scene briefly to display the final state."
"from manim import *

class WidthExample(Scene):
    def construct(self):
        decimal = DecimalNumber().to_edge(UP)
        rect = Rectangle(color=BLUE)
        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)

        decimal.add_updater(lambda d: d.set_value(rect.width))

        self.add(rect_copy, rect, decimal)
        self.play(rect.animate.set(width=7))
        self.wait()","Create a Manim animation scene that demonstrates a rectangle's width change with real-time numeric updates. The scene should include: (1) a blue rectangle and a semi-transparent (50% opacity) gray copy positioned behind it, (2) a DecimalNumber displayed at the top edge of the frame, dynamically showing the current width of the blue rectangle, (3) an animation where the blue rectangle’s width expands to 7 units while maintaining its center position, and (4) a brief pause after the animation completes. The decimal value must update continuously during the rectangle's width transition."
"from manim import *

class ComplexValueTrackerExample(Scene):
    def construct(self):
        tracker = ComplexValueTracker(-2+1j)
        dot = Dot().add_updater(
            lambda x: x.move_to(tracker.points)
        )

        self.add(NumberPlane(), dot)

        self.play(tracker.animate.set_value(3+2j))
        self.play(tracker.animate.set_value(tracker.get_value() * 1j))
        self.play(tracker.animate.set_value(tracker.get_value() - 2j))
        self.play(tracker.animate.set_value(tracker.get_value() / (-2 + 3j)))","Create a Manim animation scene demonstrating transformations of a complex number using a dot and ComplexValueTracker. The scene should start with a NumberPlane. A dot must follow the position determined by a ComplexValueTracker initialized at (-2, 1). The animation should include these sequential transformations:  
1. Move the dot from (-2, 1) to (3, 2) in the first animation.  
2. Multiply the current value by 1j (rotating 90° counterclockwise and adjusting position accordingly) in the second animation.  
3. Subtract 2j from the current value (moving downward by 2 units on the imaginary axis) in the third animation.  
4. Divide the current value by (-2 + 3j), scaling and rotating to the new position in the fourth animation. Use animate-driven updates for all changes, ensuring the dot smoothly follows each transformation."
"from manim import *

class ValueTrackerExample(Scene):
    def construct(self):
        number_line = NumberLine()
        pointer = Vector(DOWN)
        label = MathTex(""x"").add_updater(lambda m: m.next_to(pointer, UP))

        tracker = ValueTracker(0)
        pointer.add_updater(
            lambda m: m.next_to(
                        number_line.n2p(tracker.get_value()),
                        UP
                    )
        )
        self.add(number_line, pointer,label)
        tracker += 1.5
        self.wait(1)
        tracker -= 4
        self.wait(0.5)
        self.play(tracker.animate.set_value(5))
        self.wait(0.5)
        self.play(tracker.animate.set_value(3))
        self.play(tracker.animate.increment_value(-2))
        self.wait(0.5)","Design a Manim animation scene that must include the following visual elements and movements in sequence:

- Display a number line with a downward-pointing arrow (pointer) at position 0. A label ""x"" must dynamically stay above the pointer as it moves.

Movement sequence:
1. IMMEDIATELY shift the pointer to +1.5 ON THE NUMBER LINE (no animation, instant jump). Hold this position for 1 full second.
2. Instantly move the pointer to position -2.5 without animation. Pause for 0.5 seconds.
3. ANIMATED MOVEMENT to position 5, showing a smooth slide along the number line. (takes default animation time, e.g., 1 second.)
4. After reaching 5, wait 0.5 seconds.
5. ANIMATED transition to position 3.
6. Then ANIMATED move an additional 2 units to the LEFT (ends at position 1).).
7. Conclude with a 0.5-second hold at position 1.

The label ""x"" must continuously update its position to follow the moving pointer through all transitions. The pointer graphic should remain above its associated point on the number line at all times."
"from manim import *

class ValueTrackerExample(Scene):
    def construct(self):
        tracker = ValueTracker(0)
        label = Dot(radius=3).add_updater(lambda x : x.set_x(tracker.get_value()))
        self.add(label)
        self.add(tracker)
        tracker.add_updater(lambda mobject, dt: mobject.increment_value(dt))
        self.wait(2)","Create a Manim animation where a large dot (radius 3 times default size) starts at the center of the screen and moves smoothly to the right at a constant speed of 1 unit per second. The dot's horizontal position increases continuously over time, with its motion based on real-time passage rather than fixed path interpolation. The animation should run for exactly 2 seconds, continuously displaying the dot's position change over this duration."
"from manim import *

class BasicUsage(Scene):
    def construct(self):
        func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3
        self.add(ArrowVectorField(func))",Create a Manim animation scene showing an arrow vector field where each arrow's direction is determined by the formula: (x-component multiplied by UR vector plus y-component multiplied by LEFT vector minus the original position vector) divided by 3. The arrows should dynamically represent this vector field across the entire scene using Manim's ArrowVectorField class. Include the full Python code defining the scene class with the required lambda function for vector calculation.
"from manim import *

class SizingAndSpacing(Scene):
    def construct(self):
        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT
        vf = ArrowVectorField(func, x_range=[-7, 7, 1])
        self.add(vf)
        self.wait()

        length_func = lambda x: x / 3
        vf2 = ArrowVectorField(func, x_range=[-7, 7, 1], length_func=length_func)
        self.play(vf.animate.become(vf2))
        self.wait()","Create a Manim animation scene where:  
1. An arrow vector field is initially displayed, where each vector combines a sine component in the upper-right (UR) direction based on the x-position and a cosine component to the left (LEFT) based on the y-position.  
2. The vector field spans the coordinates from -7 to 7 on both axes, with grid spacing of 1 unit.  
3. After a short pause, the vectors smoothly transition to a scaled-down version of themselves, shrinking to one-third of their original length.  
4. The transformation should animate the resizing of all vectors in place without shifting their positions.  
5. Include a pause at the beginning and end of the animation to show the before/after states clearly.  

Specify the scene using Manim's ArrowVectorField, lambda functions for vector calculation and length scaling, and animation transitions like become()."
"from manim import *

class Coloring(Scene):
    def construct(self):
        func = lambda pos: pos - LEFT * 5
        colors = [RED, YELLOW, BLUE, DARK_GRAY]
        min_radius = Circle(radius=2, color=colors[0]).shift(LEFT * 5)
        max_radius = Circle(radius=10, color=colors[-1]).shift(LEFT * 5)
        vf = ArrowVectorField(
            func, min_color_scheme_value=2, max_color_scheme_value=10, colors=colors
        )
        self.add(vf, min_radius, max_radius)","""Please write Manim code for an animation scene. The scene must display two concentric circles at 5 units left of center: the inner circle has a radius of 2 (red), the larger 10 (darkgray. Between them is a vector field with arrow colors transitioning from red → yellow → blue → dark gray as distance increases from the center point (at -5 on x-axis). The arrow vectors should use a function that represents movement from the initial left position. The vector field must specify a minimum of 2 and maximum of 10 for color grading, and the vector field uses arrow tips pointing in the direction based on their distance from the center point."""
"from manim import *

class SpawningAndFlowingArea(Scene):
    def construct(self):
        func = lambda pos: np.sin(pos[0]) * UR + np.cos(pos[1]) * LEFT + pos / 5
        stream_lines = StreamLines(
            func, x_range=[-3, 3, 0.2], y_range=[-2, 2, 0.2], padding=1
        )

        spawning_area = Rectangle(width=6, height=4)
        flowing_area = Rectangle(width=8, height=6)
        labels = [Tex(""Spawning Area""), Tex(""Flowing Area"").shift(DOWN * 2.5)]
        for lbl in labels:
            lbl.add_background_rectangle(opacity=0.6, buff=0.05)

        self.add(stream_lines, spawning_area, flowing_area, *labels)","Create an animation scene using Manim showing two labeled rectangular regions (""Spawning Area"" and ""Flowing Area"") with background rectangles for their labels. The Spawning Area is a smaller rectangle (6x4 units), centered) labeled with ""Spawning Area"" above it, while the larger Flowing Area (8x6 units, centered) has its label positioned below the first label. Show streaming lines across the entire scene representing a vector field whose direction combines sin(x) for upward-right motion and cos(y) for leftward motion, scaled by 1/5 of the position vector. The stream lines should span x-ranges from -3 to 3 (0.2 unit steps), y-ranges from -2 to 2 (0.2 steps), with padding=1 to fill the scene edges. All elements are displayed simultaneously without motion, but the stream lines visually demonstrate the vector field’s flow pattern."
"from manim import *

class StreamLineCreation(Scene):
    def construct(self):
        func = lambda pos: (pos[0] * UR + pos[1] * LEFT) - pos
        stream_lines = StreamLines(
            func,
            color=YELLOW,
            x_range=[-7, 7, 1],
            y_range=[-4, 4, 1],
            stroke_width=3,
            virtual_time=1,  # use shorter lines
            max_anchors_per_line=5,  # better performance with fewer anchors
        )
        self.play(stream_lines.create())  # uses virtual_time as run_time
        self.wait()","Write a Manim Python code for an animation scene displaying the formation of a vector field's stream lines through the following specifications:

- The vector field is computed by the lambda function: `(pos[0] * UR + pos[1] * LEFT) - pos`.
- Stream lines appear in **yellow** with a **stroke width of 3**.
- The grid spans an **x-axis from -7 to 7** and **y-axis from -4 to 4**, each divided into **1-unit intervals**.
- Configure `virtual_time=1` to shorten line segments and `max_anchors_per_line=5` for performance optimization without sacrificing clarity.
- The animation should gradually ""draw"" the stream lines using the `create()` method as the primary animation, following which the screen pauses briefly.

Provide the complete code for the scene, including all initialization parameters, animations, and timing parameters."
"from manim import *

class EndAnimation(Scene):
    def construct(self):
        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT
        stream_lines = StreamLines(
            func, stroke_width=3, max_anchors_per_line=5, virtual_time=1, color=BLUE
        )
        self.add(stream_lines)
        stream_lines.start_animation(warm_up=False, flow_speed=1.5, time_width=0.5)
        self.wait(1)
        self.play(stream_lines.end_animation())","Create a Manim animation scene showing the following sequence: 

1. A flow of blue stream lines initially displayed across the screen, following a vector field defined by combining a sine wave moving upwards-right (based on the x-position) and a cosine wave moving left (based on the y-position). 
2. The stream lines then begin a fluid animation where they flow according to the vector field, with a faster movement speed (1.5x) and narrower time width for smoother transitions, without any initial warm-up phase. 
3. After a 1-second pause, the animation transitions into a controlled dissolve or fade-out effect ending the stream line motion. 
4. Specify parameters: blue color, stroke thickness of 3, and limited anchor points per line (max 5) to maintain performance."
"from manim import *

class ContinuousMotion(Scene):
    def construct(self):
        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT
        stream_lines = StreamLines(func, stroke_width=3, max_anchors_per_line=30)
        self.add(stream_lines)
        stream_lines.start_animation(warm_up=False, flow_speed=1.5)
        self.wait(stream_lines.virtual_time / stream_lines.flow_speed)","""Design a Manim animation scene that demonstrates continuous fluid-like motion using stream lines. The stream lines should visualize a vector field where each point's velocity is determined by: (1) a sine function of the x-coordinate divided by 2, directed diagonally upward-right (UR direction), and (2) a cosine function of the y-coordinate divided by 2, directed to the left. Configure stream lines with a stroke width of 3 and limit each line to 30 anchor points. Initiate the animation without a warm-up phase, set flow speed to 1.5, and ensure the scene plays until the full animation cycle completes based on virtual time calculation."""
"from manim import *

class Nudging(Scene):
    def construct(self):
        func = lambda pos: np.sin(pos[1] / 2) * RIGHT + np.cos(pos[0] / 2) * UP
        vector_field = ArrowVectorField(
            func, x_range=[-7, 7, 1], y_range=[-4, 4, 1], length_func=lambda x: x / 2
        )
        self.add(vector_field)
        circle = Circle(radius=2).shift(LEFT)
        self.add(circle.copy().set_color(GRAY))
        dot = Dot().move_to(circle)

        vector_field.nudge(circle, -2, 60, True)
        vector_field.nudge(dot, -2, 60)

        circle.add_updater(vector_field.get_nudge_updater(pointwise=True))
        dot.add_updater(vector_field.get_nudge_updater())
        self.add(circle, dot)
        self.wait(6)","Create an animation scene using Manim where the following elements and their dynamics are realized:

1. **Vector Field Setup**: Show a vector field defined by the function `func(pos)`, where each vector at position (x,y) has a horizontal component `sin(y/2)` and vertical component `cos(x/2)`, scaled down by half in magnitude. The field spans from x: -7 to 7 and y: -4 to 4.

2. **Initial Setup**:
   - Draw a **gray reference circle** (radius 2) positioned 1 unit to the left of the origin. Keep it stationary as a background reference.
   - Create a filled **colored circle** (radius 2) in the same initial position, identical to the reference but dynamically movable.
   - Add a **dot** at the starting position of the movable circle's perimeter.

3. **Dynamic Nudging**:
   - The movable circle and its center dot must undergo simultaneous motion following these rules:
     * For the circle's shape: its edges respond individually (pointwise) following the vector field, but slower by a factor of -2 (opposing direction) with 60% magnitude.
     * For the dot: it responds to the vector field at its instantaneous position, also slowed by -2 (opposite motion).
     * Both updates occur in real-time using continuous updaters during animation.

4. **Animation Timing**: Run continuous motion for 6 seconds, showing how the circle's shape morphs and the dot drifts along paths determined by the vector field, while the background gray circle remains fixed for comparison."
"from manim import *

class ScaleVectorFieldFunction(Scene):
    def construct(self):
        func = lambda pos: np.sin(pos[1]) * RIGHT + np.cos(pos[0]) * UP
        vector_field = ArrowVectorField(func)
        self.add(vector_field)
        self.wait()

        func = VectorField.scale_func(func, 0.5)
        self.play(vector_field.animate.become(ArrowVectorField(func)))
        self.wait()","Create a Manim animation scene that starts with a vector field where each vector is defined by the function: the x-component is sin(y) and the y-component is cos(x). Display this vector field using arrow vectors. Then, smoothly scale the entire vector field's magnitude by a factor of 0.5, showing the transformation animation where every vector simultaneously adjusts its length to the new scaled size. The scene should include transitions between the original and scaled vector fields with appropriate waiting periods to observe both states."
"from manim import *

class ChangingCameraWidthAndRestore(MovingCameraScene):
    def construct(self):
        text = Text(""Hello World"").set_color(BLUE)
        self.add(text)
        self.camera.frame.save_state()
        self.play(self.camera.frame.animate.set(width=text.width * 1.2))
        self.wait(0.3)
        self.play(Restore(self.camera.frame))","Create a Manim animation scene that starts with the text ""Hello World"" displayed in blue. First, the camera frame should smoothly adjust its width to 1.2 times the width of the text, centering and focusing on the text with some padding. After holding this view for 0.3 seconds, the camera frame must instantly return to its original size and position. Ensure the camera's initial state is saved before modifying it, and use smooth transitions for both the zoom and the restoration."
"from manim import *

class MovingCameraCenter(MovingCameraScene):
    def construct(self):
        s = Square(color=RED, fill_opacity=0.5).move_to(2 * LEFT)
        t = Triangle(color=GREEN, fill_opacity=0.5).move_to(2 * RIGHT)
        self.wait(0.3)
        self.add(s, t)
        self.play(self.camera.frame.animate.move_to(s))
        self.wait(0.3)
        self.play(self.camera.frame.animate.move_to(t))","Design a Manim animation showing a red square (half-transparent) positioned 2 units to the left and a green triangle (half-transparent) positioned 2 units to the right. The animation should start by displaying both shapes together for 0.3 seconds. Then smoothly transition the camera view to center on the square, hold that view for 0.3 seconds, then shift the camera to center on the triangle. The camera movements should be animated transitions between these focal points."
"from manim import *

class MovingAndZoomingCamera(MovingCameraScene):
    def construct(self):
        s = Square(color=BLUE, fill_opacity=0.5).move_to(2 * LEFT)
        t = Triangle(color=YELLOW, fill_opacity=0.5).move_to(2 * RIGHT)
        self.add(s, t)
        self.play(self.camera.frame.animate.move_to(s).set(width=s.width*2))
        self.wait(0.3)
        self.play(self.camera.frame.animate.move_to(t).set(width=t.width*2))

        self.play(self.camera.frame.animate.move_to(ORIGIN).set(width=14))","Create a Manim animation where a blue square (fill opacity 0.5) is placed 2 units to the left and a yellow triangle (fill opacity 0.5) is placed 2 units to the right. Start by zooming the camera frame to focus on the square, scaling its width to double. After a 0.3-second pause, smoothly transition the camera to focus on the triangle, scaling its width to double. Finally, return the camera to center position with full screen view (width=14). Use smooth transitions between all camera movements."
"from manim import *

class MovingCameraOnGraph(MovingCameraScene):
    def construct(self):
        self.camera.frame.save_state()

        ax = Axes(x_range=[-1, 10], y_range=[-1, 10])
        graph = ax.plot(lambda x: np.sin(x), color=WHITE, x_range=[0, 3 * PI])

        dot_1 = Dot(ax.i2gp(graph.t_min, graph))
        dot_2 = Dot(ax.i2gp(graph.t_max, graph))
        self.add(ax, graph, dot_1, dot_2)

        self.play(self.camera.frame.animate.scale(0.5).move_to(dot_1))
        self.play(self.camera.frame.animate.move_to(dot_2))
        self.play(Restore(self.camera.frame))
        self.wait()","Design a Manim animation scene showing a camera moving and zooming on a graph. First, display a coordinate system (Axes) with x and y ranges from -1 to 10. Plot a white sine curve from x=0 to 3π. Add a small dot at the start and end of the sine curve. Animate the camera to: 1) zoom in (scale to 50% size) and move to the first dot, 2) move to the second dot without changing zoom level, 3) return to the initial camera frame position and size, then pause. Include all elements and transition steps in the animation sequence."
"from manim import *

class SlidingMultipleScenes(MovingCameraScene):
    def construct(self):
        def create_scene(number):
            frame = Rectangle(width=16,height=9)
            circ = Circle().shift(LEFT)
            text = Tex(f""This is Scene {str(number)}"").next_to(circ, RIGHT)
            frame.add(circ,text)
            return frame

        group = VGroup(*(create_scene(i) for i in range(4))).arrange_in_grid(buff=4)
        self.add(group)
        self.camera.auto_zoom(group[0], animate=False)
        for scene in group:
            self.play(self.camera.auto_zoom(scene))
            self.wait()

        self.play(self.camera.auto_zoom(group, margin=2))","""Create an animation showing multiple numbered scenes arranged in a grid layout with spacing between them. Each scene must include a circle on the left and a text label stating 'This is Scene X' on the right, enclosed within a rectangular frame. The camera should initially zoom into the first scene, then transition smoothly to focus on each subsequent scene in sequence, pausing briefly at each, before finally panning out to display all scenes simultaneously in their grid layout. Use smooth camera transitions between each focus."""
"from manim import *

class SoundExample(Scene):
    # Source of sound under Creative Commons 0 License. https://freesound.org/people/Druminfected/sounds/250551/
    def construct(self):
        dot = Dot().set_color(GREEN)
        self.add_sound(""click.wav"")
        self.add(dot)
        self.wait()
        self.add_sound(""click.wav"")
        dot.set_color(BLUE)
        self.wait()
        self.add_sound(""click.wav"")
        dot.set_color(RED)
        self.wait()","Create a Manim animation where a dot's color transitions through three phases. Begin with a green dot appearing as a 'click.wav' sound plays. After a brief pause, another click triggers the dot turning blue. A third click sound changes it to red, with delays between each transition. Each color change occurs immediately after the sound plays, followed by a waiting period. Use the sound file ""click.wav"" (under Creative Commons 0 License) from freesound.org for all transitions."
"from manim import *

class LinearTransformationSceneExample(LinearTransformationScene):
    def __init__(self, **kwargs):
        LinearTransformationScene.__init__(
            self,
            show_coordinates=True,
            leave_ghost_vectors=True,
            **kwargs
        )

    def construct(self):
        matrix = [[1, 1], [0, 1]]
        self.apply_matrix(matrix)
        self.wait()","Create a Manim animation showing a linear transformation with the following visual elements and actions:
1. Start with a coordinate plane displaying the standard basis vectors
2. Keep ghost vector images visible after each transformation
3. Apply the linear transformation represented by the matrix [[1, 1], [0, 1]]
   - This should shear the coordinate system horizontally 
   - Show the transformation animation of the basis vectors and grid 
4. Pause briefly at the end to display the transformed coordinate system with all ghost vectors remaining
Maintain the coordinate axes throughout the transformation. Use default Manim styling and colors for grid lines, vectors, and coordinate display."
"from manim import *

class UseZoomedScene(ZoomedScene):
    def construct(self):
        dot = Dot().set_color(GREEN)
        self.add(dot)
        self.wait(1)
        self.activate_zooming(animate=False)
        self.wait(1)
        self.play(dot.animate.shift(LEFT))","Create a Manim animation scene where a green dot is first displayed stationary for 1 second. Then, activate a zoomed view without animation, wait 1 more second. Finally, animate the dot moving towards the left direction using a shift transformation. Use ZoomedScene subclass for this scene, and ensure the dot is initially positioned before activating the zoom."
"from manim import *

class ChangingZoomScale(ZoomedScene):
    def __init__(self, **kwargs):
        ZoomedScene.__init__(
            self,
            zoom_factor=0.3,
            zoomed_display_height=1,
            zoomed_display_width=3,
            image_frame_stroke_width=20,
            zoomed_camera_config={
                ""default_frame_stroke_width"": 3,
            },
            **kwargs
        )

    def construct(self):
        dot = Dot().set_color(GREEN)
        sq = Circle(fill_opacity=1, radius=0.2).next_to(dot, RIGHT)
        self.add(dot, sq)
        self.wait(1)
        self.activate_zooming(animate=False)
        self.wait(1)
        self.play(dot.animate.shift(LEFT * 0.3))

        self.play(self.zoomed_camera.frame.animate.scale(4))
        self.play(self.zoomed_camera.frame.animate.shift(0.5 * DOWN))","Create a Manim animation where:  
1. A green dot is stationary while a small filled circle (radius 0.2) is placed to its right. Both appear initially.  
2. After a 1-second pause, a zoom frame (with a thick border) activates instantly without animation, showing a portion of the scene.  
3. The green dot then slowly moves left by 0.3 units.  
4. The zoom frame first scales up to 4× its original size, then smoothly shifts downward by half a unit.  

Include the zoom frame's rectangular display area with visible borders and transitions between scales and positions."
